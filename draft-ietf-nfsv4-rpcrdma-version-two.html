<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>RPC-over-RDMA Version 2 Protocol</title>
<meta content="Charles Lever" name="author">
<meta content="David Noveck" name="author">
<meta content="
       
This document specifies the second version
of a transport protocol that conveys
Remote Procedure Call (RPC) messages
using Remote Direct Memory Access (RDMA).
This version of the protocol is extensible.
 
    " name="description">
<meta content="xml2rfc 3.12.3" name="generator">
<meta content="NFS-Over-RDMA" name="keyword">
<meta content="draft-ietf-nfsv4-rpcrdma-version-two-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.12.3
    Python 3.9.7
    appdirs 1.4.4
    ConfigArgParse 1.3
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.6.5
    MarkupSafe 2.0.1
    pycountry 20.7.3
    pyflakes 2.3.1
    PyYAML 5.4.1
    requests 2.26.0
    setuptools 52.0.0
    six 1.16.0
-->
<link href="draft-ietf-nfsv4-rpcrdma-version-two.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cabin Condensed", sans-serif;
  font-weight: 600;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
dd.break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href].selfRef {
  color: var(--text-color);
}
a[href] {
  color: var(--link-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines */
  line-height: 0;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
}
@media screen {
  pre, svg {
    display: inline-block;
    overflow-x: auto;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  pre + .pilcrow, svg + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
tr:nth-child(2n) > td {
  background-color: var(--background-color);
}
tr:nth-child(2n+1) > td {
  background-color: var(--highlight-color);
}
thead+tbody > tr:nth-child(2n) > td {
  background-color: var(--highlight-color);
}
thead+tbody > tr:nth-child(2n+1) > td {
  background-color: var(--background-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
}
a.pilcrow[href] { color: var(--pilcrow-weak); }
a.pilcrow[href]:hover { text-decoration: none; }
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 8em;
}
#identifiers dt {
  width: var(--identifier-width);
  margin: 0;
  clear: left;
  float: left;
  text-align: right;
}
#identifiers dd {
  margin: 0 0 0 calc(1em + var(--identifier-width));
  min-width: 5em;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
#toc nav ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
#toc nav li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
#toc a.xref {
  white-space: normal;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}
address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc.active {
      opacity: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 8px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active nav {
    display: block;
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin-top: 2px;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  #toc nav > ul  {
    margin-bottom: 2em;
  }
  #toc ul {
    margin: 0 0 0 4px;
    font-size: var(--small-font-size);
  }
  #toc ul p, #toc ul li {
    margin: 2px 0;
    line-height: 22px;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Changes introduced to fix issues found during implementation */

/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}

/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin: 8px 0.5em 0;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table .text-left, table .text-left {
  text-align: left;
}
table .text-center, table .text-center {
  text-align: center;
}
table .text-right, table .text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 20em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Give the table caption label the same styling as the figcaption */

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  dd {
    page-break-before: avoid;
  }
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
/* Trick: a prefix match works because only black and white are allowed */
svg [stroke="black"], svg [stroke^="#000"] {
  stroke: var(--text-color);
}
svg [stroke="white"], svg [stroke^="#fff"] {
  stroke: var(--background-color);
}
svg [fill="black"], svg [fill^="#000"], svg :not([fill]) {
  fill: var(--text-color);
}
svg [stroke="fill"], svg [fill^="#fff"] {
  fill: var(--background-color);
}
}
</style>

</head>
<body>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">RPC-over-RDMA Version 2</td>
<td class="right">March 2022</td>
</tr></thead>
<tfoot><tr>
<td class="left">Lever &amp; Noveck</td>
<td class="center">Expires 15 September 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">Network File System Version 4</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-nfsv4-rpcrdma-version-two-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2022-03-14" class="published">14 March 2022</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-09-15">15 September 2022</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">C. Lever, <span class="editor">Ed.</span>
</div>
<div class="org">Oracle</div>
</div>
<div class="author">
      <div class="author-name">D. Noveck</div>
<div class="org">NetApp</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">RPC-over-RDMA Version 2 Protocol</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">
This document specifies the second version
of a transport protocol that conveys
Remote Procedure Call (RPC) messages
using Remote Direct Memory Access (RDMA).
This version of the protocol is extensible.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">
Discussion of this draft takes place
on the NFSv4 working group mailing list (nfsv4@ietf.org),
which is archived at
<span><a href="https://mailarchive.ietf.org/arch/browse/nfsv4/">https://mailarchive.ietf.org/arch/browse/nfsv4/</a></span>.
Working Group information can be found at
<span><a href="https://datatracker.ietf.org/wg/nfsv4/about/">https://datatracker.ietf.org/wg/nfsv4/about/</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">
The source for this draft is maintained in GitHub.
Suggested changes can be submitted as pull requests at
<span><a href="https://github.com/chucklever/i-d-rpcrdma-version-two">https://github.com/chucklever/i-d-rpcrdma-version-two</a></span>.
Instructions are on that page as well.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 15 September 2022.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-3">
            This document may contain material from IETF Documents or IETF
            Contributions published or made publicly available before November
            10, 2008. The person(s) controlling the copyright in some of this
            material may not have granted the IETF Trust the right to allow
            modifications of such material outside the IETF Standards Process.
            Without obtaining an adequate license from the person(s)
            controlling the copyright in such materials, this document may not
            be modified outside the IETF Standards Process, and derivative
            works of it may not be created outside the IETF Standards Process,
            except to format it for publication as an RFC or to translate it
            into languages other than English.<a href="#section-boilerplate.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="xref">1.1</a>.  <a href="#name-design-goals" class="xref">Design Goals</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="xref">1.2</a>.  <a href="#name-motivation-for-a-new-versio" class="xref">Motivation for a New Version</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-requirements-language" class="xref">Requirements Language</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-terminology" class="xref">Terminology</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-remote-procedure-calls" class="xref">Remote Procedure Calls</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-remote-direct-memory-access" class="xref">Remote Direct Memory Access</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-rpc-over-rdma-framework" class="xref">RPC-over-RDMA Framework</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-message-framing" class="xref">Message Framing</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-reliable-message-delivery" class="xref">Reliable Message Delivery</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-initial-connection-state" class="xref">Initial Connection State</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.  <a href="#name-using-direct-data-placement" class="xref">Using Direct Data Placement</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="xref">4.5</a>.  <a href="#name-encoding-chunks" class="xref">Encoding Chunks</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="xref">4.6</a>.  <a href="#name-reverse-direction-operation" class="xref">Reverse-Direction Operation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7">
                <p id="section-toc.1-1.4.2.7.1"><a href="#section-4.7" class="xref">4.7</a>.  <a href="#name-call-only-operation" class="xref">Call-Only Operation</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-transport-properties" class="xref">Transport Properties</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-transport-properties-model" class="xref">Transport Properties Model</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-current-transport-propertie" class="xref">Current Transport Properties</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-transport-messages" class="xref">Transport Messages</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-transport-header-types" class="xref">Transport Header Types</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-headers-and-chunks" class="xref">Headers and Chunks</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-header-types" class="xref">Header Types</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.4">
                <p id="section-toc.1-1.6.2.4.1"><a href="#section-6.4" class="xref">6.4</a>.  <a href="#name-transport-header-prefix" class="xref">Transport Header Prefix</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.5">
                <p id="section-toc.1-1.6.2.5.1"><a href="#section-6.5" class="xref">6.5</a>.  <a href="#name-remote-invalidation" class="xref">Remote Invalidation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.6">
                <p id="section-toc.1-1.6.2.6.1"><a href="#section-6.6" class="xref">6.6</a>.  <a href="#name-payload-formats" class="xref">Payload Formats</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-error-handling" class="xref">Error Handling</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-basic-transport-stream-pars" class="xref">Basic Transport Stream Parsing Errors</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-xdr-errors" class="xref">XDR Errors</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.  <a href="#name-responder-rdma-operational-" class="xref">Responder RDMA Operational Errors</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="xref">7.4</a>.  <a href="#name-other-operational-errors" class="xref">Other Operational Errors</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.5">
                <p id="section-toc.1-1.7.2.5.1"><a href="#section-7.5" class="xref">7.5</a>.  <a href="#name-rdma-transport-errors" class="xref">RDMA Transport Errors</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-xdr-protocol-definition" class="xref">XDR Protocol Definition</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="xref">8.1</a>.  <a href="#name-code-component-license" class="xref">Code Component License</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a href="#section-8.2" class="xref">8.2</a>.  <a href="#name-extraction-of-the-xdr-defin" class="xref">Extraction of the XDR Definition</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3">
                <p id="section-toc.1-1.8.2.3.1"><a href="#section-8.3" class="xref">8.3</a>.  <a href="#name-xdr-definition-for-rpc-over" class="xref">XDR Definition for RPC-over-RDMA Version 2 Core Structures</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.4">
                <p id="section-toc.1-1.8.2.4.1"><a href="#section-8.4" class="xref">8.4</a>.  <a href="#name-xdr-definition-for-rpc-over-" class="xref">XDR Definition for RPC-over-RDMA Version 2 Base Header Types</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.5">
                <p id="section-toc.1-1.8.2.5.1"><a href="#section-8.5" class="xref">8.5</a>.  <a href="#name-use-of-the-xdr-description" class="xref">Use of the XDR Description</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-rpc-bind-parameters" class="xref">RPC Bind Parameters</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-implementation-status" class="xref">Implementation Status</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-security-considerations" class="xref">Security Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="xref">11.1</a>.  <a href="#name-memory-protection" class="xref">Memory Protection</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="xref">11.2</a>.  <a href="#name-rpc-message-security" class="xref">RPC Message Security</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.3">
                <p id="section-toc.1-1.11.2.3.1"><a href="#section-11.3" class="xref">11.3</a>.  <a href="#name-transport-properties-2" class="xref">Transport Properties</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.4">
                <p id="section-toc.1-1.11.2.4.1"><a href="#section-11.4" class="xref">11.4</a>.  <a href="#name-host-authentication" class="xref">Host Authentication</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="xref">12</a>. <a href="#name-iana-considerations" class="xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="xref">13</a>. <a href="#name-references" class="xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a href="#section-13.1" class="xref">13.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a href="#section-13.2" class="xref">13.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-A" class="xref">Appendix A</a>.  <a href="#name-ulb-specifications" class="xref">ULB Specifications</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1">
                <p id="section-toc.1-1.14.2.1.1"><a href="#appendix-A.1" class="xref">A.1</a>.  <a href="#name-ddp-eligibility" class="xref">DDP-Eligibility</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.2">
                <p id="section-toc.1-1.14.2.2.1"><a href="#appendix-A.2" class="xref">A.2</a>.  <a href="#name-maximum-reply-size" class="xref">Maximum Reply Size</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.3">
                <p id="section-toc.1-1.14.2.3.1"><a href="#appendix-A.3" class="xref">A.3</a>.  <a href="#name-reverse-direction-operation-2" class="xref">Reverse-Direction Operation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.4">
                <p id="section-toc.1-1.14.2.4.1"><a href="#appendix-A.4" class="xref">A.4</a>.  <a href="#name-additional-considerations" class="xref">Additional Considerations</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.5">
                <p id="section-toc.1-1.14.2.5.1"><a href="#appendix-A.5" class="xref">A.5</a>.  <a href="#name-ulp-extensions" class="xref">ULP Extensions</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#appendix-B" class="xref">Appendix B</a>.  <a href="#name-extending-rpc-over-rdma-ver" class="xref">Extending RPC-over-RDMA Version 2</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15.2.1">
                <p id="section-toc.1-1.15.2.1.1"><a href="#appendix-B.1" class="xref">B.1</a>.  <a href="#name-documentation-requirements" class="xref">Documentation Requirements</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15.2.2">
                <p id="section-toc.1-1.15.2.2.1"><a href="#appendix-B.2" class="xref">B.2</a>.  <a href="#name-adding-new-header-types-to-" class="xref">Adding New Header Types to RPC-over-RDMA Version 2</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15.2.3">
                <p id="section-toc.1-1.15.2.3.1"><a href="#appendix-B.3" class="xref">B.3</a>.  <a href="#name-adding-new-transport-proper" class="xref">Adding New Transport properties to the Protocol</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15.2.4">
                <p id="section-toc.1-1.15.2.4.1"><a href="#appendix-B.4" class="xref">B.4</a>.  <a href="#name-adding-new-error-codes-to-t" class="xref">Adding New Error Codes to the Protocol</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#appendix-C" class="xref">Appendix C</a>.  <a href="#name-differences-from-rpc-over-r" class="xref">Differences from RPC-over-RDMA Version 1</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.1">
                <p id="section-toc.1-1.16.2.1.1"><a href="#appendix-C.1" class="xref">C.1</a>.  <a href="#name-changes-to-the-xdr-definiti" class="xref">Changes to the XDR Definition</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.2">
                <p id="section-toc.1-1.16.2.2.1"><a href="#appendix-C.2" class="xref">C.2</a>.  <a href="#name-transport-properties-3" class="xref">Transport Properties</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.3">
                <p id="section-toc.1-1.16.2.3.1"><a href="#appendix-C.3" class="xref">C.3</a>.  <a href="#name-credit-management-changes" class="xref">Credit Management Changes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.4">
                <p id="section-toc.1-1.16.2.4.1"><a href="#appendix-C.4" class="xref">C.4</a>.  <a href="#name-inline-threshold-changes" class="xref">Inline Threshold Changes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.5">
                <p id="section-toc.1-1.16.2.5.1"><a href="#appendix-C.5" class="xref">C.5</a>.  <a href="#name-message-continuation-change" class="xref">Message Continuation Changes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.6">
                <p id="section-toc.1-1.16.2.6.1"><a href="#appendix-C.6" class="xref">C.6</a>.  <a href="#name-host-authentication-changes" class="xref">Host Authentication Changes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.7">
                <p id="section-toc.1-1.16.2.7.1"><a href="#appendix-C.7" class="xref">C.7</a>.  <a href="#name-support-for-remote-invalida" class="xref">Support for Remote Invalidation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.8">
                <p id="section-toc.1-1.16.2.8.1"><a href="#appendix-C.8" class="xref">C.8</a>.  <a href="#name-integration-of-reverse-dire" class="xref">Integration of Reverse-Direction Operation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.9">
                <p id="section-toc.1-1.16.2.9.1"><a href="#appendix-C.9" class="xref">C.9</a>.  <a href="#name-error-reporting-changes" class="xref">Error Reporting Changes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16.2.10">
                <p id="section-toc.1-1.16.2.10.1"><a href="#appendix-C.10" class="xref">C.10</a>. <a href="#name-changes-in-terminology" class="xref">Changes in Terminology</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#appendix-D" class="xref"></a><a href="#name-acknowledgments" class="xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.18">
            <p id="section-toc.1-1.18.1"><a href="#appendix-E" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="section_72f6ba4a-aafb-4e9d-8b87-800ebccc5879">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">
Remote Direct Memory Access (RDMA)
<span>[<a href="#RFC5040" class="xref">RFC5040</a>]</span>
        <span>[<a href="#RFC5041" class="xref">RFC5041</a>]</span>
        <span>[<a href="#IBA" class="xref">IBA</a>]</span>
is a technique for moving data efficiently between network nodes.
By placing transferred data directly into destination buffers
using Direct Memory Access, RDMA delivers the reciprocal benefits of
faster data transfer
and
reduced host CPU overhead.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">
Open Network Computing Remote Procedure Call
(ONC RPC, often shortened in NFSv4 documents to RPC)
<span>[<a href="#RFC5531" class="xref">RFC5531</a>]</span>
is a Remote Procedure Call protocol
that runs over a variety of transports.
Most RPC implementations today use
UDP
<span>[<a href="#RFC0768" class="xref">RFC0768</a>]</span>
or
TCP
<span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span>.
On UDP, a datagram encapsulates each RPC message.
Within a TCP byte stream,
a record marking protocol delineates RPC messages.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">
An RDMA transport, too, conveys RPC messages
in a fashion that must be fully defined
if RPC implementations are to interoperate
when using RDMA to transport RPC transactions.
Although RDMA transports encapsulate messages like UDP,
they deliver them reliably and in order, like TCP.
Further, they implement a bulk data transfer service
not provided by traditional network transports.
Therefore, we treat RDMA as a novel transport type for RPC.<a href="#section-1-3" class="pilcrow">¶</a></p>
<div id="section_3ade56d8-45ea-4ab5-b97c-da817d3e0033">
<section id="section-1.1">
        <h3 id="name-design-goals">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-design-goals" class="section-name selfRef">Design Goals</a>
        </h3>
<p id="section-1.1-1">
The general mission of RPC-over-RDMA transports is to
leverage network hardware capabilities to
reduce host CPU needs related to the transport of RPC messages.
In particular, this includes
mitigating host interrupt rates
and
limiting the necessity to copy RPC payload bytes on receivers.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">
These hardware capabilities benefit both RPC clients and servers.
On balance, however, the RPC-over-RDMA protocol design approach
has been to bolster clients more than servers, as the client is
typically where applications are most hungry for CPU resources.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
<p id="section-1.1-3">
Additionally,
RPC-over-RDMA transports are designed to
support RPC applications transparently.
However, such transports can also provide mechanisms
that enable further optimization of data transfer
when RPC applications are structured
to exploit direct data placement.
In this context, the Network File System (NFS) family of protocols
(as described in
<span>[<a href="#RFC1094" class="xref">RFC1094</a>]</span>,
<span>[<a href="#RFC1813" class="xref">RFC1813</a>]</span>,
<span>[<a href="#RFC7530" class="xref">RFC7530</a>]</span>,
<span>[<a href="#RFC7862" class="xref">RFC7862</a>]</span>,
<span>[<a href="#RFC8881" class="xref">RFC8881</a>]</span>,
and subsequent NFSv4 minor versions)
are all potential beneficiaries of RPC-over-RDMA.<a href="#section-1.1-3" class="pilcrow">¶</a></p>
<p id="section-1.1-4">
A complete problem statement appears in
<span>[<a href="#RFC5532" class="xref">RFC5532</a>]</span>.<a href="#section-1.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_0a2befc3-b5d7-468e-a48e-97c46a9c1b40">
<section id="section-1.2">
        <h3 id="name-motivation-for-a-new-versio">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-motivation-for-a-new-versio" class="section-name selfRef">Motivation for a New Version</a>
        </h3>
<p id="section-1.2-1">
Storage administrators have broadly deployed
the RPC-over-RDMA version 1 protocol specified in
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>.
However, there are known shortcomings to this protocol:<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.2-2.1">
The protocol's default size of Receive buffers forces
the use of RDMA Read and Write transfers for small payloads,
and limits the size of reverse-direction messages.<a href="#section-1.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.2-2.2">
It is difficult to make optimizations or protocol fixes
that require changes to on-the-wire behavior.<a href="#section-1.2-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.2-2.3">
For some RPC procedures, the maximum reply size is
difficult or impossible for an RPC client to estimate
in advance.<a href="#section-1.2-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-1.2-3">
To address these issues in a way that preserves interoperation
with existing RPC-over-RDMA version 1 deployments,
the current document presents
an updated version of the RPC-over-RDMA transport protocol.<a href="#section-1.2-3" class="pilcrow">¶</a></p>
<p id="section-1.2-4">
This version of RPC-over-RDMA is extensible,
enabling the introduction of <span class="bcp14">OPTIONAL</span> extensions
without impacting existing implementations.
See
<a href="#section_d945b9f0-0666-4db7-9126-be57cf7b5f4f" class="xref">Appendix C.1</a>
for further discussion.
It introduces a mechanism to exchange implementation properties
to automatically provide further optimization of data transfer.<a href="#section-1.2-4" class="pilcrow">¶</a></p>
<p id="section-1.2-5">
This version also contains incremental changes that
relieve performance constraints
and
enable recovery from unusual corner cases.
These changes are outlined in
<a href="#section_c2574344-5aec-427d-a5ed-048d7fcc0d95" class="xref">Appendix C</a>
and include
a larger default inline threshold,
the ability to convey a single RPC message using multiple RDMA Send operations,
support for authentication of connection peers,
richer error reporting,
improved credit-based flow control,
and
support for Remote Invalidation.<a href="#section-1.2-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_ef1a2819-4d22-40af-8d38-fde10849c872">
<section id="section-2">
      <h2 id="name-requirements-language">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-requirements-language" class="section-name selfRef">Requirements Language</a>
      </h2>
<p id="section-2-1">
The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>",
"<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>",
"<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>",
"<span class="bcp14">SHOULD NOT</span>",
"<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
"<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>"
in this document are to be interpreted
as described in BCP 14
<span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span>
        <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span>
when, and only when, they appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_4dc39c9c-3770-491f-b674-f824e87e2143">
<section id="section-3">
      <h2 id="name-terminology">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-terminology" class="section-name selfRef">Terminology</a>
      </h2>
<div id="section_4d675e45-c377-48df-8029-c5c9f8c48f9f">
<section id="section-3.1">
        <h3 id="name-remote-procedure-calls">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-remote-procedure-calls" class="section-name selfRef">Remote Procedure Calls</a>
        </h3>
<p id="section-3.1-1">
This section highlights critical elements of the RPC protocol
<span>[<a href="#RFC5531" class="xref">RFC5531</a>]</span>
and
the External Data Representation (XDR)
<span>[<a href="#RFC4506" class="xref">RFC4506</a>]</span>
it uses.
RPC-over-RDMA version 2 enables
the transmission of RPC messges built using XDR
and
also uses XDR internally to describe its header format.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<div id="section_8d804fe5-c7c7-4c6c-92d8-888da10caaec">
<section id="section-3.1.1">
          <h4 id="name-upper-layer-protocols">
<a href="#section-3.1.1" class="section-number selfRef">3.1.1. </a><a href="#name-upper-layer-protocols" class="section-name selfRef">Upper-Layer Protocols</a>
          </h4>
<p id="section-3.1.1-1">
RPCs are an abstraction used to implement the operations of an Upper-Layer Protocol (ULP).
For RPC-over-RDMA, "ULP" refers to an RPC Program and Version tuple,
which is a versioned set of procedure calls that comprise a single well-defined API.
One example of a ULP is the Network File System Version 4.0
<span>[<a href="#RFC7530" class="xref">RFC7530</a>]</span>.
In the current document, the term "RPC consumer" refers to
an implementation of a ULP running on an RPC client.<a href="#section-3.1.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_17a77782-8b11-4fb5-af0b-e0da7759c10A">
<section id="section-3.1.2">
          <h4 id="name-rpc-procedures">
<a href="#section-3.1.2" class="section-number selfRef">3.1.2. </a><a href="#name-rpc-procedures" class="section-name selfRef">RPC Procedures</a>
          </h4>
<p id="section-3.1.2-1">
Like a local procedure call,
every RPC procedure has a set of "arguments" and a set of "results".
A calling context invokes an RPC procedure,
passing arguments to it,
and the procedure subsequently returns a set of results.
Unlike a local procedure call,
an RPC procedure is executed remotely rather than
in the local application's execution context.<a href="#section-3.1.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_97382254-b1a3-4e03-98e5-a0814b331bd0">
<section id="section-3.1.3">
          <h4 id="name-rpc-transactions">
<a href="#section-3.1.3" class="section-number selfRef">3.1.3. </a><a href="#name-rpc-transactions" class="section-name selfRef">RPC Transactions</a>
          </h4>
<p id="section-3.1.3-1">
The RPC protocol as described in
<span>[<a href="#RFC5531" class="xref">RFC5531</a>]</span>
is fundamentally a message-passing protocol
between one or more clients, where RPC consumers are running,
and a server, where a remote execution context is available
to process RPC transactions on behalf of these consumers.<a href="#section-3.1.3-1" class="pilcrow">¶</a></p>
<p id="section-3.1.3-2">
ONC RPC transactions consist of two types of messages:<a href="#section-3.1.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.3-3.1">
A CALL message, or "Call", requests work.
An RPC Call message is designated
by the value zero (0) in the message's msg_type field.<a href="#section-3.1.3-3.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.3-3.2">
A REPLY message, or "Reply",
reports the results of work requested by an RPC Call message.
An RPC Reply message is designated
by the value one (1) in the message's msg_type field.<a href="#section-3.1.3-3.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.3-4">
<span><a href="https://rfc-editor.org/rfc/rfc5531#section-9" class="relref">Section 9</a> of [<a href="#RFC5531" class="xref">RFC5531</a>]</span>
introduces the RPC transaction identifier,
or "XID" for short.
Each connection endpoint interprets the value of an XID
in the context of the message's msg_type field.<a href="#section-3.1.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.3-5.1">
The sender of a Call message generates an arbitrary XID value
for each RPC that is unique among outstanding Calls from that sender.<a href="#section-3.1.3-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.3-5.2">
The sender of a Reply message copies the XID of the initiating Call
to the Reply containing the results of that procedure.<a href="#section-3.1.3-5.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.3-6">
After receiving a Reply,
a Requester then matches the XID value in that Reply
with a Call it previously sent.<a href="#section-3.1.3-6" class="pilcrow">¶</a></p>
<p id="section-3.1.3-7">
The ratio of Call messages to Reply messages is typically
but not always one-to-one.<a href="#section-3.1.3-7" class="pilcrow">¶</a></p>
<p id="section-3.1.3-8">
The most common operational paradigm is when
a Requester sends a Call message to a Responder,
who then sends a Reply message back to the Requester
with the results of that procedure.
One Call message elicits a single Reply message in response.
A Responder never sends more than one Reply
for each received Call message.<a href="#section-3.1.3-8" class="pilcrow">¶</a></p>
<p id="section-3.1.3-9">
A "retransmission" occurs when a Requester sends
exactly the same Call message,
with the same arguments and XID, more than once.
A Requester can retransmit if it believes the network layer
or Responder has dropped a Call message,
or if the Responder's Reply has been likewise lost.
To prevent unnecessary network traffic or the execution
of non-idempotent procedures multiple times,
Requesters avoid retransmitting needlessly.<a href="#section-3.1.3-9" class="pilcrow">¶</a></p>
<p id="section-3.1.3-10">
In rare cases, an RPC procedure may not require any
results or even acknowledgement that the Responder
has executed the procedure.
In that case, the Requester sends a Call message
but no Reply is returned.
This document refers to that case as "Call-only".<a href="#section-3.1.3-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_7e64e30d-0519-449b-b0bf-45c3d103b0be">
<section id="section-3.1.4">
          <h4 id="name-message-serialization">
<a href="#section-3.1.4" class="section-number selfRef">3.1.4. </a><a href="#name-message-serialization" class="section-name selfRef">Message Serialization</a>
          </h4>
<p id="section-3.1.4-1">
RPC messages are always transmitted atomically.
RPC peers may interleave messages,
but the contents of individual messages
cannot be broken up or interleaved
without making the messages illegible.<a href="#section-3.1.4-1" class="pilcrow">¶</a></p>
<p id="section-3.1.4-2">
An RPC peer acting as a "Requester"
serializes the procedure's arguments
and
conveys them to a "Responder" endpoint via an RPC Call message.
A Call message contains an RPC protocol header with a unique XID,
a header describing the requested upper-layer operation,
and all arguments.<a href="#section-3.1.4-2" class="pilcrow">¶</a></p>
<p id="section-3.1.4-3">
An RPC peer acting as a "Responder"
deserializes these arguments and processes the requested procedure.
It then serializes the procedure's results into an RPC Reply message.
An RPC Reply message contains an RPC protocol header with the same XID,
a header describing the upper-layer reply,
and all results.<a href="#section-3.1.4-3" class="pilcrow">¶</a></p>
<p id="section-3.1.4-4">
The Requester deserializes the results
and
allows the RPC consumer to proceed.
At this point, the RPC transaction
designated by the XID in the RPC Call message is complete,
and the XID is retired.<a href="#section-3.1.4-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_63f47fcd-629b-4b00-aa8b-dbf836401581">
<section id="section-3.1.5">
          <h4 id="name-rpc-transports">
<a href="#section-3.1.5" class="section-number selfRef">3.1.5. </a><a href="#name-rpc-transports" class="section-name selfRef">RPC Transports</a>
          </h4>
<p id="section-3.1.5-1">
The role of an "RPC transport" is
to mediate the exchange of RPC messages
between Requesters and Responders,
bridging the gap between
the RPC message abstraction
and
the native operations of a network transport
(e.g., a socket).<a href="#section-3.1.5-1" class="pilcrow">¶</a></p>
<p id="section-3.1.5-2">
When an RPC transport type is connection-oriented,
RPC client endpoints initiate transport connections,
while RPC server endpoints wait passively to accept incoming connection requests.
RPC messages may also be exchanged without a connection association.
Because RPC-over-RDMA is a connection-oriented RPC transport,
connectionless operation is not discussed further in the current document.<a href="#section-3.1.5-2" class="pilcrow">¶</a></p>
<div id="section_7aafb376-73d8-4fa1-8888-97a02c9a58c1">
<section id="section-3.1.5.1">
            <h5 id="name-transport-failure-recovery">
<a href="#section-3.1.5.1" class="section-number selfRef">3.1.5.1. </a><a href="#name-transport-failure-recovery" class="section-name selfRef">Transport Failure Recovery</a>
            </h5>
<p id="section-3.1.5.1-1">
So that appropriate and timely recovery action can be taken,
the transport implementation is responsible for notifying
a Requester when an RPC Call or Reply was not able to be conveyed.
Recovery can take the form of establishing a new connection,
re-sending RPC Calls, or terminating RPC transactions pending
on the Requester.<a href="#section-3.1.5.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1.5.1-2">
For instance, a connection loss may occur after a Responder
has received an RPC Call but before it can send the matching RPC Reply.
Once the transport notifies the Requester of the connection loss,
the Requester can re-send all pending RPC Calls on a fresh connection.<a href="#section-3.1.5.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_2432566f-67e7-4f35-8ec4-9ed44cecd8cc">
<section id="section-3.1.5.2">
            <h5 id="name-forward-direction">
<a href="#section-3.1.5.2" class="section-number selfRef">3.1.5.2. </a><a href="#name-forward-direction" class="section-name selfRef">Forward Direction</a>
            </h5>
<p id="section-3.1.5.2-1">
Traditionally, an RPC client acts as a Requester,
while an RPC service acts as a Responder.
The current document
refers to this direction of RPC message passing
as "forward-direction" operation.<a href="#section-3.1.5.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_189a59d0-9235-4c1e-a76f-ea2b20fd6c94">
<section id="section-3.1.5.3">
            <h5 id="name-reverse-direction">
<a href="#section-3.1.5.3" class="section-number selfRef">3.1.5.3. </a><a href="#name-reverse-direction" class="section-name selfRef">Reverse-Direction</a>
            </h5>
<p id="section-3.1.5.3-1">
The RPC specification
<span>[<a href="#RFC5531" class="xref">RFC5531</a>]</span>
does not forbid performing RPC transactions
in the other direction.
An RPC service endpoint can act as a Requester,
in which case an RPC client endpoint acts as a Responder.
This direction of RPC message passing is known as
"reverse-direction" operation.<a href="#section-3.1.5.3-1" class="pilcrow">¶</a></p>
<p id="section-3.1.5.3-2">
During reverse-direction operation,
an RPC client is responsible
for establishing transport connections,
even though the RPC server originates RPC Calls.<a href="#section-3.1.5.3-2" class="pilcrow">¶</a></p>
<p id="section-3.1.5.3-3">
RPC clients and servers are usually optimized
to perform and scale well when handling traffic
in the forward direction.
They might not be prepared to handle operation
in the reverse direction.
Not until NFS version 4.1
<span>[<a href="#RFC8881" class="xref">RFC8881</a>]</span>
has there been a strong need
to handle reverse-direction operation.<a href="#section-3.1.5.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_05f24e3b-ad49-4370-a0fe-477b0f1364aa">
<section id="section-3.1.5.4">
            <h5 id="name-bi-directional-operation">
<a href="#section-3.1.5.4" class="section-number selfRef">3.1.5.4. </a><a href="#name-bi-directional-operation" class="section-name selfRef">Bi-directional Operation</a>
            </h5>
<p id="section-3.1.5.4-1">
A pair of connected RPC endpoints may choose to use
only forward-direction
or
only reverse-direction operation
on a particular transport connection.
Or, these endpoints may send Calls
in both directions concurrently
on the same transport connection.<a href="#section-3.1.5.4-1" class="pilcrow">¶</a></p>
<p id="section-3.1.5.4-2">
"Bi-directional operation" occurs when both transport endpoints
act as a Requester and a Responder at the same time
on a single connection.<a href="#section-3.1.5.4-2" class="pilcrow">¶</a></p>
<p id="section-3.1.5.4-3">
Bi-directionality is an extension
of RPC transport connection sharing.
Two RPC endpoints wish to exchange
independent RPC messages over a shared connection
but in opposite directions.
These messages may or may not be related
to the same workloads or RPC Programs.<a href="#section-3.1.5.4-3" class="pilcrow">¶</a></p>
<p id="section-3.1.5.4-4">
During bi-directional operation,
forward- and reverse- direction XIDs
are typically generated
on distinct hosts by possibly different algorithms.
There is no coordination between the generation of XIDs
used in forward-direction and reverse-direction operation.<a href="#section-3.1.5.4-4" class="pilcrow">¶</a></p>
<p id="section-3.1.5.4-5">
Therefore, a forward-direction Requester
<span class="bcp14">MAY</span> use the same XID value at the same time
as a reverse-direction Requester
on the same transport connection.
Although such concurrent requests use the same XID value,
they represent distinct RPC transactions.<a href="#section-3.1.5.4-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_98bdc62c-0af4-4379-8b5c-6d98b7a520c7">
<section id="section-3.1.6">
          <h4 id="name-external-data-representatio">
<a href="#section-3.1.6" class="section-number selfRef">3.1.6. </a><a href="#name-external-data-representatio" class="section-name selfRef">External Data Representation</a>
          </h4>
<p id="section-3.1.6-1">
One cannot assume that all Requesters and Responders
represent data objects in the same way internally.
RPC uses External Data Representation (XDR)
to translate native data types and serialize arguments and results
<span>[<a href="#RFC4506" class="xref">RFC4506</a>]</span>.<a href="#section-3.1.6-1" class="pilcrow">¶</a></p>
<p id="section-3.1.6-2">
XDR encodes data independently
of the endianness or size of host-native data types,
enabling unambiguous decoding of data by a receiver.<a href="#section-3.1.6-2" class="pilcrow">¶</a></p>
<p id="section-3.1.6-3">
XDR assumes only that the number of bits in a byte (octet)
and
their order are the same on both endpoints and the physical network.
The smallest indivisible unit of XDR encoding is a group of four octets.
XDR can also flatten
lists,
arrays,
and
other complex data types
into a stream of bytes.<a href="#section-3.1.6-3" class="pilcrow">¶</a></p>
<p id="section-3.1.6-4">
We refer to a serialized stream of bytes
that is the result of XDR encoding
as an "XDR stream".
A sender encodes native data
into an XDR stream and then transmits that stream to a receiver.
The receiver decodes incoming XDR byte streams
into its native data representation format.<a href="#section-3.1.6-4" class="pilcrow">¶</a></p>
<div id="section_c6d3092c-99e6-4cce-b377-fffc4862929F">
<section id="section-3.1.6.1">
            <h5 id="name-xdr-opaque-data">
<a href="#section-3.1.6.1" class="section-number selfRef">3.1.6.1. </a><a href="#name-xdr-opaque-data" class="section-name selfRef">XDR Opaque Data</a>
            </h5>
<p id="section-3.1.6.1-1">
Sometimes, a data item is to be transferred as-is,
without encoding or decoding.
We refer to the contents of such a data item as "opaque data".
XDR encoding places the content of opaque data items
directly into an XDR stream without altering it in any way.
ULPs or applications perform
any needed data translation in this case.
Examples of opaque data items include the content of files
or generic byte strings.<a href="#section-3.1.6.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_c210323f-c524-4e98-a02d-23549a4bebc5">
<section id="section-3.1.6.2">
            <h5 id="name-xdr-roundup">
<a href="#section-3.1.6.2" class="section-number selfRef">3.1.6.2. </a><a href="#name-xdr-roundup" class="section-name selfRef">XDR Roundup</a>
            </h5>
<p id="section-3.1.6.2-1">
The number of octets in a variable-length data item
precedes that item in an XDR stream.
If the size of an encoded data item is not a multiple of four octets,
the sender appends octets containing zero after the end of the data item.
These zero octets shift the next encoded data item in the XDR stream
so that it always starts on a four-octet boundary.
The addition of extra octets does not change
the encoded size of the data item.
Receivers do not expose the extra octets to ULPs.<a href="#section-3.1.6.2-1" class="pilcrow">¶</a></p>
<p id="section-3.1.6.2-2">
We refer to this technique as "XDR roundup",
and the extra octets as "XDR roundup padding".<a href="#section-3.1.6.2-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="section_de830270-64ed-4510-ac25-29837d352031">
<section id="section-3.2">
        <h3 id="name-remote-direct-memory-access">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-remote-direct-memory-access" class="section-name selfRef">Remote Direct Memory Access</a>
        </h3>
<p id="section-3.2-1">
When a third party transfers large RPC payloads,
RPC Requesters and Responders can become more efficient.
An example of such a third party might be
an intelligent network interface
(data movement offload),
which places data in the receiver's memory so that
no additional adjustment of data alignment is necessary
(direct data placement or "DDP").
RDMA transports enable both of these optimizations.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2-2">
In the current document, the standalone term "RDMA" refers to
the physical mechanism an RDMA transport utilizes when moving data.<a href="#section-3.2-2" class="pilcrow">¶</a></p>
<div id="section_1b97ecfd-7aba-4299-9007-dab28ac76f81">
<section id="section-3.2.1">
          <h4 id="name-direct-data-placement">
<a href="#section-3.2.1" class="section-number selfRef">3.2.1. </a><a href="#name-direct-data-placement" class="section-name selfRef">Direct Data Placement</a>
          </h4>
<p id="section-3.2.1-1">
Typically, RPC implementations copy
the contents of RPC messages into a buffer before being sent.
An efficient RPC implementation sends bulk data
without first copying it into a separate send buffer.<a href="#section-3.2.1-1" class="pilcrow">¶</a></p>
<p id="section-3.2.1-2">
However, socket-based RPC implementations
are often unable to receive data directly
into its final place in memory.
Receivers often need to copy incoming data
to finish an RPC operation,
if only to adjust data alignment.<a href="#section-3.2.1-2" class="pilcrow">¶</a></p>
<p id="section-3.2.1-3">
Although it may not be efficient,
before an RDMA transfer, a sender may copy data into an intermediate buffer.
After an RDMA transfer, a receiver may copy that data again to its final destination.
In this document, the term "DDP" refers to
any optimized data transfer where a receiving host's CPU
does not move transferred data
to another location after arrival.<a href="#section-3.2.1-3" class="pilcrow">¶</a></p>
<p id="section-3.2.1-4">
RPC-over-RDMA version 2 enables the use of RDMA Read and Write operations
to achieve both data movement offload and DDP.
However, note that
not all RDMA-based data transfer qualifies as DDP,
and
some mechanisms that do not employ explicit RDMA can place data directly.<a href="#section-3.2.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_6903045e-bd1c-4e12-bf96-6b534989f46A">
<section id="section-3.2.2">
          <h4 id="name-rdma-transport-operation">
<a href="#section-3.2.2" class="section-number selfRef">3.2.2. </a><a href="#name-rdma-transport-operation" class="section-name selfRef">RDMA Transport Operation</a>
          </h4>
<p id="section-3.2.2-1">
RDMA transports require that
RDMA consumers provision resources in advance
to achieve good performance during receive operations.
An RDMA consumer might provide Receive buffers in advance
by posting an RDMA Receive Work Request
for every expected RDMA Send from a remote peer.
These buffers are provided
before the remote peer posts RDMA Send Work Requests.
Thus this is often referred to as "pre-posting" buffers.<a href="#section-3.2.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2.2-2">
An RDMA Receive Work Request remains outstanding
until the RDMA provider matches it to an inbound Send operation.
The resources associated with that Receive must be retained in
host memory, or "pinned", until the Receive completes.<a href="#section-3.2.2-2" class="pilcrow">¶</a></p>
<p id="section-3.2.2-3">
Given these tenets of operation,
the RPC-over-RDMA version 2 protocol assumes
each transport provides the following abstract operations.
A more complete discussion of these operations appears in
<span>[<a href="#RFC5040" class="xref">RFC5040</a>]</span>.<a href="#section-3.2.2-3" class="pilcrow">¶</a></p>
<div id="section_90f88ba5-5ad6-4ac1-b40d-ed9247e61ca5">
<section id="section-3.2.2.1">
            <h5 id="name-memory-registration">
<a href="#section-3.2.2.1" class="section-number selfRef">3.2.2.1. </a><a href="#name-memory-registration" class="section-name selfRef">Memory Registration</a>
            </h5>
<p id="section-3.2.2.1-1">
Memory registration assigns a steering tag
to a region of memory,
permitting the RDMA provider
to perform data-transfer operations.
The RPC-over-RDMA version 2 protocol assumes that
a steering tag of no more than 32 bits and memory
addresses of up to 64 bits in length
identifies each registered memory region.<a href="#section-3.2.2.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_07bba55f-c48f-474c-918b-db6c9d2325dd">
<section id="section-3.2.2.2">
            <h5 id="name-rdma-send">
<a href="#section-3.2.2.2" class="section-number selfRef">3.2.2.2. </a><a href="#name-rdma-send" class="section-name selfRef">RDMA Send</a>
            </h5>
<p id="section-3.2.2.2-1">
The RDMA provider supports an RDMA Send operation,
with completion signaled on the receiving peer
after the RDMA provider has placed data in a pre-posted buffer.
Sends complete at the receiver
in the order they were posted at the sender.
The size of the remote peer's pre-posted buffers
limits the amount of data
that can be transferred by a single RDMA Send operation.<a href="#section-3.2.2.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_9be6a44c-1ea5-4ccd-b188-ee04e930497b">
<section id="section-3.2.2.3">
            <h5 id="name-rdma-receive">
<a href="#section-3.2.2.3" class="section-number selfRef">3.2.2.3. </a><a href="#name-rdma-receive" class="section-name selfRef">RDMA Receive</a>
            </h5>
<p id="section-3.2.2.3-1">
The RDMA provider supports an RDMA Receive operation
to receive data conveyed by incoming RDMA Send operations.
To reduce the amount of memory that must remain pinned
awaiting incoming Sends,
the amount of memory posted per Receive is limited.
The RDMA consumer (in this case, the RPC-over-RDMA version 2 protocol)
provides flow control to prevent overrunning receiver resources.<a href="#section-3.2.2.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_cfd79bce-e8e9-4a51-b43a-b747af6213f4">
<section id="section-3.2.2.4">
            <h5 id="name-rdma-write">
<a href="#section-3.2.2.4" class="section-number selfRef">3.2.2.4. </a><a href="#name-rdma-write" class="section-name selfRef">RDMA Write</a>
            </h5>
<p id="section-3.2.2.4-1">
The RDMA provider supports an RDMA Write operation
to place data directly into a remote memory region.
The local host initiates an RDMA Write
and the RDMA provider signals completion there.
The remote RDMA provider does not signal completion
on the remote peer.
The local host provides
the steering tag,
the memory address,
and
the length of the remote peer's memory region.<a href="#section-3.2.2.4-1" class="pilcrow">¶</a></p>
<p id="section-3.2.2.4-2">
RDMA Writes are not ordered relative to one another,
but are ordered relative to RDMA Sends.
Thus, a subsequent RDMA Send completion
signaled on the local peer
guarantees that prior RDMA Write data
has been successfully placed in the remote peer's memory.<a href="#section-3.2.2.4-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_f37121af-49ff-4575-a699-7310f4ae1296">
<section id="section-3.2.2.5">
            <h5 id="name-rdma-read">
<a href="#section-3.2.2.5" class="section-number selfRef">3.2.2.5. </a><a href="#name-rdma-read" class="section-name selfRef">RDMA Read</a>
            </h5>
<p id="section-3.2.2.5-1">
The RDMA provider supports an RDMA Read operation
to place remote source data directly into local memory.
The local host initiates an RDMA Read
and and the RDMA provider signals completion there.
The remote RDMA provider does not signal
completion on the remote peer.
The local host provides
the steering tags,
the memory addresses,
and the lengths for the remote source
and
local destination memory regions.<a href="#section-3.2.2.5-1" class="pilcrow">¶</a></p>
<p id="section-3.2.2.5-2">
The RDMA consumer (in this case, the RPC-over-RDMA version 2 protocol)
signals Read completion to the remote peer
as part of a subsequent RDMA Send message.
The remote peer can then invalidate steering tags
and
subsequently free associated source memory regions.<a href="#section-3.2.2.5-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="section_5ae4b016-9b44-4649-9021-5ae851ac9326">
<section id="section-4">
      <h2 id="name-rpc-over-rdma-framework">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-rpc-over-rdma-framework" class="section-name selfRef">RPC-over-RDMA Framework</a>
      </h2>
<p id="section-4-1">
Before an RDMA data transfer can occur,
an endpoint first exposes regions of its memory to a remote endpoint.
The remote endpoint then initiates RDMA Read and Write operations
against the exposed memory.
A "transfer model" designates
which endpoint exposes its memory
and
which is responsible for initiating the transfer of data.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">
In RPC-over-RDMA version 2,
only Requesters expose their memory to the Responder,
and only Responders initiate RDMA Read and Write operations.
Read access to memory regions enables the Responder to
pull RPC arguments
or
whole RPC Calls from each Requester.
The Responder pushes
RPC results
or
whole RPC Replies to a Requester's
memory regions to which it has write access.<a href="#section-4-2" class="pilcrow">¶</a></p>
<div id="section_195e0288-862d-40bb-a259-4239930c728a">
<section id="section-4.1">
        <h3 id="name-message-framing">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-message-framing" class="section-name selfRef">Message Framing</a>
        </h3>
<p id="section-4.1-1">
Each RPC-over-RDMA version 2 message consists of at most two XDR streams:<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-2.1">
The "Transport stream" contains a header that describes
and controls the transfer of the Payload stream
in this RPC-over-RDMA message.
Every RDMA Send on an RPC-over-RDMA version 2 connection
<span class="bcp14">MUST</span> begin with a Transport stream.<a href="#section-4.1-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-4.1-2.2">
The "Payload stream" contains part or all of a single RPC message.
The sender <span class="bcp14">MAY</span> divide an RPC message at any convenient boundary
but
<span class="bcp14">MUST</span> send RPC message fragments in XDR stream order
and
<span class="bcp14">MUST NOT</span> interleave Payload streams from multiple RPC messages.<a href="#section-4.1-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.1-3">
The RPC-over-RDMA framing mechanism described in this section
replaces all other RPC framing mechanisms.
Connection peers use RPC-over-RDMA framing
even when the underlying RDMA protocol runs
on a transport type with well-defined RPC framing, such as TCP.
However, a ULP can negotiate the use of RDMA,
dynamically enabling the use of RPC-over-RDMA on a connection
established on some other transport type.
Because RPC framing delimits an entire RPC request or reply,
the resulting shift in framing must occur between distinct RPC messages,
and in concert with the underlying transport.<a href="#section-4.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_130ce79c-8b13-479e-8108-a943024047dD">
<section id="section-4.2">
        <h3 id="name-reliable-message-delivery">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-reliable-message-delivery" class="section-name selfRef">Reliable Message Delivery</a>
        </h3>
<p id="section-4.2-1">
RPC-over-RDMA provides
a reliable
and
in-order
data transport service for RPC Calls and Replies.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">
RPC-over-RDMA transports
<span class="bcp14">MUST</span>
operate only on a reliable Queue Pair (QP) such as
the RDMA RC (Reliable Connected) QP type
as defined in Section 9.7.7 of
<span>[<a href="#IBA" class="xref">IBA</a>]</span>.
The Marker PDU Aligned (MPA) protocol
<span>[<a href="#RFC5044" class="xref">RFC5044</a>]</span>,
when deployed on a reliable transport such as TCP,
provides similar functionality.
Using a reliable QP type ensures
in-transit data integrity
and
proper recovery from packet loss in the lower layers.<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2-3">
If any pre-posted Receive buffer on the connection
is not large enough to contain an incoming message,
the receiving RDMA provider
cannot deliver that message to the upper-layer consumer.
Likewise, if no pre-posted Receive buffer is available
to accept an incoming message,
the receiving RDMA provide
cannot pass that message to the consumer.
Exceeding these limits results in
a transition to a QP error state,
the loss of an in-flight message,
and
the potential loss of the connection.<a href="#section-4.2-3" class="pilcrow">¶</a></p>
<p id="section-4.2-4">
Therefore, senders need to respect peer receiver resource limits
to ensure that the transport service
can deliver every message reliably.
Two operational parameters communicate these limits
between RPC-over-RDMA peers:
credits and inline threshold.<a href="#section-4.2-4" class="pilcrow">¶</a></p>
<div id="section_45c67eb8-8dc6-47c3-8555-14270f1514bF">
<section id="section-4.2.1">
          <h4 id="name-flow-control">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-flow-control" class="section-name selfRef">Flow Control</a>
          </h4>
<p id="section-4.2.1-1">
RPC-over-RDMA version 2 employs
end-to-end credit-based flow control on each connection
to prevent a sender from transmitting more messages
than a receiver is prepared to accept
<span>[<a href="#CBFC" class="xref">CBFC</a>]</span>.
Credit-based flow control is relatively simple, providing
automated management of receive buffer allocation
and
robust operation in the face of bursty traffic
while enabling effective pipelining.
The RPC-over-RDMA version 2 flow control mechanism relies on
reliable and in-order message delivery guarantees
provided by the underlying RDMA transport service.<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1-2">
An RPC-over-RDMA version 2 credit represents
the capability to convey
exactly one RPC-over-RDMA version 2 message,
regardless of its size,
via an RDMA Send/Receive pair.
Because an RPC-over-RDMA version 2 connection is full-duplex,
each connection peer has its own set of credits.
The two peers manage their credit limits independently,
although they communicate these values
by piggy-backing them on a message in the opposite direction.<a href="#section-4.2.1-2" class="pilcrow">¶</a></p>
<p id="section-4.2.1-3">
Each peer tracks four critical values for each connection.
The peer uses these values to determine when it is safe to send
a message on the connection.<a href="#section-4.2.1-3" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.2.1-4">
            <dt id="section-4.2.1-4.1">Sent message count:</dt>
            <dd style="margin-left: 1.5em" id="section-4.2.1-4.2">
The total number of RDMA Send channel operations
the peer has posted on the connection.
The peer
<span class="bcp14">MUST</span>
set this value to zero (0) when a connection is first established.<a href="#section-4.2.1-4.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-4.2.1-4.3">Received message count:</dt>
            <dd style="margin-left: 1.5em" id="section-4.2.1-4.4">
The total number of RDMA Receive channel operations
that have completed on the connection.
The peer
<span class="bcp14">MUST</span>
set this value to zero (0) when a connection is first established.<a href="#section-4.2.1-4.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-4.2.1-4.5">Advertised credits:</dt>
            <dd style="margin-left: 1.5em" id="section-4.2.1-4.6">
The number of messages the peer is prepared to receive.
This value is typically equal to or less than
the number of RDMA Receive channel operations
that are currently pending on the connection.<a href="#section-4.2.1-4.6" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-4.2.1-4.7">Received credits:</dt>
            <dd style="margin-left: 1.5em" id="section-4.2.1-4.8">
The value in the rdma_start.rdma_credit field
in the most recently received message on the connection.
The peer
<span class="bcp14">MUST</span>
set this value to one (1) when a connection is first established.<a href="#section-4.2.1-4.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.2.1-5">
When constructing an RPC-over-RDMA header to be sent,
a sender
<span class="bcp14">MUST</span>
set the header's rdma_start.rdma_credit field
to the sum of the connection's "Sent message count"
and "Advertised credits" values.
The sender
<span class="bcp14">MUST NOT</span>
post this message if the connection's "Sent message counter"
is greater than the connection's current "Received credits" value.
To handle counter wrapping, the sender uses appropriate modulo
arithmetic to perform this comparison.<a href="#section-4.2.1-5" class="pilcrow">¶</a></p>
<p id="section-4.2.1-6">
Because the rdma_start.rdma_credit field is 32 bits wide,
credit limit values
<span class="bcp14">MUST</span>
be less than 2^31 - 1.
For a given bandwidth-delay product,
a peer selects an "Advertised credits" value
that is large enough to maximize throughput
while not overwhelming its local memory resources.<a href="#section-4.2.1-6" class="pilcrow">¶</a></p>
<p id="section-4.2.1-7">
A peer
<span class="bcp14">MAY</span>
adjust its "Advertised credits"
to match the needs or policies in effect on either peer.
For instance, a peer may reduce its "Advertised credits"
to accommodate the available resources in a Shared Receive Queue.
Certain RDMA implementations may impose additional flow-control restrictions,
such as limits on RDMA Read operations in progress at the Responder.
Accommodation of such checks is considered
the responsibility of each RPC-over-RDMA version 2 implementation.<a href="#section-4.2.1-7" class="pilcrow">¶</a></p>
<div id="section_f6348562-97f8-4413-96d7-bde3ff57b375">
<section id="section-4.2.1.1">
            <h5 id="name-asynchronous-credit-grants">
<a href="#section-4.2.1.1" class="section-number selfRef">4.2.1.1. </a><a href="#name-asynchronous-credit-grants" class="section-name selfRef">Asynchronous Credit Grants</a>
            </h5>
<p id="section-4.2.1.1-1">
Credit accounting information is usually piggy-backed
on payload-bearing messages.
However, on occasion, a peer might need to
reset its credit limit without sending an RPC payload.
A receiving peer can send a message using a special header type
when the sender's credit limit approaches exhaustion
during a stream of unacknowledged messages.
See
<a href="#section_d7b171ca-326d-45ed-bfa6-eca86ae4a62e" class="xref">Section 6.3.2</a>
for information about this header type.<a href="#section-4.2.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1.1-2">
Unlike RPC-over-RDMA version 1,
the credit grant on an RPC-over-RDMA version 2
connection
<span class="bcp14">MAY</span>
be zero.
In that case, the sender waits
until the receiver sends it an asynchronous credit refresh.
To prevent a sender from ever having to wait for a credit refresh,
a good receiver implementation provides a credit refresh
before half its credit limit is exceeded.<a href="#section-4.2.1.1-2" class="pilcrow">¶</a></p>
<p id="section-4.2.1.1-3">
To prevent transport deadlock,
receivers
<span class="bcp14">MUST</span>
always be in a position to receive
one asynchronous credit update message,
in addition to payload-bearing messages.
A receiver can do this is by
posting one more RDMA Receive
than its "Advertised credits" value.<a href="#section-4.2.1.1-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_653e7ab4-782f-43f2-947f-d097ada8b3c9">
<section id="section-4.2.2">
          <h4 id="name-inline-threshold">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-inline-threshold" class="section-name selfRef">Inline Threshold</a>
          </h4>
<p id="section-4.2.2-1">
An "inline threshold" value is the largest message size
(in octets) that can be conveyed in one direction between
peer implementations using RDMA Send and Receive channel operations.
An inline threshold value is
less than or equal to
the largest number of octets
the sender can post in a single RDMA Send operation.
It is also
less than or equal to
the largest number of octets
the receiver can reliably accept via a single RDMA Receive operation.<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.2-2">
Each connection has two inline threshold values.
There is one for messages flowing from Requester-to-Responder
(referred to as the "call inline threshold"),
and one for messages flowing from Responder-to-Requester
(referred to as the "reply inline threshold").<a href="#section-4.2.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2.2-3">
Peers can advertise their inline threshold values
via RPC-over-RDMA version 2 Transport Properties (see
<a href="#section_86248e99-ca60-478a-8aff-3fb387410077" class="xref">Section 5</a>).
In the absence of an exchange of Transport Properties,
connection peers
<span class="bcp14">MUST</span>
assume both inline thresholds are 4096 octets.<a href="#section-4.2.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_9563f1f0-28a7-48e1-a752-e842575c6539">
<section id="section-4.3">
        <h3 id="name-initial-connection-state">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-initial-connection-state" class="section-name selfRef">Initial Connection State</a>
        </h3>
<p id="section-4.3-1">
Immediately upon connection establishment, both peers
<span class="bcp14">MUST</span>
allow only one outstanding RPC-over-RDMA message
on the connection at a time
until both the transport protocol version is established
and both peers have received an initial credit limit.
Note that because RPC-over-RDMA versions 1 and 2 each use
a different flow control mechanism,
the meaning of the value in the rdma_start.rdma_credit field
depends on the value in the rdma_start.vers field.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">
The second word of each transport header conveys
the transport protocol version.
Immediately after the client establishes a connection,
it sends a single valid RPC-over-RDMA message
with the value two (2) in the rdma_start.rdma_vers field.
Because the server might support
only RPC-over-RDMA version 1,
this initial message <span class="bcp14">MUST NOT</span> be larger than
the version 1 default inline threshold of 1024 octets.<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<div id="section_8db4c54e-c1ce-43ba-93b4-031e829960f5">
<section id="section-4.3.1">
          <h4 id="name-server-supports-rpc-over-rd">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-server-supports-rpc-over-rd" class="section-name selfRef">Server Supports RPC-over-RDMA Version 2</a>
          </h4>
<p id="section-4.3.1-1">
If the server supports RPC-over-RDMA version 2,
it sends RPC-over-RDMA messages back to the client
with the value two (2) in the rdma_start.rdma_vers field.
Both peers may assume the default inline threshold value
for RPC-over-RDMA version 2 connections (4096 octets).<a href="#section-4.3.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_bedc4e66-4295-4dd6-8ac9-dd06907a08ad">
<section id="section-4.3.2">
          <h4 id="name-server-does-not-support-rpc">
<a href="#section-4.3.2" class="section-number selfRef">4.3.2. </a><a href="#name-server-does-not-support-rpc" class="section-name selfRef">Server Does Not Support RPC-over-RDMA Version 2</a>
          </h4>
<p id="section-4.3.2-1">
If the server does not support RPC-over-RDMA version 2,
it <span class="bcp14">MUST</span> send an RPC-over-RDMA message to the client
with an XID that matches the client's first message,
RDMA2_ERROR in the rdma_start.rdma_htype field,
and with the error code RDMA2_ERR_VERS.
This message also reports the range
of RPC-over-RDMA protocol versions that the server supports.
To continue operation, the client selects
a protocol version in that range
for subsequent messages on this connection.<a href="#section-4.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.3.2-2">
If the connection is dropped immediately after an
RDMA2_ERROR/RDMA2_ERR_VERS message is received,
the client should try to avoid a version negotiation loop
when re-establishing another connection.
It can assume that the server
does not support RPC-over-RDMA version 2.
A client can assume the same situation
(i.e., no server support for RPC-over-RDMA version 2)
if the initial negotiation message is lost or dropped.
Once the version negotiation exchange is complete,
both peers may use the default inline threshold value
for the negotiated transport protocol version.<a href="#section-4.3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_1ffe4c69-b516-476a-bba7-41863709f48d">
<section id="section-4.3.3">
          <h4 id="name-client-does-not-support-rpc">
<a href="#section-4.3.3" class="section-number selfRef">4.3.3. </a><a href="#name-client-does-not-support-rpc" class="section-name selfRef">Client Does Not Support RPC-over-RDMA Version 2</a>
          </h4>
<p id="section-4.3.3-1">
The server examines the RPC-over-RDMA protocol version
used in the first RPC-over-RDMA message it receives.
If it supports this protocol version,
it <span class="bcp14">MUST</span> use it in all subsequent messages it sends on that connection.
The client <span class="bcp14">MUST NOT</span> change the protocol version
for the duration of the connection.<a href="#section-4.3.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_cfa8877c-b905-455d-b420-bf7a4a7f7829">
<section id="section-4.4">
        <h3 id="name-using-direct-data-placement">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-using-direct-data-placement" class="section-name selfRef">Using Direct Data Placement</a>
        </h3>
<p id="section-4.4-1">
RPC-over-RDMA version 2 provides a mechanism
for moving part of an RPC message via a data transfer
distinct from RDMA Send and Receive.
For example,
a sender can remove one or more XDR data items from the Payload stream.
These items are then conveyed via other mechanisms,
such as one or more RDMA Read or Write operations.<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<div id="section_8966c401-1714-413c-9384-b1f71f0a920d">
<section id="section-4.4.1">
          <h4 id="name-chunks-and-segments">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-chunks-and-segments" class="section-name selfRef">Chunks and Segments</a>
          </h4>
<p id="section-4.4.1-1">
A Requester records the location information for each registered memory region
associated with an RPC payload
in the transport header of an RPC-over-RDMA message.
With this information, the Responder uses RDMA Read and Write operations to
retrieve arguments contained in the specified region of the Requester's memory
or
place results in that region.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">
A "segment" is a transport header data object
that contains the precise coordinates of a contiguous registered memory region.
Each segment contains the following information:<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.4.1-3">
            <dt id="section-4.4.1-3.1">Handle:</dt>
            <dd style="margin-left: 1.5em" id="section-4.4.1-3.2">
A steering Tag (STag) or R_key generated by registering this memory with the RDMA provider.<a href="#section-4.4.1-3.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-4.4.1-3.3">Length:</dt>
            <dd style="margin-left: 1.5em" id="section-4.4.1-3.4">
The length of the segment's memory region, in octets.
The length of a segment
<span class="bcp14">MAY</span>
be aligned to a single octet.
An "empty segment" is defined as a segment
with the value zero (0) in its length field.<a href="#section-4.4.1-3.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-4.4.1-3.5">Offset:</dt>
            <dd style="margin-left: 1.5em" id="section-4.4.1-3.6">
The offset or beginning memory address of the segment's memory region.<a href="#section-4.4.1-3.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.4.1-4">
The meaning of the values contained in these fields is elaborated in
<span>[<a href="#RFC5040" class="xref">RFC5040</a>]</span>.<a href="#section-4.4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.4.1-5">
A "chunk" is simply a set of segments that have a related purpose.
A Requester
<span class="bcp14">MAY</span>
divide a chunk into segments using any convenient boundaries.
The length of a chunk is defined as
the sum of the lengths of the segments that comprise it.<a href="#section-4.4.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_0e225040-d15f-4e9a-a0c3-afa115bb12c7">
<section id="section-4.4.2">
          <h4 id="name-reducing-a-payload-stream">
<a href="#section-4.4.2" class="section-number selfRef">4.4.2. </a><a href="#name-reducing-a-payload-stream" class="section-name selfRef">Reducing a Payload Stream</a>
          </h4>
<p id="section-4.4.2-1">
We refer to a data item that a sender removes from a Payload stream
to transmit separately as a "reduced" data item.
After a sender has finished removing XDR data items from a Payload stream,
we refer to it as a "reduced" Payload stream.
A set of segments that describe memory regions
containing a single reduced data item is categorized as
a "data item chunk."<a href="#section-4.4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.4.2-2">
Not all XDR data items benefit from Direct Data Placement.
For example, small data items
or
data items that require XDR unmarshaling by the receiver
do not benefit from DDP.
Moreover, it is impractical for receivers to prepare for
every possible XDR data item in a protocol to appear in a data item chunk.<a href="#section-4.4.2-2" class="pilcrow">¶</a></p>
<p id="section-4.4.2-3">
Specifying which data items are DDP-eligible is done
in separate standards track documents known as "Upper Layer Bindings".
A ULB identifies which XDR data items a peer
<span class="bcp14">MAY</span>
transfer using DDP.
We refer to such data items as "DDP-eligible."
Senders
<span class="bcp14">MUST NOT</span>
reduce any other XDR data items.
Detailed requirements for ULB specifications appear in
<a href="#section_9e003b83-66b5-43d7-b9ef-0f271c8d301b" class="xref">Appendix A</a>
of the current document.<a href="#section-4.4.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_8c9060c3-e70e-4f37-ad0d-2fd074145d55">
<section id="section-4.4.3">
          <h4 id="name-moving-whole-rpc-messages-u">
<a href="#section-4.4.3" class="section-number selfRef">4.4.3. </a><a href="#name-moving-whole-rpc-messages-u" class="section-name selfRef">Moving Whole RPC Messages using Explicit RDMA</a>
          </h4>
<p id="section-4.4.3-1">
RPC-over-RDMA version 2 also enables the movement of
a whole RPC message via data transfer
distinct from RDMA Send and Receive.
A sender registers the memory containing a Payload stream
without regard to data item boundaries or DDP-eligibility.
The Payload stream is then conveyed via other mechanisms,
such as one or more RDMA Read or Write operations.
A set of segments that describe memory regions
containing a Payload stream is categorized as
a "body chunk".<a href="#section-4.4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.4.3-2">
A sender may first reduce that Payload stream if it contains
one or more DDP-eligible data items.
The sender moves these data items using data items chunks,
and the reduced Payload stream using a body chunk.<a href="#section-4.4.3-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_c561e45c-fe88-47e3-bdfd-689d482fcad3">
<section id="section-4.5">
        <h3 id="name-encoding-chunks">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-encoding-chunks" class="section-name selfRef">Encoding Chunks</a>
        </h3>
<p id="section-4.5-1">
The RPC-over-RDMA version 2 transport protocol
does not place a limit on chunk size.
However, each ULP may cap the amount of data that can be transferred
by a single RPC transaction.
For example, NFS implementations typically have settings
that restrict the payload size of NFS READ and WRITE operations.
The Responder can use such limits to sanity check chunk sizes
before using them in RDMA operations.<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<div id="section_025098f1-1355-4c97-8fda-5b4859372aa5">
<section id="section-4.5.1">
          <h4 id="name-read-chunks">
<a href="#section-4.5.1" class="section-number selfRef">4.5.1. </a><a href="#name-read-chunks" class="section-name selfRef">Read Chunks</a>
          </h4>
<p id="section-4.5.1-1">
A "Read chunk" contains data that its receiver pulls from the sender.
Each Read chunk is a set of one or more "Read segments"
encoded as a list.
A Read segment consists of a Position field
followed by a segment, as defined in
<a href="#section_8966c401-1714-413c-9384-b1f71f0a920d" class="xref">Section 4.4.1</a>.<a href="#section-4.5.1-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.5.1-2">
            <dt id="section-4.5.1-2.1">Position:</dt>
            <dd style="margin-left: 1.5em" id="section-4.5.1-2.2">
The byte offset in the unreduced Payload stream
where the receiver reinserts the data item conveyed in the chunk.
The sender <span class="bcp14">MUST</span> compute the Position value
from the beginning of the unreduced Payload stream,
which begins at Position zero.
All segments in the same Read chunk share the same Position value,
even if one or more of the segments have a non-four-byte-aligned length.
The value in this field <span class="bcp14">MUST</span> be a multiple of four.<a href="#section-4.5.1-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.5.1-3">
When constructing an RPC-over-RDMA message,
the sender registers memory regions containing
data intended for RDMA Read operations.
It advertises the coordinates of these regions in Read chunks added
to the transport header of an RPC-over-RDMA message.<a href="#section-4.5.1-3" class="pilcrow">¶</a></p>
<p id="section-4.5.1-4">
The receiver of this message then pulls the chunk's data from the sender
using RDMA Read operations.
When receiving a Read chunk,
the receiver inserts the first Read segment in a Read chunk
into the Payload stream at the byte offset indicated by its Position field.
The receiver concatenates Read segments
whose Position field value matches this offset
until there are no more Read segments at that Position value.<a href="#section-4.5.1-4" class="pilcrow">¶</a></p>
<div id="section_52130e02-8afb-4a36-ac38-64a4cb73b5bf">
<section id="section-4.5.1.1">
            <h5 id="name-the-read-list">
<a href="#section-4.5.1.1" class="section-number selfRef">4.5.1.1. </a><a href="#name-the-read-list" class="section-name selfRef">The Read List</a>
            </h5>
<p id="section-4.5.1.1-1">
Each RPC-over-RDMA message carries a list of Read segments
that make up the set of Read chunks for that message.
When no RDMA Read operations are needed
to complete the transmission of the message's Payload stream,
the message's Read list is empty.<a href="#section-4.5.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.5.1.1-2">
If a Responder receives
a Read list whose segment position values
do not appear in monotonically increasing order, it
<span class="bcp14">MUST</span>
discard the message without processing it
and
respond with an RDMA2_ERROR message
with the rdma_xid field set to the XID of the malformed message and
the rdma_err field set to RDMA2_ERR_BAD_XDR.<a href="#section-4.5.1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_a7327632-a379-43a5-92f7-d5a83582cd6d">
<section id="section-4.5.1.2">
            <h5 id="name-the-call-chunk">
<a href="#section-4.5.1.2" class="section-number selfRef">4.5.1.2. </a><a href="#name-the-call-chunk" class="section-name selfRef">The Call Chunk</a>
            </h5>
<p id="section-4.5.1.2-1">
The Call chunk is a Read chunk that acts as a body chunk
containing an RPC Call message.
A Requester can utilize a Call chunk at any time.
However, using a Call chunk is less efficient than
an RDMA Send.<a href="#section-4.5.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.1.2-2">
A Read chunk may act as either a data item chunk or a body chunk.
When the chunk's position is zero, it acts as a body chunk.
Otherwise, it is a data item chunk containing exactly one XDR data item.<a href="#section-4.5.1.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_5f4cc5f7-325d-479c-b592-6e93979431d0">
<section id="section-4.5.1.3">
            <h5 id="name-read-completion">
<a href="#section-4.5.1.3" class="section-number selfRef">4.5.1.3. </a><a href="#name-read-completion" class="section-name selfRef">Read Completion</a>
            </h5>
<p id="section-4.5.1.3-1">
A Responder acknowledges that
it is finished with the Requester's Read chunk memory regions
when it sends the corresponding RPC Reply message.
The Requester may then invalidate memory regions belonging to
Read chunks associated with the associated RPC Call message.<a href="#section-4.5.1.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_b8492157-7734-43e8-9a90-8ee32c674a12">
<section id="section-4.5.2">
          <h4 id="name-write-chunks">
<a href="#section-4.5.2" class="section-number selfRef">4.5.2. </a><a href="#name-write-chunks" class="section-name selfRef">Write Chunks</a>
          </h4>
<p id="section-4.5.2-1">
Each "Write chunk" consists of a counted array of
zero or more segments, as defined in
<a href="#section_8966c401-1714-413c-9384-b1f71f0a920d" class="xref">Section 4.4.1</a>.
The function of a Write chunk depends on the direction of
the containing RPC-over-RDMA message.
In a Call message,
a Write chunk advertises registered memory regions into which the Responder
may push data.
In a Reply message,
a Write chunk reports how much data has been pushed.<a href="#section-4.5.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.2-2">
A Requester provisions Write chunks for an RPC transaction
long before the Responder has constructed a corresponding Reply message.
A Requester typically does not know the actual length
of the result data items or Reply to be returned,
since the Reply does not yet exist.
Thus, a Requester
<span class="bcp14">MUST</span>
provision Write chunks large enough
to accommodate the maximum possible size of each returned data item.<a href="#section-4.5.2-2" class="pilcrow">¶</a></p>
<p id="section-4.5.2-3">
An "empty Write chunk" is a Write chunk with a zero segment count.
By definition, the length of an empty Write chunk is zero.
An "unused Write chunk" has a non-zero segment count,
but all of its segments are empty segments.<a href="#section-4.5.2-3" class="pilcrow">¶</a></p>
<div id="section_480387ae-1a7c-46b8-b310-8badb7b2a62b">
<section id="section-4.5.2.1">
            <h5 id="name-the-write-list">
<a href="#section-4.5.2.1" class="section-number selfRef">4.5.2.1. </a><a href="#name-the-write-list" class="section-name selfRef">The Write List</a>
            </h5>
<p id="section-4.5.2.1-1">
Each RPC-over-RDMA message carries a list of Write chunks.
When no DDP-eligible data items are to appear
in the Reply to an RPC transaction,
the Requester provides an empty Write list in the RPC Call,
and the Responder leaves the Write list empty in the matching RPC Reply.
When a Write chunk appears in the Write list,
it acts only as a data item chunk.<a href="#section-4.5.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.5.2.1-2">
For each Write chunk in the Write list,
the Responder pushes one DDP-eligible data item to the Requester.
It fills the chunk contiguously and in segment array order
until the Responder has written that data item to the Requester in its entirety.
The Responder <span class="bcp14">MUST</span> copy the segment count
and all segments from the Requester-provided Write chunk
into the RPC Reply message's transport header.
As it does so, the Responder updates each segment length field
to reflect the actual amount of data returned in that segment.<a href="#section-4.5.2.1-2" class="pilcrow">¶</a></p>
<p id="section-4.5.2.1-3">
The Responder then sends the RPC Reply message via an RDMA Send operation.<a href="#section-4.5.2.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_af268e5f-c34b-4329-aa2a-578e4b47b914">
<section id="section-4.5.2.2">
            <h5 id="name-the-reply-chunk">
<a href="#section-4.5.2.2" class="section-number selfRef">4.5.2.2. </a><a href="#name-the-reply-chunk" class="section-name selfRef">The Reply Chunk</a>
            </h5>
<p id="section-4.5.2.2-1">
The Reply chunk is a single Write chunk that acts as a body chunk.
that contains an RPC Reply message.
When a Requester estimates that the Reply message can exceed the
connection's ability to convey that Reply using RDMA Send operations,
it should provision a Reply chunk.<a href="#section-4.5.2.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_76f7431e-a3d6-4e62-8c8d-1844c564f944">
<section id="section-4.5.2.3">
            <h5 id="name-write-completion">
<a href="#section-4.5.2.3" class="section-number selfRef">4.5.2.3. </a><a href="#name-write-completion" class="section-name selfRef">Write Completion</a>
            </h5>
<p id="section-4.5.2.3-1">
A Responder acknowledges that
it is finished updating the Requester's Write chunk memory regions
when it sends the corresponding RPC Reply message.
The RDMA provider guarantees that the written data is at rest
before the next Receive operation, which typically contains the
corresponding RPC Reply, completes.
The Requester may then invalidate memory regions belonging to
Write chunks associated with the associated RPC Call message.<a href="#section-4.5.2.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_00f1edd4-2e2f-4b54-bc21-9d6dfa39556b">
<section id="section-4.5.2.4">
            <h5 id="name-write-chunk-roundup">
<a href="#section-4.5.2.4" class="section-number selfRef">4.5.2.4. </a><a href="#name-write-chunk-roundup" class="section-name selfRef">Write Chunk Roundup</a>
            </h5>
<p id="section-4.5.2.4-1">
When provisioning a Write chunk for a variable-length result data item,
the Requester <span class="bcp14">MUST NOT</span> include additional space for XDR roundup padding.
A Responder <span class="bcp14">MUST NOT</span> write XDR roundup padding into a Write chunk,
even if the result is shorter than the available space in the chunk.<a href="#section-4.5.2.4-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_4acf0f2d-6719-43cf-8231-e9ce8fa9791e">
<section id="section-4.5.3">
          <h4 id="name-reducing-complex-xdr-data-t">
<a href="#section-4.5.3" class="section-number selfRef">4.5.3. </a><a href="#name-reducing-complex-xdr-data-t" class="section-name selfRef">Reducing Complex XDR Data Types</a>
          </h4>
<p id="section-4.5.3-1">
XDR data items may appear in body chunks
without regard to their DDP-eligibility.
As body chunks contain a Payload stream, they
<span class="bcp14">MUST</span>
include all appropriate XDR roundup padding
to maintain proper XDR alignment of their contents.<a href="#section-4.5.3-1" class="pilcrow">¶</a></p>
<p id="section-4.5.3-2">
However, a data item chunk
<span class="bcp14">MUST</span>
contain only one XDR data item, and the chunk
<span class="bcp14">MUST</span>
occupy a four-byte aligned length in the Payload stream
so that subsequent data items remain properly aligned
once the reduced data item is removed from the Payload stream.<a href="#section-4.5.3-2" class="pilcrow">¶</a></p>
<div id="section_a7aa6a3a-2d02-4c11-bb88-0ba2eb76b0c0">
<section id="section-4.5.3.1">
            <h5 id="name-variable-length-data-items">
<a href="#section-4.5.3.1" class="section-number selfRef">4.5.3.1. </a><a href="#name-variable-length-data-items" class="section-name selfRef">Variable-Length Data Items</a>
            </h5>
<p id="section-4.5.3.1-1">
When a sender reduces a variable-length XDR data item,
the length of the item
<span class="bcp14">MUST</span>
remain in the Payload stream.
The sender
<span class="bcp14">MUST</span>
omit the item's XDR roundup padding
from the Payload stream and the chunk.
The chunk's total length
<span class="bcp14">MUST</span>
be the same as the encoded length of the data item.<a href="#section-4.5.3.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_2b8d1299-b521-4198-b99c-25b4e344b8bb">
<section id="section-4.5.3.2">
            <h5 id="name-counted-arrays">
<a href="#section-4.5.3.2" class="section-number selfRef">4.5.3.2. </a><a href="#name-counted-arrays" class="section-name selfRef">Counted Arrays</a>
            </h5>
<p id="section-4.5.3.2-1">
When reducing a data item that is a counted array data type,
the count of array elements
<span class="bcp14">MUST</span>
remain in the Payload stream.
The sender
<span class="bcp14">MUST</span>
move the array elements into the chunk.
For example, when encoding an opaque byte array as a chunk,
the count of bytes stays in the Payload stream,
and the sender places the bytes in the array in the chunk.<a href="#section-4.5.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.3.2-2">
Individual array elements appear in a chunk in their entirety.
For example, when encoding an array of arrays as a chunk,
the count of items in the enclosing array stays in the Payload stream.
But each enclosed array, including its item count,
is transferred as part of the chunk.<a href="#section-4.5.3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_ec322087-6d38-42b9-b24b-831aabcfb5f9">
<section id="section-4.5.3.3">
            <h5 id="name-optional-data">
<a href="#section-4.5.3.3" class="section-number selfRef">4.5.3.3. </a><a href="#name-optional-data" class="section-name selfRef">Optional-Data</a>
            </h5>
<p id="section-4.5.3.3-1">
Similar to a counted array,
when reducing an optional-data data type,
the discriminator field
<span class="bcp14">MUST</span>
remain in the Payload stream.
The sender
<span class="bcp14">MUST</span>
place the data, when present, in the chunk.<a href="#section-4.5.3.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_5ae887e6-fd9d-4a9f-a298-925b87a6a5b2">
<section id="section-4.5.3.4">
            <h5 id="name-xdr-unions">
<a href="#section-4.5.3.4" class="section-number selfRef">4.5.3.4. </a><a href="#name-xdr-unions" class="section-name selfRef">XDR Unions</a>
            </h5>
<p id="section-4.5.3.4-1">
A union data type
<span class="bcp14">MUST NOT</span>
be made DDP-eligible.
However, one or more of its arms
<span class="bcp14">MAY</span>
be made DDP-eligible, subject to the other requirements in this section.<a href="#section-4.5.3.4-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="section_41b8bd31-255d-4fab-a81b-df765f11ad47">
<section id="section-4.6">
        <h3 id="name-reverse-direction-operation">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-reverse-direction-operation" class="section-name selfRef">Reverse-Direction Operation</a>
        </h3>
<p id="section-4.6-1">
The terminology used in this section is introduced in
<a href="#section_189a59d0-9235-4c1e-a76f-ea2b20fd6c94" class="xref">Section 3.1.5.3</a>.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
<div id="section_3816dd27-8007-47b0-82da-9d69f578f29d">
<section id="section-4.6.1">
          <h4 id="name-sending-a-reverse-direction">
<a href="#section-4.6.1" class="section-number selfRef">4.6.1. </a><a href="#name-sending-a-reverse-direction" class="section-name selfRef">Sending a Reverse-Direction RPC Call</a>
          </h4>
<p id="section-4.6.1-1">
An RPC-over-RDMA server endpoint constructs the transport header
for a reverse-direction RPC Call as follows:<a href="#section-4.6.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.6.1-2.1">
The server generates a new XID value (see
<a href="#section_97382254-b1a3-4e03-98e5-a0814b331bd0" class="xref">Section 3.1.3</a>
for full requirements) and places it
in the rdma_xid field of the transport header
and the xid field of the RPC Call message.
The RPC Call header <span class="bcp14">MUST</span> start with the same XID value
that is present in the transport header.<a href="#section-4.6.1-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.2">
The rdma_vers field of each reverse-direction Call
<span class="bcp14">MUST</span> contain the same value as forward-direction Calls
on the same connection.<a href="#section-4.6.1-2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.3">
The server fills in the rdma_credit field
with the credit values for the connection, as described in
<a href="#section_45c67eb8-8dc6-47c3-8555-14270f1514bF" class="xref">Section 4.2.1</a>.<a href="#section-4.6.1-2.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.4">
The server determines the Payload format for the RPC message
and fills in the rdma_htype field as appropriate
(see Sections
<a href="#section_740e5b29-8c88-40ab-9506-69635d9a8167" class="xref">6.6</a>
and
<a href="#section_858fef67-6100-48bc-8d3d-d46201a4b461" class="xref">4.6.4</a>).
<a href="#section_858fef67-6100-48bc-8d3d-d46201a4b461" class="xref">Section 4.6.4</a>
also covers the disposition of the chunk lists.<a href="#section-4.6.1-2.4" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="section_748614a9-26da-4846-b5ff-43b06823abab">
<section id="section-4.6.2">
          <h4 id="name-sending-a-reverse-direction-">
<a href="#section-4.6.2" class="section-number selfRef">4.6.2. </a><a href="#name-sending-a-reverse-direction-" class="section-name selfRef">Sending a Reverse-Direction RPC Reply</a>
          </h4>
<p id="section-4.6.2-1">
An RPC-over-RDMA client endpoint constructs the transport header
for a reverse-direction RPC Reply as follows:<a href="#section-4.6.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.6.2-2.1">
The client copies the XID value from the matching RPC Call
and
places it in the rdma_xid field of the transport header
and
the xid field of the RPC Reply message.
The RPC Reply header <span class="bcp14">MUST</span> start with the same XID value
that is present in the transport header.<a href="#section-4.6.2-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.2-2.2">
The rdma_vers field of each reverse-direction Call
<span class="bcp14">MUST</span> contain the same value as forward-direction Replies
on the same connection.<a href="#section-4.6.2-2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.2-2.3">
The client fills in the rdma_credit field
with the credit values for the connection, as described in
<a href="#section_45c67eb8-8dc6-47c3-8555-14270f1514bF" class="xref">Section 4.2.1</a>.<a href="#section-4.6.2-2.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.2-2.4">
The client determines the Payload format for the RPC message
and fills in the rdma_htype field as appropriate
(see Sections
<a href="#section_740e5b29-8c88-40ab-9506-69635d9a8167" class="xref">6.6</a>
and
<a href="#section_858fef67-6100-48bc-8d3d-d46201a4b461" class="xref">4.6.4</a>).
<a href="#section_858fef67-6100-48bc-8d3d-d46201a4b461" class="xref">Section 4.6.4</a>
also covers the disposition of the chunk lists.<a href="#section-4.6.2-2.4" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="section_ed1c8ecf-360c-496f-ba93-117f016dfd4c">
<section id="section-4.6.3">
          <h4 id="name-when-reverse-direction-oper">
<a href="#section-4.6.3" class="section-number selfRef">4.6.3. </a><a href="#name-when-reverse-direction-oper" class="section-name selfRef">When Reverse-Direction Operation is Not Supported</a>
          </h4>
<p id="section-4.6.3-1">
An RPC-over-RDMA transport endpoint does not
have to support reverse-direction operation.
There might be no mechanism in the transport implementation to do so.
Or, the transport implementation might support
operation in the reverse direction,
but the Upper-Layer Protocol might not
configure the transport to handle reverse-direction traffic.<a href="#section-4.6.3-1" class="pilcrow">¶</a></p>
<p id="section-4.6.3-2">
If an endpoint is unprepared to receive a reverse-direction message,
loss of the RDMA connection might result.
Thus a denial of service can occur if an RPC server
continues to send reverse-direction messages
after a client that is not prepared to receive them
reconnects to that server.<a href="#section-4.6.3-2" class="pilcrow">¶</a></p>
<p id="section-4.6.3-3">
Connection peers indicate their support for reverse-direction operation
as part of the exchange of Transport Properties
just after a connection is established (see
<a href="#section_6ace2d7f-044b-491f-97ea-5760345a2e8f" class="xref">Section 5.2.5</a>).<a href="#section-4.6.3-3" class="pilcrow">¶</a></p>
<p id="section-4.6.3-4">
When dealing with the possibility that the remote peer
has no transport level support for reverse-direction operation,
the Upper-Layer Protocol is responsible for informing peers
when reverse-direction operation is supported.
Otherwise, even a simple reverse-direction RPC NULL procedure
from a peer could result in a lost connection.
Therefore, an Upper-Layer Protocol <span class="bcp14">MUST NOT</span> perform
reverse-direction RPC operations
until the RPC client indicates support for them.<a href="#section-4.6.3-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_858fef67-6100-48bc-8d3d-d46201a4b461">
<section id="section-4.6.4">
          <h4 id="name-using-chunks-during-reverse">
<a href="#section-4.6.4" class="section-number selfRef">4.6.4. </a><a href="#name-using-chunks-during-reverse" class="section-name selfRef">Using Chunks During Reverse-Direction Operation</a>
          </h4>
<p id="section-4.6.4-1">
Reverse-direction operations can use chunks for
DDP-eligible data items
and
Special payload formats
the same way chunks are used in forward-direction operation.
Connection peers indicate their support for
using chunks in the reverse direction
as part of the exchange of Transport Properties
just after a connection is established (see
<a href="#section_6ace2d7f-044b-491f-97ea-5760345a2e8f" class="xref">Section 5.2.5</a>).<a href="#section-4.6.4-1" class="pilcrow">¶</a></p>
<p id="section-4.6.4-2">
However, an implementation might support
only Upper-Layer Protocols
that have no DDP-eligible data items.
Such Upper-Layer Protocols can use only small messages,
or they might have a native mechanism
for restricting the size of reverse-direction RPC messages,
obviating the need to handle chunks in the reverse direction.<a href="#section-4.6.4-2" class="pilcrow">¶</a></p>
<p id="section-4.6.4-3">
When there is no Upper-Layer Protocol need
for chunks in the reverse direction,
implementers <span class="bcp14">MAY</span> choose not to provide support
for chunks in the reverse direction,
thus avoiding the complexity of implementing support
for RDMA Reads and Writes in the reverse direction.
When an RPC-over-RDMA transport implementation does not support
chunks in the reverse direction, RPC endpoints use only
the Simple Payload format without data item chunks
or
the Continued Payload format without data item chunks
to send RPC messages in the reverse direction.<a href="#section-4.6.4-3" class="pilcrow">¶</a></p>
<p id="section-4.6.4-4">
If a reverse-direction Requester provides a non-empty chunk list
to a Responder that does not support chunks,
the Responder <span class="bcp14">MUST</span> report its lack of support
using one of the error values defined in
<a href="#section_87c5f543-7092-4faf-b13e-0e994e8023a7" class="xref">Section 7.3</a>.<a href="#section-4.6.4-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_328c8cb7-80db-4b24-b871-2983e9648b45">
<section id="section-4.6.5">
          <h4 id="name-reverse-direction-retransmi">
<a href="#section-4.6.5" class="section-number selfRef">4.6.5. </a><a href="#name-reverse-direction-retransmi" class="section-name selfRef">Reverse-Direction Retransmission</a>
          </h4>
<p id="section-4.6.5-1">
In rare cases, an RPC server cannot
complete an RPC transaction
or
cannot send a Reply.
In these cases, the Requester may send the RPC transaction again
using the same RPC XID.<a href="#section-4.6.5-1" class="pilcrow">¶</a></p>
<p id="section-4.6.5-2">
In the forward direction,
an RPC client is the Requester.
The client is always responsible for ensuring
a transport connection is in place
before sending a dropped Call again.<a href="#section-4.6.5-2" class="pilcrow">¶</a></p>
<p id="section-4.6.5-3">
With reverse-direction operation,
an RPC server is the Requester.
Because an RPC server is not responsible
for establishing transport connections with clients,
the Requester is unable to retransmit a reverse-direction Call
whenever there is no transport connection.
In this case,
the RPC server must wait for the RPC client
to re-establish a transport connection
before it can retransmit reverse-direction RPC Calls.<a href="#section-4.6.5-3" class="pilcrow">¶</a></p>
<p id="section-4.6.5-4">
If the forward-direction Requester has no work to do,
it can be some time before the RPC client
re-establishes a transport connection.
An RPC server may need to abandon a pending reverse-direction RPC Call
to avoid waiting indefinitely for the client
to re-establish a transport connection.<a href="#section-4.6.5-4" class="pilcrow">¶</a></p>
<p id="section-4.6.5-5">
Therefore forward-direction Requesters <span class="bcp14">SHOULD</span> maintain a transport connection
as long as the RPC server might send reverse-direction Calls.
For example, while an NFS version 4.1 client has
open delegated files
or
active pNFS layouts,
it maintains one or more transport connections
to enable the NFS server to perform callback operations.<a href="#section-4.6.5-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_65de80fe-06ae-49ac-a4d8-e88dbbf787ab">
<section id="section-4.7">
        <h3 id="name-call-only-operation">
<a href="#section-4.7" class="section-number selfRef">4.7. </a><a href="#name-call-only-operation" class="section-name selfRef">Call-Only Operation</a>
        </h3>
<p id="section-4.7-1">
There is no corresponding Reply to a Call-only procedure.
Thus there is no opportunity for the Responder to
indicate it has completed its use of Read or Call chunks
that hold arguments or the whole Call.
In addition,
Write and Reply chunks are not necessary
because there are no results and no Reply message.
Therefore, Requesters
<span class="bcp14">MUST NOT</span>
use chunks when sending Call-only RPC procedures.<a href="#section-4.7-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_86248e99-ca60-478a-8aff-3fb387410077">
<section id="section-5">
      <h2 id="name-transport-properties">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-transport-properties" class="section-name selfRef">Transport Properties</a>
      </h2>
<p id="section-5-1">
RPC-over-RDMA version 2 enables connection endpoints
to exchange information about implementation properties.
Compatible endpoints use this information to optimize data transfer.
Initially, only a small set of transport properties are defined.
The protocol provides header types
to exchange transport properties (see
<a href="#section_977e471d-6948-43da-b3c8-bbb36034bd3e" class="xref">6.3.3</a>
and
<a href="#section_e8fbc443-1f44-4ec6-9132-9a28b4e6c870" class="xref">6.3.4</a>).<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">
Both the set of transport properties and the operations used
to communicate them may be extended.
Within RPC-over-RDMA version 2, such extensions are <span class="bcp14">OPTIONAL</span>.
A discussion of extending the set of transport properties appears in
<a href="#section_a355adad-f03b-41a6-94a8-4128b10301bb" class="xref">Appendix B.3</a>.<a href="#section-5-2" class="pilcrow">¶</a></p>
<div id="section_d5ac12f6-6735-48f3-b4ba-b44a19ff9298">
<section id="section-5.1">
        <h3 id="name-transport-properties-model">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-transport-properties-model" class="section-name selfRef">Transport Properties Model</a>
        </h3>
<p id="section-5.1-1">
The current document specifies a basic set of receiver and sender properties.
Such properties are specified using
a code point that identifies the particular transport property
and
a nominally opaque array containing the XDR encoding of the property.<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1-2">
The following XDR types handle transport properties:<a href="#section-5.1-2" class="pilcrow">¶</a></p>
<div id="section-5.1-3">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

typedef rpcrdma2_propid uint32;

struct rpcrdma2_propval {
        rpcrdma2_propid rdma_which;
        opaque          rdma_data&lt;&gt;;
};

typedef rpcrdma2_propval rpcrdma2_propset&lt;&gt;;

typedef uint32 rpcrdma2_propsubset&lt;&gt;;


&lt;CODE ENDS&gt;</pre><a href="#section-5.1-3" class="pilcrow">¶</a>
</div>
<p id="section-5.1-4">
The rpcrdma2_propid type specifies a distinct transport property.
The property code points are defined as const values rather than
elements in an enum type
to enable the extension by concatenating XDR definition files.<a href="#section-5.1-4" class="pilcrow">¶</a></p>
<p id="section-5.1-5">
The rpcrdma2_propval type carries the value of a transport property.
The rdma_which field identifies the particular property,
and
the rdma_data field contains the associated value of that property.
A zero-length rdma_data field represents
the default value of the property specified by rdma_which.<a href="#section-5.1-5" class="pilcrow">¶</a></p>
<p id="section-5.1-6">
Although the rdma_data field is opaque,
receivers interpret its contents using the XDR type
associated with the property specified by rdma_which.
When the contents of the rdma_data field
do not conform to that XDR type,
the receiver <span class="bcp14">MUST</span> return the error RDMA2_ERR_BAD_PROPVAL
using the header type RDMA2_ERROR,
as described in
<a href="#section_b1d23e5c-31df-483f-adb7-25430b5de38d" class="xref">Section 6.3.1</a>.<a href="#section-5.1-6" class="pilcrow">¶</a></p>
<p id="section-5.1-7">
For example, the receiver of a message
containing a valid rpcrdma2_propval returns this error
if the length of rdma_data is greater than
the length of the transferred message.
Also, when the receiver recognizes
the rpcrdma2_propid contained in rdma_which,
it <span class="bcp14">MUST</span> report the error RDMA2_ERR_BAD_PROPVAL
if either of the following occurs:<a href="#section-5.1-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-8.1">
The nominally opaque data within rdma_data is not valid when
interpreted using the property-associated typedef.<a href="#section-5.1-8.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.1-8.2">
The length of rdma_data is insufficient to contain the data
represented by the property-associated typedef.<a href="#section-5.1-8.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-5.1-9">
A receiver does not report an error if it does not recognize
the value contained in rdma_which.
In that case, the receiver does not process that rpcrdma2_propval.
Processing continues with the next rpcrdma2_propval, if any.<a href="#section-5.1-9" class="pilcrow">¶</a></p>
<p id="section-5.1-10">
The rpcrdma2_propset type specifies a set of transport properties.
The protocol does not impose a particular ordering of the rpcrdma2_propval items within it.<a href="#section-5.1-10" class="pilcrow">¶</a></p>
<p id="section-5.1-11">
The rpcrdma2_propsubset type identifies
a subset of the properties in a rpcrdma2_propset.
Each bit in the mask denotes a particular element in a previously
specified rpcrdma2_propset.
If a particular rpcrdma2_propval is at position N in the array,
then bit number N mod 32 in word N div 32 specifies whether
the defined subset includes that particular rpcrdma2_propval.
Words beyond the last one specified are assumed to contain zero.<a href="#section-5.1-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_943010bd-c342-46b7-9fcd-df746437dd6f">
<section id="section-5.2">
        <h3 id="name-current-transport-propertie">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-current-transport-propertie" class="section-name selfRef">Current Transport Properties</a>
        </h3>
<p id="section-5.2-1">
<a href="#table_99d0e7cc-da81-4f16-9bd0-471f806bc0b6" class="xref">Table 1</a>
specifies a basic set of transport properties.
The columns contain the following information:<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-2.1">
The column labeled "Property" contains a name
of the transport property described by the current row.<a href="#section-5.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-2.2">
The column labeled "Code" specifies the code point
that identifies this property.<a href="#section-5.2-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-2.3">
The column labeled "XDR type" gives the XDR type
of the data used to communicate the value of this property.
This data type overlays the data portion
of the nominally opaque rdma_data field.<a href="#section-5.2-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-2.4">
The column labeled "Default" gives the default value for the property.<a href="#section-5.2-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-2.5">
The column labeled "Section" indicates the section within the current
document that explains the use of this property.<a href="#section-5.2-2.5" class="pilcrow">¶</a>
</li>
        </ul>
<div id="table_99d0e7cc-da81-4f16-9bd0-471f806bc0b6">
<table class="left" id="table-1">
          <caption><a href="#table-1" class="selfRef">Table 1</a></caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Property</th>
              <th class="text-left" rowspan="1" colspan="1">Code</th>
              <th class="text-left" rowspan="1" colspan="1">XDR type</th>
              <th class="text-left" rowspan="1" colspan="1">Default</th>
              <th class="text-left" rowspan="1" colspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Maximum Send Size</td>
              <td class="text-left" rowspan="1" colspan="1">1</td>
              <td class="text-left" rowspan="1" colspan="1">uint32</td>
              <td class="text-left" rowspan="1" colspan="1">4096</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_0a985ff5-a5c1-477f-8932-517be34ccf65" class="xref">5.2.1</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Receive Buffer Size</td>
              <td class="text-left" rowspan="1" colspan="1">2</td>
              <td class="text-left" rowspan="1" colspan="1">uint32</td>
              <td class="text-left" rowspan="1" colspan="1">4096</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_5101b1f1-b1ad-4b6b-9fa4-d6fa324ffc0d" class="xref">5.2.2</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Maximum Segment Size</td>
              <td class="text-left" rowspan="1" colspan="1">3</td>
              <td class="text-left" rowspan="1" colspan="1">uint32</td>
              <td class="text-left" rowspan="1" colspan="1">1048576</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_14ed280d-521c-410c-a190-cf891be53900" class="xref">5.2.3</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Maximum Segment Count</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
              <td class="text-left" rowspan="1" colspan="1">uint32</td>
              <td class="text-left" rowspan="1" colspan="1">16</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_98fc720d-6263-4a52-ae89-d2469b982512" class="xref">5.2.4</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Reverse-Direction Support</td>
              <td class="text-left" rowspan="1" colspan="1">5</td>
              <td class="text-left" rowspan="1" colspan="1">uint32</td>
              <td class="text-left" rowspan="1" colspan="1">0</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_6ace2d7f-044b-491f-97ea-5760345a2e8f" class="xref">5.2.5</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Host Auth Message</td>
              <td class="text-left" rowspan="1" colspan="1">6</td>
              <td class="text-left" rowspan="1" colspan="1">opaque&lt;&gt;</td>
              <td class="text-left" rowspan="1" colspan="1">N/A</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_5f63e1b6-8d24-453b-b18b-b98ad66f3671" class="xref">5.2.6</a>
              </td>
            </tr>
          </tbody>
        </table>
</div>
<div id="section_0a985ff5-a5c1-477f-8932-517be34ccf65">
<section id="section-5.2.1">
          <h4 id="name-maximum-send-size">
<a href="#section-5.2.1" class="section-number selfRef">5.2.1. </a><a href="#name-maximum-send-size" class="section-name selfRef">Maximum Send Size</a>
          </h4>
<p id="section-5.2.1-1">
The value of this property specifies
the maximum size, in octets, of Send payloads.
The endpoint receiving this value
can size its Receive buffers
based on the value of this property.<a href="#section-5.2.1-1" class="pilcrow">¶</a></p>
<div id="section-5.2.1-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const uint32 RDMA2_PROPID_SBSIZ = 1;
typedef uint32 rpcrdma2_prop_sbsiz;


&lt;CODE ENDS&gt;</pre><a href="#section-5.2.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="section_5101b1f1-b1ad-4b6b-9fa4-d6fa324ffc0d">
<section id="section-5.2.2">
          <h4 id="name-receive-buffer-size">
<a href="#section-5.2.2" class="section-number selfRef">5.2.2. </a><a href="#name-receive-buffer-size" class="section-name selfRef">Receive Buffer Size</a>
          </h4>
<p id="section-5.2.2-1">
The value of this property specifies
the minimum size, in octets, of pre-posted receive buffers.<a href="#section-5.2.2-1" class="pilcrow">¶</a></p>
<div id="section-5.2.2-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const uint32 RDMA2_PROPID_RBSIZ = 2;
typedef uint32 rpcrdma2_prop_rbsiz;


&lt;CODE ENDS&gt;</pre><a href="#section-5.2.2-2" class="pilcrow">¶</a>
</div>
<p id="section-5.2.2-3">
A sender can subsequently use this value to
determine when a message to be sent fits in
pre-posted receive buffers that the receiver has set up.
In particular:<a href="#section-5.2.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2.2-4.1">
Requesters may use the value to determine
when to use a Call chunk or Message Continuation
when sending a Call.<a href="#section-5.2.2-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5.2.2-4.2">
Requesters may use the value to determine when
to provide a Reply chunk when sending a Call,
based on the maximum possible size of the Reply.<a href="#section-5.2.2-4.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5.2.2-4.3">
Responders may use the value to determine when
to use a Reply chunk provided by the Requester,
given the actual size of a Reply.<a href="#section-5.2.2-4.3" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="section_14ed280d-521c-410c-a190-cf891be53900">
<section id="section-5.2.3">
          <h4 id="name-maximum-segment-size">
<a href="#section-5.2.3" class="section-number selfRef">5.2.3. </a><a href="#name-maximum-segment-size" class="section-name selfRef">Maximum Segment Size</a>
          </h4>
<p id="section-5.2.3-1">
The value of this property specifies
the maximum size, in octets,
of a segment this endpoint is prepared to send or receive.<a href="#section-5.2.3-1" class="pilcrow">¶</a></p>
<div id="section-5.2.3-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const uint32 RDMA2_PROPID_RSSIZ = 3;
typedef uint32 rpcrdma2_prop_rssiz;


&lt;CODE ENDS&gt;</pre><a href="#section-5.2.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="section_98fc720d-6263-4a52-ae89-d2469b982512">
<section id="section-5.2.4">
          <h4 id="name-maximum-segment-count">
<a href="#section-5.2.4" class="section-number selfRef">5.2.4. </a><a href="#name-maximum-segment-count" class="section-name selfRef">Maximum Segment Count</a>
          </h4>
<p id="section-5.2.4-1">
The value of this property specifies
the maximum number of segments
that can appear in a Requester's transport header.<a href="#section-5.2.4-1" class="pilcrow">¶</a></p>
<div id="section-5.2.4-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const uint32 RDMA2_PROPID_RCSIZ = 4;
typedef uint32 rpcrdma2_prop_rcsiz;


&lt;CODE ENDS&gt;</pre><a href="#section-5.2.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="section_6ace2d7f-044b-491f-97ea-5760345a2e8f">
<section id="section-5.2.5">
          <h4 id="name-reverse-direction-support">
<a href="#section-5.2.5" class="section-number selfRef">5.2.5. </a><a href="#name-reverse-direction-support" class="section-name selfRef">Reverse-Direction Support</a>
          </h4>
<p id="section-5.2.5-1">
The value of this property specifies
a client implementation's readiness to process
messages that are part of reverse-direction RPC requests.<a href="#section-5.2.5-1" class="pilcrow">¶</a></p>
<div id="section-5.2.5-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const uint32 RDMA_RVRSDIR_NONE = 0;
const uint32 RDMA_RVRSDIR_SIMPLE = 1;
const uint32 RDMA_RVRSDIR_CONT = 2;
const uint32 RDMA_RVRSDIR_GENL = 3;

const uint32 RDMA2_PROPID_BRS = 5;
typedef uint32 rpcrdma2_prop_brs;


&lt;CODE ENDS&gt;</pre><a href="#section-5.2.5-2" class="pilcrow">¶</a>
</div>
<p id="section-5.2.5-3">
Multiple levels of support are distinguished:<a href="#section-5.2.5-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2.5-4.1">
The value RDMA2_RVRSDIR_NONE indicates
that the sender does not support reverse-direction operation.<a href="#section-5.2.5-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5.2.5-4.2">
The value RDMA2_RVRSDIR_SIMPLE indicates
that the sender supports using only Simple Format messages without data item chunks
for reverse-direction messages.<a href="#section-5.2.5-4.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5.2.5-4.3">
The value RDMA2_RVRSDIR_CONT indicates
that the sender supports using either
Simple Format without data item chunks
or
Continued Format messages without data item chunks
for reverse-direction messages.<a href="#section-5.2.5-4.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5.2.5-4.4">
The value RDMA2_RVRSDIR_GENL indicates
that the sender supports reverse-direction messages
in the same way as forward-direction messages.<a href="#section-5.2.5-4.4" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-5.2.5-5">
When a peer does not provide this property,
the default is the peer does not support
reverse-direction operation.<a href="#section-5.2.5-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_5f63e1b6-8d24-453b-b18b-b98ad66f3671">
<section id="section-5.2.6">
          <h4 id="name-host-authentication-message">
<a href="#section-5.2.6" class="section-number selfRef">5.2.6. </a><a href="#name-host-authentication-message" class="section-name selfRef">Host Authentication Message</a>
          </h4>
<p id="section-5.2.6-1">
The value of this transport property enables
the exchange of host authentication material.
This property can accommodate authentication handshakes
that require multiple challenge-response interactions
and potentially large amounts of material.<a href="#section-5.2.6-1" class="pilcrow">¶</a></p>
<div id="section-5.2.6-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const uint32 RDMA2_PROPID_HOSTAUTH = 6;
typedef opaque rpcrdma2_prop_hostauth&lt;&gt;;


&lt;CODE ENDS&gt;</pre><a href="#section-5.2.6-2" class="pilcrow">¶</a>
</div>
<p id="section-5.2.6-3">
When this property is not present, the peer(s) remain unauthenticated.
Local security policy on each peer determines
whether the connection is permitted to continue.<a href="#section-5.2.6-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="section_eef6a22e-2633-44a2-a8f0-821fec8bf824">
<section id="section-6">
      <h2 id="name-transport-messages">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-transport-messages" class="section-name selfRef">Transport Messages</a>
      </h2>
<p id="section-6-1">
Each transport message consists of multiple sections.<a href="#section-6-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6-2.1">
A transport header prefix, as defined in
<a href="#section_2d1735f0-c465-43c6-9c18-3da6b7979862" class="xref">Section 6.4</a>.
Among other things, this structure indicates the header type.<a href="#section-6-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-6-2.2">
The transport header proper, as defined by one of the sub-sections below.
See
<a href="#section_67b34950-5376-49fd-93d7-b4fdf80d1c9b" class="xref">Section 6.1</a>
for the mapping between header types and the corresponding header structure.<a href="#section-6-2.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-6-2.3">
Potentially, all or part of an RPC message payload.<a href="#section-6-2.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-6-3">
This organization differs from that presented in the definition of
RPC-over-RDMA version 1
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>,
which defined the first and second of the items above as a single XDR data structure.
The new organization is in keeping with RPC-over-RDMA version 2's
extensibility model, which enables the definition of new header types
without modifying the XDR definition of existing header types.<a href="#section-6-3" class="pilcrow">¶</a></p>
<div id="section_67b34950-5376-49fd-93d7-b4fdf80d1c9b">
<section id="section-6.1">
        <h3 id="name-transport-header-types">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-transport-header-types" class="section-name selfRef">Transport Header Types</a>
        </h3>
<p id="section-6.1-1">
<a href="#table_b5c31bf9-d623-4957-97db-29fc1d416cb8" class="xref">Table 2</a>
lists the RPC-over-RDMA version 2 header types.
The columns contain the following information:<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-2.1">
The column labeled "Operation" names
the particular operation.<a href="#section-6.1-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.1-2.2">
The column labeled "Code" specifies
the value of the header type for this operation.<a href="#section-6.1-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.1-2.3">
The column labeled "XDR type" gives
the XDR type of the data structure
used to organize the information in this new header type.
This data immediately follows the universal portion on the
transport header present in every RPC-over-RDMA transport header.<a href="#section-6.1-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.1-2.4">
The column labeled "Msg" indicates whether this operation is
followed (or not) by an RPC message payload.<a href="#section-6.1-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.1-2.5">
The column labeled "Section" refers to the section within the current
document that explains the use of this header type.<a href="#section-6.1-2.5" class="pilcrow">¶</a>
</li>
        </ul>
<div id="table_b5c31bf9-d623-4957-97db-29fc1d416cb8">
<table class="left" id="table-2">
          <caption><a href="#table-2" class="selfRef">Table 2</a></caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Operation</th>
              <th class="text-left" rowspan="1" colspan="1">Code</th>
              <th class="text-left" rowspan="1" colspan="1">XDR type</th>
              <th class="text-left" rowspan="1" colspan="1">Msg</th>
              <th class="text-left" rowspan="1" colspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Report Transport Error</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_error</td>
              <td class="text-left" rowspan="1" colspan="1">No</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_b1d23e5c-31df-483f-adb7-25430b5de38d" class="xref">6.3.1</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Grant Credits</td>
              <td class="text-left" rowspan="1" colspan="1">5</td>
              <td class="text-left" rowspan="1" colspan="1">void</td>
              <td class="text-left" rowspan="1" colspan="1">No</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_d7b171ca-326d-45ed-bfa6-eca86ae4a62e" class="xref">6.3.2</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Specify Properties (Middle)</td>
              <td class="text-left" rowspan="1" colspan="1">6</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_connprop</td>
              <td class="text-left" rowspan="1" colspan="1">No</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_977e471d-6948-43da-b3c8-bbb36034bd3e" class="xref">6.3.3</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Specify Properties (Final)</td>
              <td class="text-left" rowspan="1" colspan="1">7</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_connprop</td>
              <td class="text-left" rowspan="1" colspan="1">No</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_e8fbc443-1f44-4ec6-9132-9a28b4e6c870" class="xref">6.3.4</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Convey External RPC Call Message</td>
              <td class="text-left" rowspan="1" colspan="1">8</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_call_external</td>
              <td class="text-left" rowspan="1" colspan="1">No</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_7e1de71a-9b68-4bd0-8213-97991139ab87" class="xref">6.3.5</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Convey Continued RPC Call Message</td>
              <td class="text-left" rowspan="1" colspan="1">9</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_call_middle</td>
              <td class="text-left" rowspan="1" colspan="1">Yes</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_3eb026d2-eccb-41bc-a09e-d922d935b23c" class="xref">6.3.6</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Convey Inline RPC Call Message</td>
              <td class="text-left" rowspan="1" colspan="1">10</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_call_inline</td>
              <td class="text-left" rowspan="1" colspan="1">Yes</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_b8fd93f1-e5c8-47f2-b26e-921530cb0681" class="xref">6.3.7</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Convey External RPC Reply Message</td>
              <td class="text-left" rowspan="1" colspan="1">11</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_reply_external</td>
              <td class="text-left" rowspan="1" colspan="1">No</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_780fd420-96d9-4cbe-af49-141ea89cdf6F" class="xref">6.3.8</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Convey Continued RPC Reply Message</td>
              <td class="text-left" rowspan="1" colspan="1">12</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_reply_middle</td>
              <td class="text-left" rowspan="1" colspan="1">Yes</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_3d6d56ae-ba9b-432f-9fc0-403a5f622fe5" class="xref">6.3.9</a>
              </td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Convey Inline RPC Reply Message</td>
              <td class="text-left" rowspan="1" colspan="1">13</td>
              <td class="text-left" rowspan="1" colspan="1">rpcrdma2_hdr_reply_inline</td>
              <td class="text-left" rowspan="1" colspan="1">Yes</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#section_67bf730f-38f1-40bc-8eec-1bedde7b0449" class="xref">6.3.10</a>
              </td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-6.1-4">
RPC-over-RDMA version 2 peers are
<span class="bcp14">REQUIRED</span>
to support all message header types in
<a href="#table_b5c31bf9-d623-4957-97db-29fc1d416cb8" class="xref">Table 2</a>.
RPC-over-RDMA version 2 implementations that receive an unrecognized header type
<span class="bcp14">MUST</span>
respond with an RDMA2_ERROR message
with an rdma_err field containing RDMA2_ERR_INVAL_HTYPE
and drop the incoming message without processing it further.<a href="#section-6.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_2e577c75-4e43-4e13-8b17-75afa849f0b6">
<section id="section-6.2">
        <h3 id="name-headers-and-chunks">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-headers-and-chunks" class="section-name selfRef">Headers and Chunks</a>
        </h3>
<p id="section-6.2-1">
Most RPC-over-RDMA version 2 data structures have antecedents in
corresponding structures in RPC-over-RDMA version 1.
As is typical for new versions of an existing protocol,
the XDR data structures have new names,
and there are a few small changes in content.
In some cases,
there have been structural re-organizations
to enable protocol extensibility.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<div id="section_e21d4f74-b536-47f2-9d07-c03a27a20de4">
<section id="section-6.2.1">
          <h4 id="name-common-transport-header-pre">
<a href="#section-6.2.1" class="section-number selfRef">6.2.1. </a><a href="#name-common-transport-header-pre" class="section-name selfRef">Common Transport Header Prefix</a>
          </h4>
<p id="section-6.2.1-1">
The rpcrdma_common structure defines
the initial part of each RPC-over-RDMA transport header
for RPC-over-RDMA version 2 and subsequent versions.<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
<div id="section-6.2.1-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

struct rpcrdma_common {
             uint32         rdma_xid;
             uint32         rdma_vers;
             uint32         rdma_credit;
             uint32         rdma_htype;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.2.1-2" class="pilcrow">¶</a>
</div>
<p id="section-6.2.1-3">
RPC-over-RDMA version 2's use of these first four words
aligns with that of version 1 as required by
<span><a href="https://rfc-editor.org/rfc/rfc8166#section-4.2" class="relref">Section 4.2</a> of [<a href="#RFC8166" class="xref">RFC8166</a>]</span>.
However, there are crucial structural differences
in the XDR definition of RPC-over-RDMA version 2:
in the way that these words are described
by the respective XDR descriptions:<a href="#section-6.2.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2.1-4.1">
The header type is represented as a uint32 rather than as an enum type.
An enum would need to be modified to reflect additions to the set of
header types made by later extensions.<a href="#section-6.2.1-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.2.1-4.2">
The header type field is part of an XDR structure devoted to
representing the transport header prefix,
rather than being part of a discriminated union,
that includes the body of each transport header type.<a href="#section-6.2.1-4.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.2.1-4.3">
There is now a prefix structure
(see
<a href="#section_2d1735f0-c465-43c6-9c18-3da6b7979862" class="xref">Section 6.4</a>)
of which the rpcrdma_common structure is the initial segment.
This prefix is a newly defined XDR object within the protocol description,
which constrains the universal portion of all header types
to the four words in rpcrdma_common.<a href="#section-6.2.1-4.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-6.2.1-5">
These changes are part of a more considerable structural change
in the XDR definition of RPC-over-RDMA version 2
that facilitates a cleaner treatment of protocol extension.
The XDR appearing in
<a href="#section_bf53e759-d97f-487d-a5e2-9b8153db1803" class="xref">Section 8</a>
reflects these changes, which
<a href="#section_d945b9f0-0666-4db7-9126-be57cf7b5f4f" class="xref">Appendix C.1</a>
discusses in further detail.<a href="#section-6.2.1-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_8039c7b8-9068-401e-9cbd-5c1e67d403e7">
<section id="section-6.3">
        <h3 id="name-header-types">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-header-types" class="section-name selfRef">Header Types</a>
        </h3>
<p id="section-6.3-1">
The header types defined and used in RPC-over-RDMA version 1
are not carried over into RPC-over-RDMA version 2,
although there are easy equivalents to the version 1
procedures:<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.3-2.1">
The RDMA2_ERROR header (defined in
<a href="#section_b1d23e5c-31df-483f-adb7-25430b5de38d" class="xref">Section 6.3.1</a>)
has an XDR definition that differs from that in RPC-over-RDMA version 1,
and its modifications are all compatible extensions.<a href="#section-6.3-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.3-2.2">
Senders use RDMA2_CALL_INLINE or RDMA2_REPLY_INLINE
(defined in Sections
<a href="#section_b8fd93f1-e5c8-47f2-b26e-921530cb0681" class="xref">6.3.7</a>
and
<a href="#section_67bf730f-38f1-40bc-8eec-1bedde7b0449" class="xref">6.3.10</a>)
in place of RDMA_MSG.
There are minor differences in the on-the-wire format
between the version 1 procedure and the version 2 header types.<a href="#section-6.3-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.3-2.3">
Senders use RDMA2_CALL_EXTERNAL or RDMA2_REPLY_EXTERNAL
(defined in Sections
<a href="#section_7e1de71a-9b68-4bd0-8213-97991139ab87" class="xref">6.3.5</a>
and
<a href="#section_780fd420-96d9-4cbe-af49-141ea89cdf6F" class="xref">6.3.8</a>)
in place of RDMA_NOMSG.
There are minor differences in the on-the-wire format
between the version 1 procedure and the version 2 header types.<a href="#section-6.3-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.3-2.4">
RDMA2_CONNPROP_MIDDLE and RDMA2_CONNPROP_FINAL
(defined in Sections
<a href="#section_977e471d-6948-43da-b3c8-bbb36034bd3e" class="xref">6.3.3</a>
and
<a href="#section_e8fbc443-1f44-4ec6-9132-9a28b4e6c870" class="xref">6.3.4</a>)
are new header types devoted to
enabling connection peers to exchange information
about their transport properties.<a href="#section-6.3-2.4" class="pilcrow">¶</a>
</li>
        </ul>
<div id="section_b1d23e5c-31df-483f-adb7-25430b5de38d">
<section id="section-6.3.1">
          <h4 id="name-rdma2_error-report-transpor">
<a href="#section-6.3.1" class="section-number selfRef">6.3.1. </a><a href="#name-rdma2_error-report-transpor" class="section-name selfRef">RDMA2_ERROR: Report Transport Error</a>
          </h4>
<p id="section-6.3.1-1">
RDMA2_ERROR reports a transport layer error on a previous transmission.<a href="#section-6.3.1-1" class="pilcrow">¶</a></p>
<div id="section-6.3.1-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_ERROR = 4;

struct rpcrdma2_err_vers {
        uint32 rdma_vers_low;
        uint32 rdma_vers_high;
};

struct rpcrdma2_err_write {
        uint32 rdma_chunk_index;
        uint32 rdma_length_needed;
};

union rpcrdma2_hdr_error switch (rpcrdma2_errcode rdma_err) {
        case RDMA2_ERR_VERS:
          rpcrdma2_err_vers rdma_vrange;
        case RDMA2_ERR_READ_CHUNKS:
          uint32 rdma_max_chunks;
        case RDMA2_ERR_WRITE_CHUNKS:
          uint32 rdma_max_chunks;
        case RDMA2_ERR_SEGMENTS:
          uint32 rdma_max_segments;
        case RDMA2_ERR_WRITE_RESOURCE:
          rpcrdma2_err_write rdma_writeres;
        case RDMA2_ERR_REPLY_RESOURCE:
          uint32 rdma_length_needed;
        default:
          void;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.1-2" class="pilcrow">¶</a>
</div>
<p id="section-6.3.1-3">
See
<a href="#section_995a7597-4e89-48c3-b142-35b783ef1329" class="xref">Section 7</a>
for details on the use of this header type.<a href="#section-6.3.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_d7b171ca-326d-45ed-bfa6-eca86ae4a62e">
<section id="section-6.3.2">
          <h4 id="name-rdma2_grant-grant-credits">
<a href="#section-6.3.2" class="section-number selfRef">6.3.2. </a><a href="#name-rdma2_grant-grant-credits" class="section-name selfRef">RDMA2_GRANT: Grant Credits</a>
          </h4>
<p id="section-6.3.2-1">
The RDMA2_GRANT header type enables a connection peer
to update credit information
without conveying a payload.<a href="#section-6.3.2-1" class="pilcrow">¶</a></p>
<div id="section-6.3.2-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_GRANT = 5;


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.2-2" class="pilcrow">¶</a>
</div>
<p id="section-6.3.2-3">
This message carries no payload except for a struct rpcrdma2_hdr_prefix.
The rdma_xid field is unused.
Senders
<span class="bcp14">MUST</span>
set the rdma_xid field to zero and receivers
<span class="bcp14">MUST</span>
ignore the value in this field.<a href="#section-6.3.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_977e471d-6948-43da-b3c8-bbb36034bd3e">
<section id="section-6.3.3">
          <h4 id="name-rdma2_connprop_middle-excha">
<a href="#section-6.3.3" class="section-number selfRef">6.3.3. </a><a href="#name-rdma2_connprop_middle-excha" class="section-name selfRef">RDMA2_CONNPROP_MIDDLE: Exchange Transport Properties</a>
          </h4>
<p id="section-6.3.3-1">
The RDMA2_CONNPROP_MIDDLE header type enables a connection peer
to publish the properties of its implementation to its
remote peer.<a href="#section-6.3.3-1" class="pilcrow">¶</a></p>
<div id="section-6.3.3-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_CONNPROP_MIDDLE = 6;

struct rpcrdma2_hdr_connprop {
        rpcrdma2_propset rdma_props;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.3-2" class="pilcrow">¶</a>
</div>
<p id="section-6.3.3-3">
A peer sends an RDMA2_CONNPROP_MIDDLE header type
when it has one or more properties to send that
do not fit within
the default inline threshold for the RPC-over-RDMA version that is in effect.<a href="#section-6.3.3-3" class="pilcrow">¶</a></p>
<p id="section-6.3.3-4">
A peer may encounter properties that it does not recognize or support.
In such cases, the receiver ignores unsupported properties
without generating an error response.<a href="#section-6.3.3-4" class="pilcrow">¶</a></p>
<p id="section-6.3.3-5">
If a peer sends follows an RDMA2_CONNPROP_MIDDLE
header type with anything other than
another RDMA2_CONNPROP_MIDDLE message
or
an RDMA2_CONNPROP_FINAL message,
the receiver
<span class="bcp14">MUST</span>
respond with an RDMA2_ERROR header type
and
set its rdma_err field to RDMA2_ERR_INVAL_CONT
and drop the incoming message without processing it further.<a href="#section-6.3.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_e8fbc443-1f44-4ec6-9132-9a28b4e6c870">
<section id="section-6.3.4">
          <h4 id="name-rdma2_connprop_final-exchan">
<a href="#section-6.3.4" class="section-number selfRef">6.3.4. </a><a href="#name-rdma2_connprop_final-exchan" class="section-name selfRef">RDMA2_CONNPROP_FINAL: Exchange Transport Properties</a>
          </h4>
<p id="section-6.3.4-1">
The RDMA2_CONNPROP_FINAL header type enables a connection peer
to publish the properties of its implementation to its
remote peer.<a href="#section-6.3.4-1" class="pilcrow">¶</a></p>
<div id="section-6.3.4-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_CONNPROP_FINAL = 7;

struct rpcrdma2_hdr_connprop {
        rpcrdma2_propset rdma_props;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.4-2" class="pilcrow">¶</a>
</div>
<p id="section-6.3.4-3">
Each peer sends an RDMA2_CONNPROP_FINAL header type
as the final CONNPROP-type message
after the client has established a connection.
The size of this message is limited to
the default inline threshold for the RPC-over-RDMA version that is in effect.<a href="#section-6.3.4-3" class="pilcrow">¶</a></p>
<p id="section-6.3.4-4">
A peer may encounter properties that it does not recognize or support.
In such cases, the receiver ignores unsupported properties
without generating an error response.<a href="#section-6.3.4-4" class="pilcrow">¶</a></p>
<p id="section-6.3.4-5">
If a peer sends a CONNPROP-type message on a connection
after it has sent an RDMA2_CONNPROP_FINAL message,
the receiver
<span class="bcp14">MUST</span>
respond with an RDMA2_ERROR header type
and
set its rdma_err field to RDMA2_ERR_INVAL_CONT
and drop the incoming message without processing it further.<a href="#section-6.3.4-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_7e1de71a-9b68-4bd0-8213-97991139ab87">
<section id="section-6.3.5">
          <h4 id="name-rdma2_call_external-convey-">
<a href="#section-6.3.5" class="section-number selfRef">6.3.5. </a><a href="#name-rdma2_call_external-convey-" class="section-name selfRef">RDMA2_CALL_EXTERNAL: Convey External RPC Call Message</a>
          </h4>
<p id="section-6.3.5-1">
RDMA2_CALL_EXTERNAL conveys an RPC Call message payload
using explicit RDMA operations.
The Responder reads the Payload stream from a memory area
specified by the Call chunk.
The sender
<span class="bcp14">MUST</span>
set the rdma_xid field to the same value
as the xid of the RPC Reply message payload.<a href="#section-6.3.5-1" class="pilcrow">¶</a></p>
<div id="section-6.3.5-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_CALL_EXTERNAL = 8;

struct rpcrdma2_hdr_call_external {
        uint32                      rdma_inv_handle;

        struct rpcrdma2_read_list   *rdma_call;
        struct rpcrdma2_read_list   *rdma_reads;
        struct rpcrdma2_write_list  *rdma_provisional_writes;
        struct rpcrdma2_write_chunk *rdma_provisional_reply;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.5-2" class="pilcrow">¶</a>
</div>
<span class="break"></span><dl class="dlParallel" id="section-6.3.5-3">
            <dt id="section-6.3.5-3.1">rdma_inv_handle:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.5-3.2">
The rdma_inv_handle field contains a 32-bit RDMA handle that
the Responder may use in a Send With Invalidation operation.
See
<a href="#section_a957db67-a8fd-4886-b7a7-57382cfe3190" class="xref">Section 6.5</a>.<a href="#section-6.3.5-3.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.5-3.3">rdma_call:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.5-3.4">
The rdma_call field anchors a list of one or more Read segments
that contain the RPC Call's Payload stream.<a href="#section-6.3.5-3.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.5-3.5">rdma_reads:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.5-3.6">
The rdma_reads field anchors a list of zero or more Read segments
that contain data item chunks.<a href="#section-6.3.5-3.6" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.5-3.7">rdma_provisional_writes:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.5-3.8">
The rdma_writes field
anchors a list of zero or more provisional Write chunks.<a href="#section-6.3.5-3.8" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.5-3.9">rdma_provisional_reply:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.5-3.10">
The rdma_reply field is a list containing zero or one provisional Reply chunk.<a href="#section-6.3.5-3.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="section_3eb026d2-eccb-41bc-a09e-d922d935b23c">
<section id="section-6.3.6">
          <h4 id="name-rdma2_call_middle-convey-co">
<a href="#section-6.3.6" class="section-number selfRef">6.3.6. </a><a href="#name-rdma2_call_middle-convey-co" class="section-name selfRef">RDMA2_CALL_MIDDLE: Convey Continued RPC Call Message</a>
          </h4>
<p id="section-6.3.6-1">
RDMA2_CALL_MIDDLE conveys a beginning or middle portion
of an RPC Call message
immediately following the transport header in the send buffer.
The sender
<span class="bcp14">MUST</span>
set the rdma_xid field to the same value
as the xid of the RPC Reply message payload.
The sender sets the rdma_remaining field
to the number of bytes in the RPC Call message payload
that remain to be sent.
The rdma_rpc_first_word field demarks the first word
of the Payload stream.<a href="#section-6.3.6-1" class="pilcrow">¶</a></p>
<div id="section-6.3.6-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_CALL_MIDDLE = 9;

struct rpcrdma2_hdr_call_middle {
        uint32                      rdma_remaining;

        /* The rpc message starts here and continues
         * through the end of the transmission. */
        uint32                      rdma_rpc_first_word;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.6-2" class="pilcrow">¶</a>
</div>
<p id="section-6.3.6-3">
If a peer sends follows an RDMA2_CALL_MIDDLE
header type with anything other than
an RDMA2_CALL_MIDDLE message
or
an RDMA2_CALL_INLINE message,
the receiver
<span class="bcp14">MUST</span>
respond with an RDMA2_ERROR header type
and
set its rdma_err field to RDMA2_ERR_INVAL_CONT
and drop the incoming message without processing it further.<a href="#section-6.3.6-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_b8fd93f1-e5c8-47f2-b26e-921530cb0681">
<section id="section-6.3.7">
          <h4 id="name-rdma2_call_inline-convey-in">
<a href="#section-6.3.7" class="section-number selfRef">6.3.7. </a><a href="#name-rdma2_call_inline-convey-in" class="section-name selfRef">RDMA2_CALL_INLINE: Convey Inline RPC Call Message</a>
          </h4>
<p id="section-6.3.7-1">
RDMA2_CALL_INLINE conveys the only or final portion
of an RPC Call message.
The rdma_rpc_first_word field demarks the first word
of this Payload stream.<a href="#section-6.3.7-1" class="pilcrow">¶</a></p>
<div id="section-6.3.7-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_CALL_INLINE = 10;

struct rpcrdma2_hdr_call_inline {
        uint32                      rdma_inv_handle;

        struct rpcrdma2_read_list   *rdma_reads;
        struct rpcrdma2_write_list  *rdma_provisional_writes;
        struct rpcrdma2_write_chunk *rdma_provisional_reply;

        /* The rpc message starts here and continues
         * through the end of the transmission. */
        uint32                      rdma_rpc_first_word;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.7-2" class="pilcrow">¶</a>
</div>
<span class="break"></span><dl class="dlParallel" id="section-6.3.7-3">
            <dt id="section-6.3.7-3.1">rdma_inv_handle:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.7-3.2">
The rdma_inv_handle field contains a 32-bit RDMA handle that
the Responder may use in a Send With Invalidation operation.
See
<a href="#section_a957db67-a8fd-4886-b7a7-57382cfe3190" class="xref">Section 6.5</a>.<a href="#section-6.3.7-3.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.7-3.3">rdma_reads:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.7-3.4">
The rdma_reads field anchors a list of zero or more Read segments
that contain only data item chunks.
A Requester
<span class="bcp14">MUST NOT</span>
insert Position-zero Read chunks in this list.<a href="#section-6.3.7-3.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.7-3.5">rdma_provisional_writes:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.7-3.6">
The rdma_writes field
anchors a list of zero or more provisional Write chunks.<a href="#section-6.3.7-3.6" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.7-3.7">rdma_provisional_reply:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.7-3.8">
The rdma_reply field is a list containing zero or one provisional Reply chunk.<a href="#section-6.3.7-3.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="section_780fd420-96d9-4cbe-af49-141ea89cdf6F">
<section id="section-6.3.8">
          <h4 id="name-rdma2_reply_external-convey">
<a href="#section-6.3.8" class="section-number selfRef">6.3.8. </a><a href="#name-rdma2_reply_external-convey" class="section-name selfRef">RDMA2_REPLY_EXTERNAL: Convey External RPC Reply Message</a>
          </h4>
<p id="section-6.3.8-1">
RDMA2_REPLY_EXTERNAL conveys an RPC Reply message payload
using explicit RDMA operations.
In particular, it is referred to as a Special Format Reply
when the Responder writes the RPC payload into a memory area
specified by a Reply chunk.
The sender
<span class="bcp14">MUST</span>
set the rdma_xid field to the same value
as the xid of the RPC Reply message payload.<a href="#section-6.3.8-1" class="pilcrow">¶</a></p>
<div id="section-6.3.8-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_REPLY_EXTERNAL = 11;

struct rpcrdma2_hdr_reply_external {
        struct rpcrdma2_write_list  *rdma_writes;
        struct rpcrdma2_write_chunk *rdma_reply;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.8-2" class="pilcrow">¶</a>
</div>
<span class="break"></span><dl class="dlParallel" id="section-6.3.8-3">
            <dt id="section-6.3.8-3.1">rdma_writes:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.8-3.2">
The rdma_writes field anchors a list of zero or more Write chunks
that are either empty or contain reduced data items.<a href="#section-6.3.8-3.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.3.8-3.3">rdma_reply:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.8-3.4">
The rdma_reply field is a list that
<span class="bcp14">MUST</span> contain exactly one Reply chunk.<a href="#section-6.3.8-3.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="section_3d6d56ae-ba9b-432f-9fc0-403a5f622fe5">
<section id="section-6.3.9">
          <h4 id="name-rdma2_reply_middle-convey-c">
<a href="#section-6.3.9" class="section-number selfRef">6.3.9. </a><a href="#name-rdma2_reply_middle-convey-c" class="section-name selfRef">RDMA2_REPLY_MIDDLE: Convey Continued RPC Reply Message</a>
          </h4>
<p id="section-6.3.9-1">
RDMA2_REPLY_MIDDLE conveys a beginning or middle portion
of an RPC Reply message
immediately following the transport header in the send buffer.
The sender
<span class="bcp14">MUST</span>
set the rdma_xid field to the same value
as the xid of the RPC Reply message payload.
The sender sets the rdma_remaining field
to the number of bytes in the RPC Call message payload
that remain to be sent.
The rdma_rpc_first_word field demarks the first word
of the Payload stream.<a href="#section-6.3.9-1" class="pilcrow">¶</a></p>
<div id="section-6.3.9-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_REPLY_MIDDLE = 12;

struct rpcrdma2_hdr_reply_middle {
        uint32                      rdma_remaining;

        /* The rpc message starts here and continues
         * through the end of the transmission. */
        uint32                      rdma_rpc_first_word;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.9-2" class="pilcrow">¶</a>
</div>
<p id="section-6.3.9-3">
If a peer sends follows an RDMA2_REPLY_MIDDLE
header type with anything other than
an RDMA2_REPLY_MIDDLE message
or
an RDMA2_REPLY_INLINE message,
the receiver
<span class="bcp14">MUST</span>
respond with an RDMA2_ERROR header type
and
set its rdma_err field to RDMA2_ERR_INVAL_CONT
and drop the incoming message without processing it further.<a href="#section-6.3.9-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_67bf730f-38f1-40bc-8eec-1bedde7b0449">
<section id="section-6.3.10">
          <h4 id="name-rdma2_reply_inline-convey-r">
<a href="#section-6.3.10" class="section-number selfRef">6.3.10. </a><a href="#name-rdma2_reply_inline-convey-r" class="section-name selfRef">RDMA2_REPLY_INLINE: Convey RPC Reply Message Inline</a>
          </h4>
<p id="section-6.3.10-1">
RDMA2_REPLY_INLINE conveys the only or final portion
of an RPC Reply message
immediately following the transport header in the send buffer.
If the Reply message payload has been reduced,
the rdma_chunks object carries the reduced data item chunks.<a href="#section-6.3.10-1" class="pilcrow">¶</a></p>
<div id="section-6.3.10-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_REPLY_INLINE = 13;

struct rpcrdma2_hdr_reply_inline {
        struct rpcrdma2_write_list  *rdma_writes;

        /* The rpc message starts here and continues
         * through the end of the transmission. */
        uint32                      rdma_rpc_first_word;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.3.10-2" class="pilcrow">¶</a>
</div>
<span class="break"></span><dl class="dlParallel" id="section-6.3.10-3">
            <dt id="section-6.3.10-3.1">rdma_writes:</dt>
            <dd style="margin-left: 1.5em" id="section-6.3.10-3.2">
The rdma_writes field anchors a list of zero or more Write chunks
that are either empty or contain reduced data items.<a href="#section-6.3.10-3.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="section_2d1735f0-c465-43c6-9c18-3da6b7979862">
<section id="section-6.4">
        <h3 id="name-transport-header-prefix">
<a href="#section-6.4" class="section-number selfRef">6.4. </a><a href="#name-transport-header-prefix" class="section-name selfRef">Transport Header Prefix</a>
        </h3>
<p id="section-6.4-1">
The following prefix structure appears at the start of each
RPC-over-RDMA version 2 transport header.<a href="#section-6.4-1" class="pilcrow">¶</a></p>
<div id="section-6.4-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

struct rpcrdma2_hdr_prefix {
        struct rpcrdma_common       rdma_start;
};


&lt;CODE ENDS&gt;</pre><a href="#section-6.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="section_a957db67-a8fd-4886-b7a7-57382cfe3190">
<section id="section-6.5">
        <h3 id="name-remote-invalidation">
<a href="#section-6.5" class="section-number selfRef">6.5. </a><a href="#name-remote-invalidation" class="section-name selfRef">Remote Invalidation</a>
        </h3>
<p id="section-6.5-1">
To solicit the use of Remote Invalidation,
a Requester sets the value of the rdma_inv_handle field
in an RPC Call's transport header
to a non-zero value that matches
one of the rdma_handle fields in that header.
If the Responder may invalidate none of the rdma_handle values
in the header conveying the Call,
the Requester sets the RPC Call's rdma_inv_handle field to the value zero.<a href="#section-6.5-1" class="pilcrow">¶</a></p>
<p id="section-6.5-2">
If the Responder chooses not to use remote invalidation
for this particular RPC Reply,
or the RPC Call's rdma_inv_handle field contains the value zero,
the Responder simply uses RDMA Send
to transmit the matching RPC reply.
However, if the Responder chooses to use Remote Invalidation,
it uses RDMA Send With Invalidate to transmit the RPC Reply.
It <span class="bcp14">MUST</span> use the value in the corresponding Call's rdma_inv_handle field
to construct the Send With Invalidate Work Request.<a href="#section-6.5-2" class="pilcrow">¶</a></p>
<p id="section-6.5-3">
A Responder never uses a Send With Invalidate Work Request when sending
a control plane header type.
This includes
the RDMA2_ERROR header type,
the RDMA2_GRANT header type,
the RDMA2_CONNPROP_MIDDLE header type,
and
the RDMA2_CONNPROP_FINAL header type.<a href="#section-6.5-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_740e5b29-8c88-40ab-9506-69635d9a8167">
<section id="section-6.6">
        <h3 id="name-payload-formats">
<a href="#section-6.6" class="section-number selfRef">6.6. </a><a href="#name-payload-formats" class="section-name selfRef">Payload Formats</a>
        </h3>
<p id="section-6.6-1">
RPC-over-RDMA version 2 provides several ways,
known as "payload formats",
to convey an RPC-over-RDMA message.
A sender chooses the payload format for each message
based on several factors:<a href="#section-6.6-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.6-2.1">
The existence of DDP-eligible data items in the RPC message payload<a href="#section-6.6-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.6-2.2">
The size of the RPC message payload<a href="#section-6.6-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.6-2.3">
The direction of the RPC message (i.e., Call or Reply)<a href="#section-6.6-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.6-2.4">
The available hardware resources<a href="#section-6.6-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.6-2.5">
The arrangement of source and sink memory buffers<a href="#section-6.6-2.5" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-6.6-3">
The following subsections describe in detail how
Requesters and Responders
format RPC-over-RDMA message payloads.<a href="#section-6.6-3" class="pilcrow">¶</a></p>
<div id="section_13a871a4-554f-4e3c-89ba-c5a75929f01E">
<section id="section-6.6.1">
          <h4 id="name-simple-format">
<a href="#section-6.6.1" class="section-number selfRef">6.6.1. </a><a href="#name-simple-format" class="section-name selfRef">Simple Format</a>
          </h4>
<p id="section-6.6.1-1">
All RPC messages conveyed via RPC-over-RDMA version 2
need at least one RDMA Send operation to convey.
Thus, the most efficient way to send an RPC message
that is smaller than the inline threshold
is to append the Payload stream directly to the Transport stream
and use an RDMA Send to convey both.
When no chunks are present, senders construct Calls and Replies the same way,
and no other operations are needed.<a href="#section-6.6.1-1" class="pilcrow">¶</a></p>
<div id="section_41c2df3b-e54d-4ccf-9eac-860f44dec2d2">
<section id="section-6.6.1.1">
            <h5 id="name-simple-format-with-data-ite">
<a href="#section-6.6.1.1" class="section-number selfRef">6.6.1.1. </a><a href="#name-simple-format-with-data-ite" class="section-name selfRef">Simple Format with Data Item Chunks</a>
            </h5>
<p id="section-6.6.1.1-1">
If DDP-eligible data items are present in a Payload stream,
a sender
<span class="bcp14">MAY</span>
reduce some or all of these items,
removing them from the Payload stream.
The sender then uses a separate mechanism to transfer the reduced data items.
The Transport stream immediately followed by
the reduced Payload stream
is then transferred using one RDMA Send operation.<a href="#section-6.6.1.1-1" class="pilcrow">¶</a></p>
<p id="section-6.6.1.1-2">
When data item chunks are present,
senders construct Calls differently than Replies.<a href="#section-6.6.1.1-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlNewline" id="section-6.6.1.1-3">
              <dt id="section-6.6.1.1-3.1">Simple Call</dt>
              <dd style="margin-left: 1.5em" id="section-6.6.1.1-3.2">
After receiving the Transport and Payload streams
of an RPC Call message with Read chunks,
the Responder uses RDMA Read operations to move
the reduced data items contained in the Read chunks.
RPC-over-RDMA Calls can carry Write chunks
for the Responder to use when sending the matching Reply.<a href="#section-6.6.1.1-3.2" class="pilcrow">¶</a>
</dd>
              <dd class="break"></dd>
<dt id="section-6.6.1.1-3.3">Simple Reply</dt>
              <dd style="margin-left: 1.5em" id="section-6.6.1.1-3.4">
The Responder uses RDMA Write operations
to move reduced data items contained in Write chunks.
Afterward, it sends the Transport and Payload streams
of the RPC Reply message using one RDMA Send.
RPC-over-RDMA Replies always carry an empty Read chunk list.<a href="#section-6.6.1.1-3.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
</dl>
</section>
</div>
<div id="section_a690cf12-0e31-4df2-a32a-8cb8e2a3b2c8">
<section id="section-6.6.1.2">
            <h5 id="name-simple-format-examples">
<a href="#section-6.6.1.2" class="section-number selfRef">6.6.1.2. </a><a href="#name-simple-format-examples" class="section-name selfRef">Simple Format Examples</a>
            </h5>
<span id="name-a-simple-call-without-data-"></span><figure id="figure-1">
              <div id="artwork_31922ae6-4df5-489a-b424-52d72e2fe778">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.1.2-1.1">
<pre>

     Requester                                 Responder
         |      RDMA Send (RDMA2_CALL_INLINE)      |
    Call |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |      RDMA Send (RDMA2_REPLY_INLINE)     |
         |   &lt;----------------------------------   | Reply

</pre>
</div>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-a-simple-call-without-data-" class="selfRef">A Simple Call without data item chunks and a Simple Reply without data item chunks</a>
              </figcaption></figure>
<span id="name-a-simple-call-with-a-read-c"></span><figure id="figure-2">
              <div id="artwork_40f8c6f0-56c5-4fb8-ac67-41522a496d79">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.1.2-2.1">
<pre>

     Requester                                 Responder
         |      RDMA Send (RDMA2_CALL_INLINE)      |
    Call |   ----------------------------------&gt;   |
         |               RDMA Read                 |
         |   &lt;----------------------------------   |
         |         RDMA Response (arg data)        |
         |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |      RDMA Send (RDMA2_REPLY_INLINE)     |
         |   &lt;----------------------------------   | Reply

</pre>
</div>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-a-simple-call-with-a-read-c" class="selfRef">A Simple Call with a Read chunk and a Simple Reply without data item chunks</a>
              </figcaption></figure>
<span id="name-a-simple-call-without-data-i"></span><figure id="figure-3">
              <div id="artwork_25fddedc-8195-40ca-a33e-e8d13dd829d7">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.1.2-3.1">
<pre>

     Requester                                 Responder
         |      RDMA Send (RDMA2_CALL_INLINE)      |
    Call |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |         RDMA Write (result data)        |
         |   &lt;----------------------------------   |
         |      RDMA Send (RDMA2_REPLY_INLINE)     |
         |   &lt;----------------------------------   | Reply

</pre>
</div>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-a-simple-call-without-data-i" class="selfRef">A Simple Call without data item chunks and a Simple Reply with a Write chunk</a>
              </figcaption></figure>
</section>
</div>
</section>
</div>
<div id="section_bda7bc14-2a3d-4224-873c-855912218987">
<section id="section-6.6.2">
          <h4 id="name-continued-format">
<a href="#section-6.6.2" class="section-number selfRef">6.6.2. </a><a href="#name-continued-format" class="section-name selfRef">Continued Format</a>
          </h4>
<p id="section-6.6.2-1">
For various reasons,
a sender can choose to split a message payload
over multiple RPC-over-RDMA messages.
The Payload stream of each RPC-over-RDMA message
contains a part of the RPC message.
The receiver reconstructs the original RPC message
by concatenating the Payload stream
of each RPC-over-RDMA message in received order.
A sender
<span class="bcp14">MAY</span>
split the Payload stream on any convenient boundary.<a href="#section-6.6.2-1" class="pilcrow">¶</a></p>
<div id="section_3b102dbf-81b2-4e0f-bb4b-d238db83ab44">
<section id="section-6.6.2.1">
            <h5 id="name-continued-format-with-data-">
<a href="#section-6.6.2.1" class="section-number selfRef">6.6.2.1. </a><a href="#name-continued-format-with-data-" class="section-name selfRef">Continued Format with Data Item Chunks</a>
            </h5>
<p id="section-6.6.2.1-1">
If DDP-eligible data items are present in the Payload stream,
a sender <span class="bcp14">MAY</span> reduce some or all of these items,
removing them from the Payload stream.
The sender then uses a separate mechanism to transfer the reduced data items.
The Transport stream immediately follwed by
the reduced Payload stream
is then transferred using one RDMA Send operation.<a href="#section-6.6.2.1-1" class="pilcrow">¶</a></p>
<p id="section-6.6.2.1-2">
As with Simple Format messages, when chunks are present,
senders construct Calls differently than Replies.<a href="#section-6.6.2.1-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlNewline" id="section-6.6.2.1-3">
              <dt id="section-6.6.2.1-3.1">Continued Call</dt>
              <dd style="margin-left: 1.5em" id="section-6.6.2.1-3.2">
After receiving the Transport and Payload streams
of an RPC Call message with Read chunks,
the Responder uses RDMA Read operations to move
the reduced data items contained in Read chunks.
RPC-over-RDMA Calls can carry Write chunks
for the Responder to use when sending the matching Reply.<a href="#section-6.6.2.1-3.2" class="pilcrow">¶</a>
</dd>
              <dd class="break"></dd>
<dt id="section-6.6.2.1-3.3">Continued Reply</dt>
              <dd style="margin-left: 1.5em" id="section-6.6.2.1-3.4">
The Responder uses RDMA Write operations
to move reduced data items contained in Write chunks.
Afterward, it sends the Transport and Payload streams
of the RPC Reply message using multiple RDMA Sends.
RPC-over-RDMA Replies always carry an empty Read chunk list.<a href="#section-6.6.2.1-3.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
</dl>
</section>
</div>
<div id="section_49c71620-d55a-4867-801a-10928118befe">
<section id="section-6.6.2.2">
            <h5 id="name-continued-format-examples">
<a href="#section-6.6.2.2" class="section-number selfRef">6.6.2.2. </a><a href="#name-continued-format-examples" class="section-name selfRef">Continued Format Examples</a>
            </h5>
<span id="name-a-continued-call-without-da"></span><figure id="figure-4">
              <div id="artwork_c7396c9d-8613-46c0-b7d0-b5641bc1f85a">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.2.2-1.1">
<pre>

     Requester                                 Responder
         |      RDMA Send (RDMA2_CALL_MIDDLE)      |
    Call |   ----------------------------------&gt;   |
         |      RDMA Send (RDMA2_CALL_MIDDLE)      |
         |   ----------------------------------&gt;   |
         |      RDMA Send (RDMA2_CALL_INLINE)      |
         |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |      RDMA Send (RDMA2_REPLY_MIDDLE)     |
         |   &lt;----------------------------------   | Reply
         |      RDMA Send (RDMA2_REPLY_MIDDLE)     |
         |   &lt;----------------------------------   |
         |      RDMA Send (RDMA2_REPLY_INLINE)     |
         |   &lt;----------------------------------   |

</pre>
</div>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-a-continued-call-without-da" class="selfRef">A Continued Call without data item chunks and a Continued Reply without data item chunks</a>
              </figcaption></figure>
<span id="name-a-continued-call-with-a-rea"></span><figure id="figure-5">
              <div id="artwork_4eece307-8a67-4b5b-a69d-ab0d37f9467f">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.2.2-2.1">
<pre>

     Requester                                 Responder
         |      RDMA Send (RDMA2_CALL_MIDDLE)      |
    Call |   ----------------------------------&gt;   |
         |      RDMA Send (RDMA2_CALL_MIDDLE)      |
         |   ----------------------------------&gt;   |
         |      RDMA Send (RDMA2_CALL_INLINE)      |
         |   ----------------------------------&gt;   |
         |              RDMA Read                  |
         |   &lt;----------------------------------   |
         |         RDMA Response (arg data)        |
         |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |      RDMA Send (RDMA2_REPLY_INLINE)     |
         |   &lt;----------------------------------   | Reply

</pre>
</div>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-a-continued-call-with-a-rea" class="selfRef">A Continued Call with a Read chunk and a Simple Reply without data item chunks</a>
              </figcaption></figure>
<span id="name-a-simple-call-without-data-it"></span><figure id="figure-6">
              <div id="artwork_4453c7eb-318c-42c8-befb-67f6a251f430">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.2.2-3.1">
<pre>

     Requester                                 Responder
         |      RDMA Send (RDMA2_CALL_INLINE)      |
    Call |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |         RDMA Write (result data)        |
         |   &lt;----------------------------------   |
         |      RDMA Send (RDMA2_REPLY_MIDDLE)     |
         |   &lt;----------------------------------   | Reply
         |      RDMA Send (RDMA2_REPLY_MIDDLE)     |
         |   &lt;----------------------------------   |
         |      RDMA Send (RDMA2_REPLY_INLINE)     |
         |   &lt;----------------------------------   |

</pre>
</div>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-a-simple-call-without-data-it" class="selfRef">A Simple Call without data item chunks and a Continued Reply with a Write chunk</a>
              </figcaption></figure>
</section>
</div>
</section>
</div>
<div id="section_d9731520-bdde-4a1b-9f54-9901d5c57648">
<section id="section-6.6.3">
          <h4 id="name-special-format">
<a href="#section-6.6.3" class="section-number selfRef">6.6.3. </a><a href="#name-special-format" class="section-name selfRef">Special Format</a>
          </h4>
<p id="section-6.6.3-1">
Even after DDP-eligible data items have been removed,
a Payload stream can sometimes be too large
to send using only RDMA Send operations.
In those cases, the sender can use RDMA Read or Write operations
to convey the entire RPC message.
We refer to this as a "Special Format" message.<a href="#section-6.6.3-1" class="pilcrow">¶</a></p>
<p id="section-6.6.3-2">
To transmit a Special Format message,
the sender transmits only the Transport stream
with an RDMA Send operation.
The sender does not include the Payload stream in the send buffer.
Instead, the Requester provides a body chunk that the Responder
uses to move the Payload stream.<a href="#section-6.6.3-2" class="pilcrow">¶</a></p>
<p id="section-6.6.3-3">
Because chunks are always present in Special Format messages,
the sender always handles Calls and Replies differently.<a href="#section-6.6.3-3" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlNewline" id="section-6.6.3-4">
            <dt id="section-6.6.3-4.1">Special Call</dt>
            <dd style="margin-left: 1.5em" id="section-6.6.3-4.2">
The Requester provides a Read chunk
that contains the RPC Call message's Payload stream.
Every Read segment in this chunk
<span class="bcp14">MUST</span>
contain zero (0) in its Position field.
This type of Read chunk is a body chunk known as a Call chunk.<a href="#section-6.6.3-4.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.6.3-4.3">Special Reply</dt>
            <dd style="margin-left: 1.5em" id="section-6.6.3-4.4">
The Requester provisions a Reply chunk in advance.
This body chunk is a Write chunk into which
the Responder places the RPC Reply message's Payload stream.
The Requester provisions the Reply chunk to accommodate
the maximum expected reply size for that upper-layer operation.<a href="#section-6.6.3-4.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-6.6.3-5">
One purpose of a Special Format message is to handle large RPC messages.
However, Requesters
<span class="bcp14">MAY</span>
use a Special Format message at any time to convey an RPC Call message.<a href="#section-6.6.3-5" class="pilcrow">¶</a></p>
<p id="section-6.6.3-6">
When it has alternatives,
a Responder chooses which Format to use based on the chunks
provided by the Requester.
If a Requester provided a Write chunk
and
the Responder has a DDP-eligible result,
it first reduces the reply Payload stream.
If a Requester provided a Reply chunk
and
the reduced Payload stream is larger than the reply inline threshold,
the Responder
<span class="bcp14">MUST</span>
use the Requester-provided Reply chunk for the reply.<a href="#section-6.6.3-6" class="pilcrow">¶</a></p>
<div id="section_199de5c1-e307-4664-abeb-dd687b4329c3">
<section id="section-6.6.3.1">
            <h5 id="name-special-format-examples">
<a href="#section-6.6.3.1" class="section-number selfRef">6.6.3.1. </a><a href="#name-special-format-examples" class="section-name selfRef">Special Format Examples</a>
            </h5>
<span id="name-a-special-call-and-a-simple"></span><figure id="figure-7">
              <div id="anchor_fd75308e-ce7d-4670-a0b0-9ee84d8f6411">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.3.1-1.1">
<pre>

     Requester                                 Responder
         |     RDMA Send (RDMA2_CALL_EXTERNAL)     |
    Call |   ----------------------------------&gt;   |
         |               RDMA Read                 |
         |   &lt;----------------------------------   |
         |         RDMA Response (RPC call)        |
         |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |      RDMA Send (RDMA2_REPLY_INLINE)     |
         |   &lt;----------------------------------   | Reply

</pre>
</div>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-a-special-call-and-a-simple" class="selfRef">A Special Call and a Simple Reply without data item chunks</a>
              </figcaption></figure>
<span id="name-a-simple-call-without-data-ite"></span><figure id="figure-8">
              <div id="anchor_12f3b386-b806-41b4-a472-eb216266523e">
<div class="alignLeft art-call-flow art-text artwork" id="section-6.6.3.1-2.1">
<pre>

     Requester                                 Responder
         |      RDMA Send (RDMA2_CALL_INLINE)      |
    Call |   ----------------------------------&gt;   |
         |                                         |
         |                                         | Processing
         |                                         |
         |          RDMA Write (RPC reply)         |
         |   &lt;----------------------------------   |
         |     RDMA Send (RDMA2_REPLY_EXTERNAL)    |
         |   &lt;----------------------------------   | Reply

</pre>
</div>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-a-simple-call-without-data-ite" class="selfRef">A Simple Call without data item chunks and a Special Reply</a>
              </figcaption></figure>
</section>
</div>
</section>
</div>
<div id="section_19fc8c94-d83f-4c1b-8ce3-700918d129b5">
<section id="section-6.6.4">
          <h4 id="name-choosing-a-reply-payload-fo">
<a href="#section-6.6.4" class="section-number selfRef">6.6.4. </a><a href="#name-choosing-a-reply-payload-fo" class="section-name selfRef">Choosing a Reply Payload Format</a>
          </h4>
<p id="section-6.6.4-1">
A Requester provisions all necessary registered memory resources
for both an RPC Call and its matching RPC Reply.
A Requester constructs each RPC Call, thus it can compute
the exact memory resources needed to send every Call.
However, the Requester allocates memory resources
to receive the corresponding Reply before the Responder has constructed it.
Occasionally, it is challenging for the Requester
to know in advance precisely what resources are needed to receive the Reply.<a href="#section-6.6.4-1" class="pilcrow">¶</a></p>
<p id="section-6.6.4-2">
In RPC-over-RDMA version 2,
a Requester can provide a Reply chunk for any transaction.
The Responder can use the provided Reply chunk
or
it can decide to use another means to convey the RPC Reply.
If
the combination of the provided Write chunk list
and
Reply chunk
is not adequate to convey a Reply,
the Responder <span class="bcp14">SHOULD</span> use Message Continuation
to send that Reply.
If even that is not possible,
the Responder sends an RDMA2_ERROR message to the Requester,
as described in
<a href="#section_b1d23e5c-31df-483f-adb7-25430b5de38d" class="xref">Section 6.3.1</a>:<a href="#section-6.6.4-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.6.4-3.1">
If the Write chunk list cannot accommodate the ULP's DDP-eligible data payload,
the Responder sends an RDMA2_ERR_WRITE_RESOURCE error.<a href="#section-6.6.4-3.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.6.4-3.2">
If the Reply chunk cannot accommodate the parts of the Reply that are not DDP-eligible,
the Responder sends an RDMA2_ERR_REPLY_RESOURCE error.<a href="#section-6.6.4-3.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-6.6.4-4">
When receiving such errors,
the Requester can retry the ULP call using more substantial reply resources.
In cases where retrying the ULP request is not possible
(e.g., the request is non-idempotent),
the Requester terminates the RPC transaction
and presents an error to the RPC consumer.<a href="#section-6.6.4-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="section_995a7597-4e89-48c3-b142-35b783ef1329">
<section id="section-7">
      <h2 id="name-error-handling">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-error-handling" class="section-name selfRef">Error Handling</a>
      </h2>
<p id="section-7-1">
A receiver performs validity checks
on each ingress RPC-over-RDMA message
before it assembles that message's Payload stream
and
passes it to the RPC layer.
For example, if an ingress RPC-over-RDMA message is not as long as
the size of struct rpcrdma2_hdr_prefix (20 octets),
the receiver cannot trust the value of the rdma_xid field.
In this case, the receiver <span class="bcp14">MUST</span> silently discard the ingress message
without processing it further, and without a response to the sender.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">
When a request
(for instance, an RPC Call or a control plane operation)
is made,
typically an RPC consumer blocks while waiting for the response.
Thus when an incoming message conveys a request
and that request cannot be acted upon,
the receiver of that request needs
to report the problem to its sender
in order to unblock waiters.
Likewise, if, after processing a request,
a sender is unable to transmit the response
on an otherwise healthy connection,
the sender needs to report that problem
for the same reason.<a href="#section-7-2" class="pilcrow">¶</a></p>
<p id="section-7-3">
The RDMA2_ERROR header type is used for this purpose.
To form an RDMA2_ERROR type header:<a href="#section-7-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-4.1">
The rdma_xid field <span class="bcp14">MUST</span> contain the same XID
that was in the rdma_xid field in the ingress request.<a href="#section-7-4.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-7-4.2">
The rdma_vers field <span class="bcp14">MUST</span> contain the same version
that was in the rdma_vers field in the ingress request.<a href="#section-7-4.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-7-4.3">
The sender sets the rdma_credit field to the credit values in effect
for this connection.<a href="#section-7-4.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-7-4.4">
The rdma_htype field <span class="bcp14">MUST</span> contain the value RDMA2_ERROR.<a href="#section-7-4.4" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-7-4.5">
The rdma_err field contains a value
that reflects the type of error that occurred,
as described in the subsections below.<a href="#section-7-4.5" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-7-5">
When a peer receives an RDMA2_ERROR message type
with an unrecognized or unsupported value in its rdma_err field,
it <span class="bcp14">MUST</span> silently discard the message without processing it further.<a href="#section-7-5" class="pilcrow">¶</a></p>
<div id="section_c445fd74-d6c2-4f64-a215-844c84da4b6b">
<section id="section-7.1">
        <h3 id="name-basic-transport-stream-pars">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-basic-transport-stream-pars" class="section-name selfRef">Basic Transport Stream Parsing Errors</a>
        </h3>
<div id="section_4a5e9013-9c26-4776-afbd-95318cb2ea8a">
<section id="section-7.1.1">
          <h4 id="name-rdma2_err_vers">
<a href="#section-7.1.1" class="section-number selfRef">7.1.1. </a><a href="#name-rdma2_err_vers" class="section-name selfRef">RDMA2_ERR_VERS</a>
          </h4>
<p id="section-7.1.1-1">
When a Responder detects an RPC-over-RDMA header version
that it does not support
(the current document defines version 2),
it <span class="bcp14">MUST</span> respond with an RDMA2_ERROR message type
and
set its rdma_err field to RDMA2_ERR_VERS.
The Responder then fills in the rpcrdma2_err_vers structure
with the RPC-over-RDMA versions it supports.
The Responder <span class="bcp14">MUST</span> silently discard the ingress message
without passing it to the RPC layer.<a href="#section-7.1.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1.1-2">
When a Requester receives this error message,
it uses the information in the rpcrdma2_err_vers structure
to select an RPC-over-RDMA version that both peers support
for subsequent operations on the connection.
A Requester <span class="bcp14">MUST NOT</span> subsequently send a message that uses
a version that the Responder has indicated it does not support.
RDMA2_ERR_VERS indicates a permanent error.
Receipt of this error completes the RPC transaction
associated with XID in the rdma_xid field.<a href="#section-7.1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_97a4dbec-8b72-43f8-9ebb-e822ec3ad713">
<section id="section-7.1.2">
          <h4 id="name-rdma2_err_vers_mismatch">
<a href="#section-7.1.2" class="section-number selfRef">7.1.2. </a><a href="#name-rdma2_err_vers_mismatch" class="section-name selfRef">RDMA2_ERR_VERS_MISMATCH</a>
          </h4>
<p id="section-7.1.2-1">
When a Responder receives a message
with a transport protocol version
that does not match the protocol version
that was used in previous successful exchanges on the same connection,
it
<span class="bcp14">MUST</span>
respond with an RDMA2_ERROR message type
and
set its rdma_err field to RDMA2_ERR_VERS_MISMATCH.
The Responder
<span class="bcp14">MUST</span>
silently discard the ingress message without passing it to the RPC layer.<a href="#section-7.1.2-1" class="pilcrow">¶</a></p>
<p id="section-7.1.2-2">
A Requester <span class="bcp14">MUST NOT</span> subsequently send a message
that uses a protocol version
that the Responder has indicated it does not recognize on this connection.
The Requester can recover by sending the message again
using a corrected protocol version,
or
it can terminate the RPC transaction associated with the XID
in the rdma_xid field with an error.<a href="#section-7.1.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_9754ea3a-d237-41cf-9739-99843e11e524">
<section id="section-7.1.3">
          <h4 id="name-rdma2_err_inval_htype">
<a href="#section-7.1.3" class="section-number selfRef">7.1.3. </a><a href="#name-rdma2_err_inval_htype" class="section-name selfRef">RDMA2_ERR_INVAL_HTYPE</a>
          </h4>
<p id="section-7.1.3-1">
If a Responder recognizes the value in an ingress rdma_vers field,
but it does not recognize the value in the rdma_htype field
or
does not support that header type,
it <span class="bcp14">MUST</span> set the rdma_err field to RDMA2_ERR_INVAL_HTYPE.
The Responder <span class="bcp14">MUST</span> silently discard the incoming message
without passing it to the RPC layer.<a href="#section-7.1.3-1" class="pilcrow">¶</a></p>
<p id="section-7.1.3-2">
A Requester <span class="bcp14">MUST NOT</span> subsequently send a message
on the connection that uses
an htype that the Responder has indicated it does not support.
RDMA2_ERR_INVAL_HTYPE indicates a permanent error.
Receipt of this error completes the RPC transaction
associated with XID in the rdma_xid field.<a href="#section-7.1.3-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_37afd7d4-5d72-4300-ad6d-95558cdd5e19">
<section id="section-7.1.4">
          <h4 id="name-rdma2_err_inval_cont">
<a href="#section-7.1.4" class="section-number selfRef">7.1.4. </a><a href="#name-rdma2_err_inval_cont" class="section-name selfRef">RDMA2_ERR_INVAL_CONT</a>
          </h4>
<p id="section-7.1.4-1">
If a Responder detects a problem with an ingress RPC-over-RDMA message
that is part of a Message Continuation sequence,
the Responder <span class="bcp14">MUST</span> set the rdma_err field to RDMA2_ERR_INVAL_CONT.
The Responder <span class="bcp14">MUST</span> silently discard all ingress messages
with an rdma_xid field that matches the failing message
without reassembling the payload.<a href="#section-7.1.4-1" class="pilcrow">¶</a></p>
<p id="section-7.1.4-2">
RDMA2_ERR_INVAL_CONT indicates a permanent error.
Receipt of this error completes the RPC transaction
associated with XID in the rdma_xid field.<a href="#section-7.1.4-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_932d8a55-30e3-412c-8b78-355606742861">
<section id="section-7.2">
        <h3 id="name-xdr-errors">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-xdr-errors" class="section-name selfRef">XDR Errors</a>
        </h3>
<p id="section-7.2-1">
A receiver might encounter an XDR parsing error that
prevents it from processing an ingress Transport stream.
Examples of such errors include:<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.2-2.1">
The value of the rdma_xid field does not match
the value of the XID field in the accompanying RPC
message.<a href="#section-7.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.2-2.2">
The receive buffer ends before the end of a data
object contained in the Transport stream.<a href="#section-7.2-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.2-3">
Moreover, when a Responder receives a valid RPC-over-RDMA header
but the Responder's ULP implementation cannot parse the RPC arguments
in the RPC Call,
the Responder returns an RPC Reply with status GARBAGE_ARGS,
using an RDMA2_REPLY_INLINE message type.
This type of parsing failure might be due to mismatches
between chunk sizes or offsets
and
the contents of the Payload stream, for example.
In this case, the error is permanent,
but the Requester has no way to know how much processing
the Responder has completed for this RPC transaction.<a href="#section-7.2-3" class="pilcrow">¶</a></p>
<div id="section_90449e5c-e65a-48c0-80bf-e9080d67094e">
<section id="section-7.2.1">
          <h4 id="name-rdma2_err_bad_xdr">
<a href="#section-7.2.1" class="section-number selfRef">7.2.1. </a><a href="#name-rdma2_err_bad_xdr" class="section-name selfRef">RDMA2_ERR_BAD_XDR</a>
          </h4>
<p id="section-7.2.1-1">
If a Responder recognizes the values in the rdma_vers field,
but it cannot otherwise parse the ingress Transport stream,
it <span class="bcp14">MUST</span> set the rdma_err field to RDMA2_ERR_BAD_XDR.
The Responder <span class="bcp14">MUST</span> silently discard the ingress message
without passing it to the RPC layer.<a href="#section-7.2.1-1" class="pilcrow">¶</a></p>
<p id="section-7.2.1-2">
RDMA2_ERR_BAD_XDR indicates a permanent error.
Receipt of this error completes the RPC transaction
associated with XID in the rdma_xid field.<a href="#section-7.2.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_4a3d9ac4-4083-46d1-99b4-76a0b1ac93bf">
<section id="section-7.2.2">
          <h4 id="name-rdma2_err_bad_propval">
<a href="#section-7.2.2" class="section-number selfRef">7.2.2. </a><a href="#name-rdma2_err_bad_propval" class="section-name selfRef">RDMA2_ERR_BAD_PROPVAL</a>
          </h4>
<p id="section-7.2.2-1">
If a receiver recognizes the value in an ingress rdma_which field,
but it cannot parse the accompanying propval,
it <span class="bcp14">MUST</span> set the rdma_err field to RDMA2_ERR_BAD_PROPVAL (see
<a href="#section_d5ac12f6-6735-48f3-b4ba-b44a19ff9298" class="xref">Section 5.1</a>).
The receiver <span class="bcp14">MUST</span> silently discard the ingress message
without applying any of its property settings.<a href="#section-7.2.2-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_87c5f543-7092-4faf-b13e-0e994e8023a7">
<section id="section-7.3">
        <h3 id="name-responder-rdma-operational-">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-responder-rdma-operational-" class="section-name selfRef">Responder RDMA Operational Errors</a>
        </h3>
<p id="section-7.3-1">
In RPC-over-RDMA version 2,
the Responder initiates RDMA Read and Write operations
that target the Requester's memory.
Problems might arise as the Responder attempts
to use Requester-provided resources for RDMA operations.
For example:<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3-2.1">
Usually, chunks can be validated only by using their contents to perform data transfers.
If chunk contents are invalid
(e.g., a memory region is no longer registered
or
a chunk length exceeds the end of the registered memory region),
a Remote Access Error occurs.<a href="#section-7.3-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.3-2.2">If a Requester's Receive buffer is too small,
the Responder's Send operation completes with a Local Length Error.<a href="#section-7.3-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.3-2.3">
If the Requester-provided Reply chunk is too small
to accommodate a large RPC Reply message,
a Remote Access Error occurs.
A Responder might detect this problem before attempting to write past the end of the Reply chunk.<a href="#section-7.3-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.3-3">
RDMA operational errors can be fatal to the connection.
To avoid a retransmission loop and repeated connection loss that deadlocks the connection,
once the Requester has re-established a connection,
the Responder
<span class="bcp14">SHOULD</span>
send an RDMA2_ERROR response
to indicate that no RPC-level reply is possible for that transaction.<a href="#section-7.3-3" class="pilcrow">¶</a></p>
<div id="section_77a9225b-7b43-4899-b9d1-5df14310a144">
<section id="section-7.3.1">
          <h4 id="name-rdma2_err_read_chunks">
<a href="#section-7.3.1" class="section-number selfRef">7.3.1. </a><a href="#name-rdma2_err_read_chunks" class="section-name selfRef">RDMA2_ERR_READ_CHUNKS</a>
          </h4>
<p id="section-7.3.1-1">
If a Requester presents more DDP-eligible arguments
than a Responder is prepared to Read,
the Responder <span class="bcp14">MUST</span>
set the rdma_err field to RDMA2_ERR_READ_CHUNKS
and
set the rdma_max_chunks field
to the maximum number of Read chunks the Responder can process.
If the Responder implementation cannot handle any Read chunks for a request,
it <span class="bcp14">MUST</span> set the rdma_max_chunks to zero in this response.
The Responder <span class="bcp14">MUST</span> silently discard the ingress message
without processing it further.<a href="#section-7.3.1-1" class="pilcrow">¶</a></p>
<p id="section-7.3.1-2">
The Requester can reconstruct the Call using
Message Continuation
or
a Special Format payload
and resend it.
If the Requester chooses not to resend the Call,
it <span class="bcp14">MUST</span> terminate this RPC transaction with an error.<a href="#section-7.3.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_61617957-ee18-4d10-bf47-3b932739eee4">
<section id="section-7.3.2">
          <h4 id="name-rdma2_err_write_chunks">
<a href="#section-7.3.2" class="section-number selfRef">7.3.2. </a><a href="#name-rdma2_err_write_chunks" class="section-name selfRef">RDMA2_ERR_WRITE_CHUNKS</a>
          </h4>
<p id="section-7.3.2-1">
If a Requester has constructed an RPC Call
with more DDP-eligible results than
the Responder is prepared to Write,
the Responder <span class="bcp14">MUST</span> set the rdma_err field to RDMA2_ERR_WRITE_CHUNKS
and
set the rdma_max_chunks field
to the maximum number of Write chunks the Responder can return.
The Requester can reconstruct the Call
with no Write chunks
and
a Reply chunk of appropriate size.
If the Requester does not resend the Call,
it <span class="bcp14">MUST</span> terminate this RPC transaction with an error.<a href="#section-7.3.2-1" class="pilcrow">¶</a></p>
<p id="section-7.3.2-2">
If the Responder implementation cannot handle any Write chunks
for a request
and
cannot send the Reply using Message Continuation,
it <span class="bcp14">MUST</span> return a response of RDMA2_ERR_REPLY_RESOURCE instead (see below).<a href="#section-7.3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_ff471562-5a8f-4dbd-8f37-ac41c5587b93">
<section id="section-7.3.3">
          <h4 id="name-rdma2_err_segments">
<a href="#section-7.3.3" class="section-number selfRef">7.3.3. </a><a href="#name-rdma2_err_segments" class="section-name selfRef">RDMA2_ERR_SEGMENTS</a>
          </h4>
<p id="section-7.3.3-1">
If a Requester has constructed an RPC Call
with a chunk that contains more segments than the Responder supports,
the Responder <span class="bcp14">MUST</span>
set the rdma_err field to RDMA2_ERR_SEGMENTS
and
set the rdma_max_segments field
to the maximum number of segments the Responder can process.
The Requester can reconstruct the Call and resend it.
If the Requester does not resend the Call,
it <span class="bcp14">MUST</span> terminate this RPC transaction with an error.<a href="#section-7.3.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_229512aa-cd65-4d5e-b66e-65a4ed3731cc">
<section id="section-7.3.4">
          <h4 id="name-rdma2_err_write_resource">
<a href="#section-7.3.4" class="section-number selfRef">7.3.4. </a><a href="#name-rdma2_err_write_resource" class="section-name selfRef">RDMA2_ERR_WRITE_RESOURCE</a>
          </h4>
<p id="section-7.3.4-1">
If a Requester has provided a Write chunk
that is not large enough to contain a DDP-eligible result,
the Responder <span class="bcp14">MUST</span> set the rdma_err field to RDMA2_ERR_WRITE_RESOURCE.
The Responder <span class="bcp14">MUST</span> set the rdma_chunk_index field
to point to the first Write chunk in the transport header
that is too short,
or to zero to indicate that it was not possible
to determine which chunk is too small.
Indexing starts at one (1), which represents the first Write chunk.
The Responder <span class="bcp14">MUST</span> set the rdma_length_needed to the number of bytes
needed in that chunk to convey the result data item.<a href="#section-7.3.4-1" class="pilcrow">¶</a></p>
<p id="section-7.3.4-2">
The Requester can reconstruct the Call with more reply resources
and resend it.
If the Requester does not resend the Call
(for instance, if the Responder set the index and length fields to zero),
it <span class="bcp14">MUST</span> terminate this RPC transaction with an error.<a href="#section-7.3.4-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_7b2d20ad-072e-4b9c-8a16-e9a28009ae6b">
<section id="section-7.3.5">
          <h4 id="name-rdma2_err_reply_resource">
<a href="#section-7.3.5" class="section-number selfRef">7.3.5. </a><a href="#name-rdma2_err_reply_resource" class="section-name selfRef">RDMA2_ERR_REPLY_RESOURCE</a>
          </h4>
<p id="section-7.3.5-1">
If a Responder cannot send an RPC Reply
using Message Continuation
and
the Reply does not fit in the Reply chunk,
the Responder <span class="bcp14">MUST</span> set the rdma_err field to RDMA2_ERR_REPLY_RESOURCE.
The Responder <span class="bcp14">MUST</span> set the rdma_length_needed
to the number of Reply chunk bytes needed to convey the reply.
The Requester can reconstruct the Call with more reply resources
and resend it.
If the Requester does not resend the Call
(for instance, if the Responder set the length field to zero),
it <span class="bcp14">MUST</span> terminate this RPC transaction with an error.<a href="#section-7.3.5-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_125537e3-1b73-465f-9602-c3986df297d6">
<section id="section-7.4">
        <h3 id="name-other-operational-errors">
<a href="#section-7.4" class="section-number selfRef">7.4. </a><a href="#name-other-operational-errors" class="section-name selfRef">Other Operational Errors</a>
        </h3>
<p id="section-7.4-1">
While a Requester is constructing an RPC Call message,
an unrecoverable problem might occur
that prevents the Requester from posting further RDMA Work Requests on behalf of that message.
As with other transports,
if a Requester is unable to construct and transmit an RPC Call,
the associated RPC transaction fails immediately.<a href="#section-7.4-1" class="pilcrow">¶</a></p>
<p id="section-7.4-2">
After a Requester has received a Reply,
if it is unable to invalidate a memory region due to an unrecoverable problem,
the Requester <span class="bcp14">MUST</span> close the connection to protect that memory
from Responder access before the associated RPC transaction is complete.<a href="#section-7.4-2" class="pilcrow">¶</a></p>
<p id="section-7.4-3">
While a Responder is constructing an RPC Reply message or error message,
an unrecoverable problem might occur that prevents the Responder
from posting further RDMA Work Requests on behalf of that message.
If a Responder is unable to construct and transmit
an RPC Reply
or
RPC-over-RDMA error message,
the Responder <span class="bcp14">MUST</span> close the connection
to signal to the Requester that a reply was lost.<a href="#section-7.4-3" class="pilcrow">¶</a></p>
<div id="section_8a40d281-66fb-4f61-a686-190624aa4001">
<section id="section-7.4.1">
          <h4 id="name-rdma2_err_system">
<a href="#section-7.4.1" class="section-number selfRef">7.4.1. </a><a href="#name-rdma2_err_system" class="section-name selfRef">RDMA2_ERR_SYSTEM</a>
          </h4>
<p id="section-7.4.1-1">
If some problem occurs on a Responder
that does not fit into the above categories,
the Responder <span class="bcp14">MAY</span> report it to the Requester
by setting the rdma_err field to RDMA2_ERR_SYSTEM.
The Responder <span class="bcp14">MUST</span> silently discard the message(s)
associated with the failing transaction
without further processing.<a href="#section-7.4.1-1" class="pilcrow">¶</a></p>
<p id="section-7.4.1-2">
RDMA2_ERR_SYSTEM is a permanent error.
This error does not indicate
how much of the transaction the Responder has processed,
nor does it indicate a particular recovery action for the Requester.
A Requester that receives this error <span class="bcp14">MUST</span> terminate the RPC transaction
associated with the XID value in the RDMA2_ERROR message's rdma_xid field.<a href="#section-7.4.1-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_1b7beb7d-b694-4309-95ee-f81a05637ef6">
<section id="section-7.5">
        <h3 id="name-rdma-transport-errors">
<a href="#section-7.5" class="section-number selfRef">7.5. </a><a href="#name-rdma-transport-errors" class="section-name selfRef">RDMA Transport Errors</a>
        </h3>
<p id="section-7.5-1">
The RDMA connection and physical link
provide some degree of error detection and retransmission.
The Marker PDU Aligned Framing (MPA) protocol (as described in
<span><a href="https://rfc-editor.org/rfc/rfc5044#section-7.1" class="relref">Section 7.1</a> of [<a href="#RFC5044" class="xref">RFC5044</a>]</span>)
as well as the InfiniBand link layer
<span>[<a href="#IBA" class="xref">IBA</a>]</span>
provide Cyclic Redundancy Check (CRC) protection of RDMA payloads.
CRC-class protection is a general attribute of such transports.<a href="#section-7.5-1" class="pilcrow">¶</a></p>
<p id="section-7.5-2">
Additionally, the RPC layer itself can accept errors
from the transport and recover via retransmission.
RPC recovery can typically handle
complete loss and re-establishment of a transport connection.<a href="#section-7.5-2" class="pilcrow">¶</a></p>
<p id="section-7.5-3">
The details of reporting and recovery from RDMA link-layer errors
are described in
specific link-layer APIs and operational specifications
and are outside the scope of this protocol specification.
See
<a href="#section_912a2c09-95ec-4cb6-aa2b-2245726d9edf" class="xref">Section 11</a>
for further discussion of RPC-level integrity schemes.<a href="#section-7.5-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_bf53e759-d97f-487d-a5e2-9b8153db1803">
<section id="section-8">
      <h2 id="name-xdr-protocol-definition">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-xdr-protocol-definition" class="section-name selfRef">XDR Protocol Definition</a>
      </h2>
<p id="section-8-1">
This section contains a description of the core features
of the RPC-over-RDMA version 2 protocol
expressed in the XDR language
<span>[<a href="#RFC4506" class="xref">RFC4506</a>]</span>.
It organizes the description to make it simple
to extract into a form that is
ready to compile
or
combine with similar descriptions published later
as extensions to RPC-over-RDMA version 2.<a href="#section-8-1" class="pilcrow">¶</a></p>
<div id="section_aaab9699-eae3-46ca-a1d5-a8776a5ecb7d">
<section id="section-8.1">
        <h3 id="name-code-component-license">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-code-component-license" class="section-name selfRef">Code Component License</a>
        </h3>
<p id="section-8.1-1">
Code Components extracted from the current document
must include the following license text.
When combining the extracted XDR code
with other XDR code which has an identical license,
only a single copy of the license text needs to be retained.<a href="#section-8.1-1" class="pilcrow">¶</a></p>
<div id="section-8.1-2">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

/// /*
///  * Copyright (c) 2010, 2020 IETF Trust and the persons
///  * identified as authors of the code.  All rights reserved.
///  *
///  * The authors of the code are:
///  * B. Callaghan, T. Talpey, C. Lever, and D. Noveck.
///  *
///  * Redistribution and use in source and binary forms, with
///  * or without modification, are permitted provided that the
///  * following conditions are met:
///  *
///  * - Redistributions of source code must retain the above
///  *   copyright notice, this list of conditions and the
///  *   following disclaimer.
///  *
///  * - Redistributions in binary form must reproduce the above
///  *   copyright notice, this list of conditions and the
///  *   following disclaimer in the documentation and/or other
///  *   materials provided with the distribution.
///  *
///  * - Neither the name of Internet Society, IETF or IETF
///  *   Trust, nor the names of specific contributors, may be
///  *   used to endorse or promote products derived from this
///  *   software without specific prior written permission.
///  *
///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
///  *   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///  */
///


&lt;CODE ENDS&gt;</pre><a href="#section-8.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="section_a288b3e6-5e73-412d-91e8-f87c031cb05b">
<section id="section-8.2">
        <h3 id="name-extraction-of-the-xdr-defin">
<a href="#section-8.2" class="section-number selfRef">8.2. </a><a href="#name-extraction-of-the-xdr-defin" class="section-name selfRef">Extraction of the XDR Definition</a>
        </h3>
<p id="section-8.2-1">
Implementers can apply the following sed script
to the current document to produce
a machine-readable XDR description
of the base RPC-over-RDMA version 2 protocol.<a href="#section-8.2-1" class="pilcrow">¶</a></p>
<div id="section-8.2-2">
<pre class="sourcecode">&lt;CODE BEGINS&gt;

sed -n -e 's:^ */// ::p' -e 's:^ *///$::p'


&lt;CODE ENDS&gt;</pre><a href="#section-8.2-2" class="pilcrow">¶</a>
</div>
<p id="section-8.2-3">
That is, if this document is in a file called "spec.txt",
then implementers can do the following
to extract an XDR description file
and store it in the file rpcrdma-v2.x.<a href="#section-8.2-3" class="pilcrow">¶</a></p>
<div id="section-8.2-4">
<pre class="sourcecode">&lt;CODE BEGINS&gt;

sed -n -e 's:^ */// ::p' -e 's:^ *///$::p' \
 &lt; spec.txt &gt; rpcrdma-v2.x


&lt;CODE ENDS&gt;</pre><a href="#section-8.2-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2-5">
Although this file is a usable description of the base protocol,
when extensions are to be supported,
it may be desirable to divide the description into multiple files.
The following script achieves that purpose:<a href="#section-8.2-5" class="pilcrow">¶</a></p>
<div id="section-8.2-6">
<pre class="lang-perl sourcecode">&lt;CODE BEGINS&gt;

#!/usr/local/bin/perl
open(IN,"rpcrdma-v2.x");
open(OUT,"&gt;temp.x");
while(&lt;IN&gt;)
{
  if (m/FILE ENDS: (.*)$/)
    {
      close(OUT);
      rename("temp.x", $1);
      open(OUT,"&gt;temp.x");
    }
    else
    {
      print OUT $_;
    }
}
close(IN);
close(OUT);


&lt;CODE ENDS&gt;</pre><a href="#section-8.2-6" class="pilcrow">¶</a>
</div>
<p id="section-8.2-7">
Running the above script results in two files:<a href="#section-8.2-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.2-8.1">
The file common.x, containing the license
plus the shared XDR definitions
that need to be made available
to both the base protocol and any subsequent extensions.<a href="#section-8.2-8.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-8.2-8.2">
The file baseops.x containing the XDR definitions
for the base protocol defined in this document.<a href="#section-8.2-8.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-8.2-9">
Extensions to RPC-over-RDMA version 2,
published as Standards Track documents,
should have similarly structured XDR definitions.
Once an implementer has extracted
the XDR for all desired extensions
and
the base XDR definition contained in the current document,
she can concatenate them to produce
a consolidated XDR definition
that reflects the set of extensions
selected for her RPC-over-RDMA version 2 implementation.<a href="#section-8.2-9" class="pilcrow">¶</a></p>
<p id="section-8.2-10">
Alternatively, the XDR descriptions can be compiled separately.
In that case, the combination of common.x and baseops.x
defines the base transport.
The combination of common.x and the XDR description
of each extension produces a full XDR definition of that extension.<a href="#section-8.2-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_b25ffcfc-511f-4383-8025-4a68cfcb4f49">
<section id="section-8.3">
        <h3 id="name-xdr-definition-for-rpc-over">
<a href="#section-8.3" class="section-number selfRef">8.3. </a><a href="#name-xdr-definition-for-rpc-over" class="section-name selfRef">XDR Definition for RPC-over-RDMA Version 2 Core Structures</a>
        </h3>
<div id="section-8.3-1">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

/// /***************************************************************
///  *    Transport Header Prefixes
///  ***************************************************************/
///
/// struct rpcrdma_common {
///         uint32         rdma_xid;
///         uint32         rdma_vers;
///         uint32         rdma_credit;
///         uint32         rdma_htype;
/// };
///
/// struct rpcrdma2_hdr_prefix {
///         struct rpcrdma_common       rdma_start;
/// };
///
/// /***************************************************************
///  *    Chunks and Chunk Lists
///  ***************************************************************/
///
/// struct rpcrdma2_segment {
///         uint32 rdma_handle;
///         uint32 rdma_length;
///         uint64 rdma_offset;
/// };
///
/// struct rpcrdma2_read_segment {
///         uint32                  rdma_position;
///         struct rpcrdma2_segment rdma_target;
/// };
///
/// struct rpcrdma2_read_list {
///         struct rpcrdma2_read_segment rdma_entry;
///         struct rpcrdma2_read_list    *rdma_next;
/// };
///
/// struct rpcrdma2_write_chunk {
///         struct rpcrdma2_segment rdma_target&lt;&gt;;
/// };
///
/// struct rpcrdma2_write_list {
///         struct rpcrdma2_write_chunk rdma_entry;
///         struct rpcrdma2_write_list  *rdma_next;
/// };
///
/// /***************************************************************
///  *    Transport Properties
///  ***************************************************************/
///
/// /*
///  * Types for transport properties model
///  */
/// typedef rpcrdma2_propid uint32;
///
/// struct rpcrdma2_propval {
///         rpcrdma2_propid rdma_which;
///         opaque          rdma_data&lt;&gt;;
/// };
///
/// typedef rpcrdma2_propval rpcrdma2_propset&lt;&gt;;
/// typedef uint32 rpcrdma2_propsubset&lt;&gt;;
///
/// /*
///  * Transport propid values for basic properties
///  */
/// const RDMA2_PROPID_SBSIZ = 1;
/// const RDMA2_PROPID_RBSIZ = 2;
/// const RDMA2_PROPID_RSSIZ = 3;
/// const RDMA2_PROPID_RCSIZ = 4;
/// const RDMA2_PROPID_BRS = 5;
/// const RDMA2_PROPID_HOSTAUTH = 6;
///
/// /*
///  * Types specific to particular properties
///  */
/// typedef uint32 rpcrdma2_prop_sbsiz;
/// typedef uint32 rpcrdma2_prop_rbsiz;
/// typedef uint32 rpcrdma2_prop_rssiz;
/// typedef uint32 rpcrdma2_prop_rcsiz;
/// typedef uint32 rpcrdma2_prop_brs;
/// typedef opaque rpcrdma2_prop_hostauth&lt;&gt;;
///
/// const RDMA2_RVRSDIR_NONE = 0;
/// const RDMA2_RVRSDIR_SIMPLE = 1;
/// const RDMA2_RVRSDIR_CONT = 2;
/// const RDMA2_RVRSDIR_GENL = 3;
///
/// /* FILE ENDS: common.x; */



&lt;CODE ENDS&gt;</pre><a href="#section-8.3-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="section_84e950a5-c842-4d19-b56d-0458c3e219b2">
<section id="section-8.4">
        <h3 id="name-xdr-definition-for-rpc-over-">
<a href="#section-8.4" class="section-number selfRef">8.4. </a><a href="#name-xdr-definition-for-rpc-over-" class="section-name selfRef">XDR Definition for RPC-over-RDMA Version 2 Base Header Types</a>
        </h3>
<div id="section-8.4-1">
<pre class="lang-xdr sourcecode">&lt;CODE BEGINS&gt;

/// /***************************************************************
///  *    Descriptions of RPC-over-RDMA Header Types
///  ***************************************************************/
///
/// /*
///  * Header Type Codes: Control plane operations.
///  */
/// const RDMA2_ERROR = 4;
/// const RDMA2_GRANT = 5;
/// const RDMA2_CONNPROP_MIDDLE = 6;
/// const RDMA2_CONNPROP_FINAL = 7;
///
/// /*
///  * Header Type Codes: Call messages.
///  */
/// const RDMA2_CALL_EXTERNAL = 8;
/// const RDMA2_CALL_MIDDLE = 9;
/// const RDMA2_CALL_INLINE = 10;
///
/// /*
///  * Header Type Codes: Reply messages.
///  */
/// const RDMA2_REPLY_EXTERNAL = 11;
/// const RDMA2_REPLY_MIDDLE = 12;
/// const RDMA2_REPLY_INLINE = 13;
///
/// /*
///  * Header Type to Report Errors.
///  */
/// const RDMA2_ERR_VERS = 1;
/// const RDMA2_ERR_BAD_XDR = 2;
/// const RDMA2_ERR_BAD_PROPVAL = 3;
/// const RDMA2_ERR_INVAL_HTYPE = 4;
/// const RDMA2_ERR_INVAL_CONT = 5;
/// const RDMA2_ERR_READ_CHUNKS = 6;
/// const RDMA2_ERR_WRITE_CHUNKS = 7;
/// const RDMA2_ERR_SEGMENTS = 8;
/// const RDMA2_ERR_WRITE_RESOURCE = 9;
/// const RDMA2_ERR_REPLY_RESOURCE = 10;
/// const RDMA2_ERR_VERS_MISMATCH = 11;
/// const RDMA2_ERR_SYSTEM = 100;
///
/// struct rpcrdma2_err_vers {
///         uint32 rdma_vers_low;
///         uint32 rdma_vers_high;
/// };
///
/// struct rpcrdma2_err_write {
///         uint32 rdma_chunk_index;
///         uint32 rdma_length_needed;
/// };
///
/// union rpcrdma2_hdr_error switch (rpcrdma2_errcode rdma_err) {
///         case RDMA2_ERR_VERS:
///           rpcrdma2_err_vers rdma_vrange;
///         case RDMA2_ERR_READ_CHUNKS:
///           uint32 rdma_max_chunks;
///         case RDMA2_ERR_WRITE_CHUNKS:
///           uint32 rdma_max_chunks;
///         case RDMA2_ERR_SEGMENTS:
///           uint32 rdma_max_segments;
///         case RDMA2_ERR_WRITE_RESOURCE:
///           rpcrdma2_err_write rdma_writeres;
///         case RDMA2_ERR_REPLY_RESOURCE:
///           uint32 rdma_length_needed;
///         default:
///           void;
/// };
///
/// /*
///  * Header Type to Exchange Transport Properties.
///  */
/// struct rpcrdma2_hdr_connprop {
///         rpcrdma2_propset rdma_props;
/// };
///
/// /*
///  * Header Types to Convey RPC Messages.
///  */
/// struct rpcrdma2_hdr_call_external {
///         uint32                      rdma_inv_handle;
///
///         struct rpcrdma2_read_list   *rdma_call;
///         struct rpcrdma2_read_list   *rdma_reads;
///         struct rpcrdma2_write_list  *rdma_provisional_writes;
///         struct rpcrdma2_write_chunk *rdma_provisional_reply;
/// };
///
/// struct rpcrdma2_hdr_call_middle {
///         uint32                      rdma_remaining;
///
///         /* The rpc message starts here and continues
///          * through the end of the transmission. */
///         uint32                      rdma_rpc_first_word;
/// };
///
/// struct rpcrdma2_hdr_call_inline {
///         uint32                      rdma_inv_handle;
///
///         struct rpcrdma2_read_list   *rdma_reads;
///         struct rpcrdma2_write_list  *rdma_provisional_writes;
///         struct rpcrdma2_write_chunk *rdma_provisional_reply;
///
///         /* The rpc message starts here and continues
///          * through the end of the transmission. */
///         uint32                      rdma_rpc_first_word;
/// };
///
/// struct rpcrdma2_hdr_reply_external {
///         struct rpcrdma2_write_list  *rdma_writes;
///         struct rpcrdma2_write_chunk *rdma_reply;
/// };
///
/// struct rpcrdma2_hdr_reply_middle {
///         uint32                      rdma_remaining;
///
///         /* The rpc message starts here and continues
///          * through the end of the transmission. */
///         uint32                      rdma_rpc_first_word;
/// };
///
/// struct rpcrdma2_hdr_reply_inline {
///         struct rpcrdma2_write_list  *rdma_writes;
///
///         /* The rpc message starts here and continues
///          * through the end of the transmission. */
///         uint32                      rdma_rpc_first_word;
/// };
///
/// /* FILE ENDS: baseops.x; */



&lt;CODE ENDS&gt;</pre><a href="#section-8.4-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="section_5541f0da-efbb-4431-af9c-6f82aa773963">
<section id="section-8.5">
        <h3 id="name-use-of-the-xdr-description">
<a href="#section-8.5" class="section-number selfRef">8.5. </a><a href="#name-use-of-the-xdr-description" class="section-name selfRef">Use of the XDR Description</a>
        </h3>
<p id="section-8.5-1">
The files common.x and baseops.x,
when combined with the XDR descriptions for extension defined later,
produce a human-readable and compilable description
of the RPC-over-RDMA version 2 protocol with the included extensions.<a href="#section-8.5-1" class="pilcrow">¶</a></p>
<p id="section-8.5-2">
Although this XDR description can generate encoders and decoders
for the Transport and Payload streams,
there are elements of the operation of RPC-over-RDMA version 2
that cannot be expressed within the XDR language.
Implementations that use the output of an automated XDR processor
need to provide additional code to bridge these gaps.<a href="#section-8.5-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.5-3.1">
The Transport stream is not a single XDR object.
Instead, the header prefix is one XDR data item,
and the rest of the header is a separate XDR data item.
<a href="#table_b5c31bf9-d623-4957-97db-29fc1d416cb8" class="xref">Table 2</a>
expresses the mapping between the header type in the header prefix
and
the XDR object representing the header type.<a href="#section-8.5-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-8.5-3.2">
The relationship between
the Transport stream
and
the Payload stream
is not specified using XDR.
Comments within the XDR text
make clear where transported messages,
described by their own XDR definitions,
need to appear.
Such data is opaque to the transport.<a href="#section-8.5-3.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-8.5-3.3">
Continuation of RPC messages across transport message boundaries
requires that message assembly facilities
not specifiable within XDR are part of transport implementations.<a href="#section-8.5-3.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-8.5-3.4">
Transport properties are constant integer values.
<a href="#table_99d0e7cc-da81-4f16-9bd0-471f806bc0b6" class="xref">Table 1</a>
expresses the mapping between
each property's code point
and
the XDR typedef that represents the structure of the property's value.
XDR does not possess the facility to express that mapping in an extensible way.<a href="#section-8.5-3.4" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-8.5-4">
The role of XDR in RPC-over-RDMA specifications
is more limited than for protocols
where the totality of the protocol is expressible within XDR.
XDR lacks the facility to represent
the embedding of XDR-encoded payload material.
Also, the need to cleanly accommodate extensions
has meant that those using rpcgen in their applications
need to take an active role to provide
the facilities that cannot be expressed within XDR.<a href="#section-8.5-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_e914de0a-05f3-4e14-a067-fb49a4f9b0ad">
<section id="section-9">
      <h2 id="name-rpc-bind-parameters">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-rpc-bind-parameters" class="section-name selfRef">RPC Bind Parameters</a>
      </h2>
<p id="section-9-1">
Before establishing a new connection,
an RPC client obtains a transport address for the RPC server.
The means used to obtain this address
and to open an RDMA connection is dependent
on the type of RDMA transport
and is the responsibility of each RPC protocol binding
and its local implementation.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">
RPC services typically register with a portmap or rpcbind service
<span>[<a href="#RFC1833" class="xref">RFC1833</a>]</span>,
which associates an RPC Program number with a service address.
This policy is no different with RDMA transports.
However, a distinct service address (port number)
is sometimes required for operation on RPC-over-RDMA.<a href="#section-9-2" class="pilcrow">¶</a></p>
<p id="section-9-3">
When mapped atop MPA
<span>[<a href="#RFC5044" class="xref">RFC5044</a>]</span>,
which uses IP port addressing due to its layering on TCP or SCTP,
port mapping is trivial
and consists merely of issuing the port in the connection process.
The NFS/RDMA protocol service address
has been assigned port 20049 by IANA
for this deployment scenario
<span>[<a href="#RFC8267" class="xref">RFC8267</a>]</span>.<a href="#section-9-3" class="pilcrow">¶</a></p>
<p id="section-9-4">
When mapped atop InfiniBand
<span>[<a href="#IBA" class="xref">IBA</a>]</span>,
which uses a service endpoint naming scheme based on a Group Identifier (GID),
a translation <span class="bcp14">MUST</span> be employed.
One such translation is described in
Annexes A3 (Application Specific Identifiers),
A4 (Sockets Direct Protocol (SDP)),
and A11 (RDMA IP CM Service) of
<span>[<a href="#IBA" class="xref">IBA</a>]</span>,
which is appropriate for translating IP port addressing
to the InfiniBand network.
Therefore, in this case,
IP port addressing may be readily employed by the upper layer.<a href="#section-9-4" class="pilcrow">¶</a></p>
<p id="section-9-5">
When a mapping standard or convention exists
for IP ports on an RDMA interconnect,
there are several possibilities for each upper layer to consider:<a href="#section-9-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-6.1">
One possibility is to have the server register
its mapped IP port with the rpcbind service
under the netid (or netids) defined in
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>.
An RPC-over-RDMA-aware RPC client can then
resolve its desired service to a mappable port
and
proceed to connect.
This method is the most flexible and compatible approach
for those upper layers that are defined to use the rpcbind service.<a href="#section-9-6.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-9-6.2">
A second possibility is to have the RPC server's portmapper
register itself on the RDMA interconnect at a "well-known" service address
(on UDP or TCP, this corresponds to port 111).
An RPC client can connect to this service address
and
use the portmap protocol to obtain a service address
in response to a program number
(e.g., a TCP port number or an InfiniBand GID).<a href="#section-9-6.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-9-6.3">
Alternately, an RPC client can connect
to the mapped well-known port for the service itself,
if it is appropriately defined.
By convention, the NFS/RDMA service,
when operating atop an InfiniBand fabric,
uses the same 20049 assignment as for MPA.<a href="#section-9-6.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-9-7">
Historically, different RPC protocols have taken different approaches
to their port assignments.
The current document leaves the specific method for each RPC-over-RDMA-enabled ULB.<a href="#section-9-7" class="pilcrow">¶</a></p>
<p id="section-9-8">
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>
defines two new netid values
to be used for registration of upper layers atop MPA
and (when a suitable port translation service is available) InfiniBand.
Additional RDMA-capable networks
<span class="bcp14">MAY</span>
define their own netids, or if they provide a port translation, they
<span class="bcp14">MAY</span>
share the one defined in
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>.<a href="#section-9-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_fd2f45e7-85fa-4863-a4cd-ea200878062f">
<section id="section-10">
      <h2 id="name-implementation-status">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-implementation-status" class="section-name selfRef">Implementation Status</a>
      </h2>
<p id="section-10-1">This section is to be removed before publishing as an RFC.<a href="#section-10-1" class="pilcrow">¶</a></p>
<p id="section-10-2">
This section records the status of known implementations of the protocol
defined by this specification at the time of posting of this Internet-Draft,
and is based on a proposal described in
<span>[<a href="#RFC7942" class="xref">RFC7942</a>]</span>.
The description of implementations in this section is intended to
assist the IETF in its decision processes in progressing drafts to RFCs.<a href="#section-10-2" class="pilcrow">¶</a></p>
<p id="section-10-3">
Please note that the listing of any individual implementation here
does not imply endorsement by the IETF.
Furthermore, no effort has been spent to verify the information presented here
that was supplied by IETF contributors.
This is not intended as, and must not be construed to be,
a catalog of available implementations or their features.
Readers are advised to note that other implementations may exist.<a href="#section-10-3" class="pilcrow">¶</a></p>
<p id="section-10-4">
At this time, no known implementations of the protocol
described in the current document exist.<a href="#section-10-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_912a2c09-95ec-4cb6-aa2b-2245726d9edf">
<section id="section-11">
      <h2 id="name-security-considerations">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<div id="section_9e0f4573-2f3e-4758-9a9d-c5ae8f54d5f6">
<section id="section-11.1">
        <h3 id="name-memory-protection">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-memory-protection" class="section-name selfRef">Memory Protection</a>
        </h3>
<p id="section-11.1-1">
A primary consideration is the protection of the integrity and confidentiality
of host memory by an RPC-over-RDMA transport.
The use of an RPC-over-RDMA transport protocol <span class="bcp14">MUST NOT</span> introduce vulnerabilities
to system memory contents nor memory owned by user processes.
Any RDMA provider used for RPC transport <span class="bcp14">MUST</span> conform
to the requirements of
<span>[<a href="#RFC5042" class="xref">RFC5042</a>]</span>
to satisfy these protections.<a href="#section-11.1-1" class="pilcrow">¶</a></p>
<div id="section_2ca69bb1-1d40-4226-a375-face55cf0108">
<section id="section-11.1.1">
          <h4 id="name-protection-domains">
<a href="#section-11.1.1" class="section-number selfRef">11.1.1. </a><a href="#name-protection-domains" class="section-name selfRef">Protection Domains</a>
          </h4>
<p id="section-11.1.1-1">
The use of a Protection Domain to limit the exposure of memory regions
to a single connection is critical.
Any attempt by an endpoint not participating in that connection
to reuse memory handles needs to result in immediate failure of that connection.
Because ULP security mechanisms rely
on this aspect of Reliable Connected behavior,
implementations <span class="bcp14">SHOULD</span> cryptographically authenticate connection endpoints.<a href="#section-11.1.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_35460fd7-b8e5-4c95-901c-fbe827b61966">
<section id="section-11.1.2">
          <h4 id="name-handle-stag-predictability">
<a href="#section-11.1.2" class="section-number selfRef">11.1.2. </a><a href="#name-handle-stag-predictability" class="section-name selfRef">Handle (STag) Predictability</a>
          </h4>
<p id="section-11.1.2-1">
Implementations should use unpredictable memory handles
for any operation requiring exposed memory regions.
Exposing a continuously registered memory region
allows a remote host to read or write to that region
even when an RPC involving that memory is not underway.
Therefore, implementations should avoid
the use of persistently registered memory.<a href="#section-11.1.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_958d6c42-3fa3-4368-9ea9-2f43b8795bcb">
<section id="section-11.1.3">
          <h4 id="name-memory-protection-2">
<a href="#section-11.1.3" class="section-number selfRef">11.1.3. </a><a href="#name-memory-protection-2" class="section-name selfRef">Memory Protection</a>
          </h4>
<p id="section-11.1.3-1">
Requesters should register memory regions for remote access
only when they are about to be the target of an RPC transaction
that involves an RDMA Read or Write.<a href="#section-11.1.3-1" class="pilcrow">¶</a></p>
<p id="section-11.1.3-2">
Requesters should invalidate memory regions
as soon as related RPC operations are complete.
Invalidation and DMA unmapping of memory regions should complete
before the receiver checks message integrity,
and
before the RPC consumer can use or alter the contents of the exposed memory region.<a href="#section-11.1.3-2" class="pilcrow">¶</a></p>
<p id="section-11.1.3-3">
An RPC transaction on a Requester can terminate
before a Reply arrives, for example,
if the RPC consumer is signaled, or a segmentation fault occurs.
When an RPC terminates abnormally, memory regions associated with that RPC
should be invalidated before the Requester reuses those regions for other purposes.<a href="#section-11.1.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_71519a0b-0458-4ae8-912d-2f09a968ab09">
<section id="section-11.1.4">
          <h4 id="name-denial-of-service">
<a href="#section-11.1.4" class="section-number selfRef">11.1.4. </a><a href="#name-denial-of-service" class="section-name selfRef">Denial of Service</a>
          </h4>
<p id="section-11.1.4-1">
A detailed discussion of denial-of-service exposures
that can result from the use of an RDMA transport
appears in
<span><a href="https://rfc-editor.org/rfc/rfc5042#section-6.4" class="relref">Section 6.4</a> of [<a href="#RFC5042" class="xref">RFC5042</a>]</span>.<a href="#section-11.1.4-1" class="pilcrow">¶</a></p>
<p id="section-11.1.4-2">
A Responder is not obliged to pull unreasonably large Read chunks.
A Responder can use an RDMA2_ERROR response
to terminate RPCs with unreadable Read chunks.
If a Responder transmits more data than
a Requester is prepared to receive in a Write or Reply chunk,
the RDMA provider typically terminates the connection.
For further discussion, see
<a href="#section_b1d23e5c-31df-483f-adb7-25430b5de38d" class="xref">Section 6.3.1</a>.
Such repeated connection termination can deny service
to other users sharing the connection from the errant Requester.<a href="#section-11.1.4-2" class="pilcrow">¶</a></p>
<p id="section-11.1.4-3">
An RPC-over-RDMA transport implementation is not responsible
for throttling the RPC request rate,
other than to keep the number of concurrent RPC transactions
within the per connection credit limits (see
<a href="#section_45c67eb8-8dc6-47c3-8555-14270f1514bF" class="xref">Section 4.2.1</a>).
A sender can trigger a self-denial of service
by exceeding the credit limit repeatedly.<a href="#section-11.1.4-3" class="pilcrow">¶</a></p>
<p id="section-11.1.4-4">
When an RPC transaction terminates due to
a signal
or
premature exit of an application process,
a Requester should invalidate the RPC's Write and Reply chunks.
Invalidation prevents the subsequent arrival of the Responder's Reply
from altering the memory regions associated with those chunks
after the Requester has released that memory.<a href="#section-11.1.4-4" class="pilcrow">¶</a></p>
<p id="section-11.1.4-5">
On the Requester,
a malfunctioning application
or
a malicious user
can create a situation where RPCs initiate and abort continuously,
resulting in Responder replies that terminate
the underlying RPC-over-RDMA connection repeatedly.
Such situations can deny service to other users
sharing the connection from that Requester.<a href="#section-11.1.4-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_4b069dfd-7532-4b9b-a9c9-1f0e8ee0d2fC">
<section id="section-11.2">
        <h3 id="name-rpc-message-security">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-rpc-message-security" class="section-name selfRef">RPC Message Security</a>
        </h3>
<p id="section-11.2-1">
ONC RPC provides cryptographic security via the RPCSEC_GSS framework
<span>[<a href="#RFC7861" class="xref">RFC7861</a>]</span>.
RPCSEC_GSS implements
message authentication (rpc_gss_svc_none),
per-message integrity checking (rpc_gss_svc_integrity),
and
per-message confidentiality (rpc_gss_svc_privacy)
in a layer above the RPC-over-RDMA transport.
The integrity and privacy services require
significant computation and movement of data
on each endpoint host.
Some performance benefits enabled by RDMA transports can be lost.<a href="#section-11.2-1" class="pilcrow">¶</a></p>
<div id="section_ca56ff24-b218-455a-9faf-c8f7c17bf26c">
<section id="section-11.2.1">
          <h4 id="name-rpc-over-rdma-protection-at">
<a href="#section-11.2.1" class="section-number selfRef">11.2.1. </a><a href="#name-rpc-over-rdma-protection-at" class="section-name selfRef">RPC-over-RDMA Protection at Other Layers</a>
          </h4>
<p id="section-11.2.1-1">
For any RPC transport,
utilizing RPCSEC_GSS integrity or privacy services
has performance implications.
Protection below the RPC implementation is often
a better choice in performance-sensitive deployments,
especially if it, too, can be offloaded.
Certain implementations of IPsec can be co-located in RDMA hardware,
for example,
without change to RDMA consumers
and
with little loss of data movement efficiency.
Such arrangements can also provide a higher degree of privacy
by hiding endpoint identity
or
altering the frequency at which messages are exchanged,
at a performance cost.<a href="#section-11.2.1-1" class="pilcrow">¶</a></p>
<p id="section-11.2.1-2">
Implementations <span class="bcp14">MAY</span> negotiate the use of protection
in another layer through the use of
an RPCSEC_GSS security flavor defined in
<span>[<a href="#RFC7861" class="xref">RFC7861</a>]</span>
in conjunction with
the Channel Binding mechanism
<span>[<a href="#RFC5056" class="xref">RFC5056</a>]</span>
and
IPsec Channel Connection Latching
<span>[<a href="#RFC5660" class="xref">RFC5660</a>]</span>.<a href="#section-11.2.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_61deca2d-94c4-4fd4-be7a-59ae3a77c9a2">
<section id="section-11.2.2">
          <h4 id="name-rpcsec_gss-on-rpc-over-rdma">
<a href="#section-11.2.2" class="section-number selfRef">11.2.2. </a><a href="#name-rpcsec_gss-on-rpc-over-rdma" class="section-name selfRef">RPCSEC_GSS on RPC-over-RDMA Transports</a>
          </h4>
<p id="section-11.2.2-1">
Not all RDMA devices and fabrics support the above protection mechanisms.
Also, NFS clients, where multiple users can access NFS files,
still require per-message authentication.
In these cases, RPCSEC_GSS can protect NFS traffic conveyed on RPC-over-RDMA connections.<a href="#section-11.2.2-1" class="pilcrow">¶</a></p>
<p id="section-11.2.2-2">
RPCSEC_GSS extends the ONC RPC protocol without changing the format of RPC messages.
By observing the conventions described in this section,
an RPC-over-RDMA transport can convey RPCSEC_GSS-protected RPC messages interoperably.<a href="#section-11.2.2-2" class="pilcrow">¶</a></p>
<p id="section-11.2.2-3">
Senders <span class="bcp14">MUST NOT</span> reduce protocol elements of RPCSEC_GSS
that appear in the Payload stream of an RPC-over-RDMA message.
Such elements include control messages
exchanged as part of establishing or destroying a security context,
or data items that are part of RPCSEC_GSS authentication material.<a href="#section-11.2.2-3" class="pilcrow">¶</a></p>
<div id="section_17014ff8-d5ef-4db8-bbb5-337a07cd66e2">
<section id="section-11.2.2.1">
            <h5 id="name-rpcsec_gss-context-negotiat">
<a href="#section-11.2.2.1" class="section-number selfRef">11.2.2.1. </a><a href="#name-rpcsec_gss-context-negotiat" class="section-name selfRef">RPCSEC_GSS Context Negotiation</a>
            </h5>
<p id="section-11.2.2.1-1">
Some NFS client implementations use a separate connection
to establish a Generic Security Service (GSS) context for NFS operation.
Such clients use TCP and the standard NFS port (2049) for context establishment.
Therefore, an NFS server <span class="bcp14">MUST</span> also provide
a TCP-based NFS service on port 2049 to enable the use of RPCSEC_GSS with NFS/RDMA.<a href="#section-11.2.2.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_77AA4781-E811-4B0D-8704-F96CCD4888DF">
<section id="section-11.2.2.2">
            <h5 id="name-rpc-over-rdma-with-rpcsec_g">
<a href="#section-11.2.2.2" class="section-number selfRef">11.2.2.2. </a><a href="#name-rpc-over-rdma-with-rpcsec_g" class="section-name selfRef">RPC-over-RDMA with RPCSEC_GSS Authentication</a>
            </h5>
<p id="section-11.2.2.2-1">
The RPCSEC_GSS authentication service has no impact
on the DDP-eligibility of data items in a ULP.<a href="#section-11.2.2.2-1" class="pilcrow">¶</a></p>
<p id="section-11.2.2.2-2">
However, RPCSEC_GSS authentication material
appearing in an RPC message header can be larger than, say,
an AUTH_SYS authenticator.
In particular, when an RPCSEC_GSS pseudoflavor is in use,
a Requester needs to accommodate a larger RPC credential
when marshaling RPC Calls
and
needs to provide for a maximum size RPCSEC_GSS verifier
when allocating reply buffers and Reply chunks.<a href="#section-11.2.2.2-2" class="pilcrow">¶</a></p>
<p id="section-11.2.2.2-3">
RPC messages, and thus Payload streams,
are larger on average as a result.
ULP operations that fit in a Simple Format message
when a simpler form of authentication is in use
might need to be reduced or conveyed via a Special Format message
when RPCSEC_GSS authentication is in use.
It is therefore more likely that a Requester provisions
both a Read list and a Reply chunk
in the same RPC-over-RDMA Transport header
to convey a Special Format Call
and provision a receptacle for a Special Format Reply.<a href="#section-11.2.2.2-3" class="pilcrow">¶</a></p>
<p id="section-11.2.2.2-4">
In addition to this cost,
the XDR encoding and decoding of each RPC message
using RPCSEC_GSS authentication
requires per-message host compute resources
to construct the GSS verifier.<a href="#section-11.2.2.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_4574ad52-fe73-4679-a808-ae3612c60f24">
<section id="section-11.2.2.3">
            <h5 id="name-rpc-over-rdma-with-rpcsec_gs">
<a href="#section-11.2.2.3" class="section-number selfRef">11.2.2.3. </a><a href="#name-rpc-over-rdma-with-rpcsec_gs" class="section-name selfRef">RPC-over-RDMA with RPCSEC_GSS Integrity or Privacy</a>
            </h5>
<p id="section-11.2.2.3-1">
The RPCSEC_GSS integrity service enables endpoints
to detect the modification of RPC messages in flight.
The RPCSEC_GSS privacy service prevents
all but the intended recipient
from viewing the cleartext content of RPC arguments and results.
RPCSEC_GSS integrity and privacy services are end-to-end.
They protect RPC arguments and results from application to server endpoint, and back.<a href="#section-11.2.2.3-1" class="pilcrow">¶</a></p>
<p id="section-11.2.2.3-2">
The RPCSEC_GSS integrity and encryption services operate
on whole RPC messages after they have been XDR encoded,
and before they have been XDR decoded after receipt.
Connection endpoints use intermediate buffers
to prevent exposure of encrypted
or
unverified cleartext data to RPC consumers.
After a sender has
verified,
encrypted,
and
wrapped a message,
the transport layer <span class="bcp14">MAY</span> use RDMA data transfer
between these intermediate buffers.<a href="#section-11.2.2.3-2" class="pilcrow">¶</a></p>
<p id="section-11.2.2.3-3">
The process of reducing a DDP-eligible data item removes
the data item
and
its XDR padding
from an encoded Payload stream.
In a non-protected RPC-over-RDMA message,
a reduced data item does not include XDR padding.
After reduction, the Payload stream contains fewer octets
than the whole XDR stream did beforehand.
XDR padding octets are often zero bytes, but they don't have to be.
Thus, reducing DDP-eligible items affects
the result of message integrity verification and encryption.<a href="#section-11.2.2.3-3" class="pilcrow">¶</a></p>
<p id="section-11.2.2.3-4">
Therefore, a sender <span class="bcp14">MUST NOT</span> reduce a Payload stream
when RPCSEC_GSS integrity or encryption services are in use.
Effectively, no data item is DDP-eligible in this situation.
Senders can use only Simple and Continued Formats without data item chunks,
or Special Format.
In this mode, an RPC-over-RDMA transport operates
in the same manner as a transport that does not support DDP.<a href="#section-11.2.2.3-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_0cddd345-064a-4c96-b251-17afce70219f">
<section id="section-11.2.2.4">
            <h5 id="name-protecting-rpc-over-rdma-tr">
<a href="#section-11.2.2.4" class="section-number selfRef">11.2.2.4. </a><a href="#name-protecting-rpc-over-rdma-tr" class="section-name selfRef">Protecting RPC-over-RDMA Transport Headers</a>
            </h5>
<p id="section-11.2.2.4-1">
Like the header fields in an RPC message
(e.g., the xid and mtype fields),
RPCSEC_GSS does not protect the RPC-over-RDMA Transport stream.
XIDs, connection credit limits, and chunk lists
(though not the content of the data items they refer to)
are exposed to malicious behavior,
which can redirect data that is transferred by the RPC-over-RDMA message,
result in spurious retransmits,
or
trigger connection loss.<a href="#section-11.2.2.4-1" class="pilcrow">¶</a></p>
<p id="section-11.2.2.4-2">
In particular,
if an attacker alters the information
contained in the chunk lists of an RPC-over-RDMA Transport header,
data contained in those chunks can be redirected
to other registered memory regions on Requesters.
An attacker might alter the arguments
of RDMA Read and RDMA Write operations on the wire
to gain a similar effect.
If such alterations occur,
the use of RPCSEC_GSS integrity or privacy services
enables a Requester to detect unexpected material in a received RPC message.<a href="#section-11.2.2.4-2" class="pilcrow">¶</a></p>
<p id="section-11.2.2.4-3">
Encryption at other layers, as described in
<a href="#section_ca56ff24-b218-455a-9faf-c8f7c17bf26c" class="xref">Section 11.2.1</a>,
protects the content of the Transport stream.
RDMA transport implementations should conform to
<span>[<a href="#RFC5042" class="xref">RFC5042</a>]</span>
to address attacks on RDMA protocols themselves.<a href="#section-11.2.2.4-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="section_3b0e673b-98d7-436d-bd6f-180180503df6">
<section id="section-11.3">
        <h3 id="name-transport-properties-2">
<a href="#section-11.3" class="section-number selfRef">11.3. </a><a href="#name-transport-properties-2" class="section-name selfRef">Transport Properties</a>
        </h3>
<p id="section-11.3-1">
Like other fields that appear in the Transport stream,
transport properties are sent in the clear with no integrity protection,
making them vulnerable to man-in-the-middle attacks.<a href="#section-11.3-1" class="pilcrow">¶</a></p>
<p id="section-11.3-2">
For example, if a man-in-the-middle were to change the value
of the Receive buffer size, it could
reduce connection performance
or
trigger loss of connection.
Repeated connection loss can impact performance
or
even prevent a new connection from being established.
The recourse is to
deploy on a private network
or
use transport layer encryption.<a href="#section-11.3-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_c85be87e-4f2b-4caf-8ae5-acdaa972a9f9">
<section id="section-11.4">
        <h3 id="name-host-authentication">
<a href="#section-11.4" class="section-number selfRef">11.4. </a><a href="#name-host-authentication" class="section-name selfRef">Host Authentication</a>
        </h3>
<p id="section-11.4-1">
[ cel: This subsection is unfinished. ]<a href="#section-11.4-1" class="pilcrow">¶</a></p>
<p id="section-11.4-2">
Wherein we use the relevant sections of
<span>[<a href="#RFC3552" class="xref">RFC3552</a>]</span>
to analyze the addition of host authentication
to this RPC-over-RDMA transport.<a href="#section-11.4-2" class="pilcrow">¶</a></p>
<p id="section-11.4-3">
The authors refer readers to Appendix C of
<span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>
for information on how to design and test
a secure authentication handshake implementation.<a href="#section-11.4-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_d235c884-6463-411f-ba34-6bcc82ab7a9f">
<section id="section-12">
      <h2 id="name-iana-considerations">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-12-1">
The RPC-over-RDMA family of transports have been assigned RPC netids
by
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>.
A netid is an rpcbind
<span>[<a href="#RFC1833" class="xref">RFC1833</a>]</span>
string used to identify the underlying protocol
in order for RPC to select appropriate transport framing
and the format of the service addresses and ports.<a href="#section-12-1" class="pilcrow">¶</a></p>
<p id="section-12-2">The following netid registry strings are already defined for this purpose:<a href="#section-12-2" class="pilcrow">¶</a></p>
<div id="artwork_bfbf9434-d33a-4f66-a0bf-2fdee624155d">
<div class="alignLeft art-text artwork" id="section-12-3">
<pre>

   NC_RDMA "rdma"
   NC_RDMA6 "rdma6"

</pre><a href="#section-12-3" class="pilcrow">¶</a>
</div>
</div>
<p id="section-12-4">
The "rdma" netid is to be used when IPv4 addressing is employed by the underlying transport,
and "rdma6" when IPv6 addressing is employed.
The netid assignment policy and registry are defined in
<span>[<a href="#RFC5665" class="xref">RFC5665</a>]</span>.
The current document does not alter these netid assignments.<a href="#section-12-4" class="pilcrow">¶</a></p>
<p id="section-12-5">
These netids <span class="bcp14">MAY</span> be used for any RDMA network that satisfies the
requirements of
<a href="#section_6903045e-bd1c-4e12-bf96-6b534989f46A" class="xref">Section 3.2.2</a>
and that is able to identify service endpoints using IP port addressing,
possibly through use of a translation service as described in
<a href="#section_e914de0a-05f3-4e14-a067-fb49a4f9b0ad" class="xref">Section 9</a>.<a href="#section-12-5" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-13">
      <h2 id="name-references">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-13.1">
        <h3 id="name-normative-references">
<a href="#section-13.1" class="section-number selfRef">13.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC1833">[RFC1833]</dt>
        <dd>
<span class="refAuthor">Srinivasan, R.</span>, <span class="refTitle">"Binding Protocols for ONC RPC Version 2"</span>, <span class="seriesInfo">RFC 1833</span>, <span class="seriesInfo">DOI 10.17487/RFC1833</span>, <time datetime="1995-08" class="refDate">August 1995</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1833">https://www.rfc-editor.org/info/rfc1833</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4506">[RFC4506]</dt>
        <dd>
<span class="refAuthor">Eisler, M., Ed.</span>, <span class="refTitle">"XDR: External Data Representation Standard"</span>, <span class="seriesInfo">STD 67</span>, <span class="seriesInfo">RFC 4506</span>, <span class="seriesInfo">DOI 10.17487/RFC4506</span>, <time datetime="2006-05" class="refDate">May 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4506">https://www.rfc-editor.org/info/rfc4506</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5042">[RFC5042]</dt>
        <dd>
<span class="refAuthor">Pinkerton, J.</span> and <span class="refAuthor">E. Deleganes</span>, <span class="refTitle">"Direct Data Placement Protocol (DDP) / Remote Direct Memory Access Protocol (RDMAP) Security"</span>, <span class="seriesInfo">RFC 5042</span>, <span class="seriesInfo">DOI 10.17487/RFC5042</span>, <time datetime="2007-10" class="refDate">October 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5042">https://www.rfc-editor.org/info/rfc5042</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5056">[RFC5056]</dt>
        <dd>
<span class="refAuthor">Williams, N.</span>, <span class="refTitle">"On the Use of Channel Bindings to Secure Channels"</span>, <span class="seriesInfo">RFC 5056</span>, <span class="seriesInfo">DOI 10.17487/RFC5056</span>, <time datetime="2007-11" class="refDate">November 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5056">https://www.rfc-editor.org/info/rfc5056</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5531">[RFC5531]</dt>
        <dd>
<span class="refAuthor">Thurlow, R.</span>, <span class="refTitle">"RPC: Remote Procedure Call Protocol Specification Version 2"</span>, <span class="seriesInfo">RFC 5531</span>, <span class="seriesInfo">DOI 10.17487/RFC5531</span>, <time datetime="2009-05" class="refDate">May 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5531">https://www.rfc-editor.org/info/rfc5531</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5660">[RFC5660]</dt>
        <dd>
<span class="refAuthor">Williams, N.</span>, <span class="refTitle">"IPsec Channels: Connection Latching"</span>, <span class="seriesInfo">RFC 5660</span>, <span class="seriesInfo">DOI 10.17487/RFC5660</span>, <time datetime="2009-10" class="refDate">October 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5660">https://www.rfc-editor.org/info/rfc5660</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5665">[RFC5665]</dt>
        <dd>
<span class="refAuthor">Eisler, M.</span>, <span class="refTitle">"IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats"</span>, <span class="seriesInfo">RFC 5665</span>, <span class="seriesInfo">DOI 10.17487/RFC5665</span>, <time datetime="2010-01" class="refDate">January 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5665">https://www.rfc-editor.org/info/rfc5665</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7861">[RFC7861]</dt>
        <dd>
<span class="refAuthor">Adamson, A.</span> and <span class="refAuthor">N. Williams</span>, <span class="refTitle">"Remote Procedure Call (RPC) Security Version 3"</span>, <span class="seriesInfo">RFC 7861</span>, <span class="seriesInfo">DOI 10.17487/RFC7861</span>, <time datetime="2016-11" class="refDate">November 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7861">https://www.rfc-editor.org/info/rfc7861</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7942">[RFC7942]</dt>
        <dd>
<span class="refAuthor">Sheffer, Y.</span> and <span class="refAuthor">A. Farrel</span>, <span class="refTitle">"Improving Awareness of Running Code: The Implementation Status Section"</span>, <span class="seriesInfo">BCP 205</span>, <span class="seriesInfo">RFC 7942</span>, <span class="seriesInfo">DOI 10.17487/RFC7942</span>, <time datetime="2016-07" class="refDate">July 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7942">https://www.rfc-editor.org/info/rfc7942</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8166">[RFC8166]</dt>
        <dd>
<span class="refAuthor">Lever, C., Ed.</span>, <span class="refAuthor">Simpson, W.</span>, and <span class="refAuthor">T. Talpey</span>, <span class="refTitle">"Remote Direct Memory Access Transport for Remote Procedure Call Version 1"</span>, <span class="seriesInfo">RFC 8166</span>, <span class="seriesInfo">DOI 10.17487/RFC8166</span>, <time datetime="2017-06" class="refDate">June 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8166">https://www.rfc-editor.org/info/rfc8166</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8267">[RFC8267]</dt>
        <dd>
<span class="refAuthor">Lever, C.</span>, <span class="refTitle">"Network File System (NFS) Upper-Layer Binding to RPC-over-RDMA Version 1"</span>, <span class="seriesInfo">RFC 8267</span>, <span class="seriesInfo">DOI 10.17487/RFC8267</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8267">https://www.rfc-editor.org/info/rfc8267</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8446">[RFC8446]</dt>
      <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08" class="refDate">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-13.2">
        <h3 id="name-informative-references">
<a href="#section-13.2" class="section-number selfRef">13.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="CBFC">[CBFC]</dt>
        <dd>
<span class="refAuthor">Kung, H.T.</span>, <span class="refAuthor">Blackwell, T.</span>, and <span class="refAuthor">A. Chapman</span>, <span class="refTitle">"Credit-Based Flow Control for ATM Networks: Credit Update Protocol, Adaptive Credit Allocation, and Statistical Multiplexing"</span>, <span class="seriesInfo">Proc. ACM SIGCOMM '94 Symposium on Communications Architectures, Protocols and Applications, pp. 101-114.</span>, <time datetime="1994-08" class="refDate">August 1994</time>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-nfsv4-rpc-tls">[I-D.ietf-nfsv4-rpc-tls]</dt>
        <dd>
<span class="refAuthor">Myklebust, T.</span> and <span class="refAuthor">C. Lever</span>, <span class="refTitle">"Towards Remote Procedure Call Encryption By Default"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-nfsv4-rpc-tls-11</span>, <time datetime="2020-11-23" class="refDate">23 November 2020</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-nfsv4-rpc-tls-11">https://datatracker.ietf.org/doc/html/draft-ietf-nfsv4-rpc-tls-11</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IBA">[IBA]</dt>
        <dd>
<span class="refAuthor">InfiniBand Trade Association</span>, <span class="refTitle">"InfiniBand Architecture Specification Volume 1"</span>, <span class="seriesInfo">Release 1.3</span>, <time datetime="2015-03" class="refDate">March 2015</time>. <span class="annotation">
Available from https://www.infinibandta.org/
</span>
        </dd>
<dd class="break"></dd>
<dt id="RFC0768">[RFC0768]</dt>
        <dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"User Datagram Protocol"</span>, <span class="seriesInfo">STD 6</span>, <span class="seriesInfo">RFC 768</span>, <span class="seriesInfo">DOI 10.17487/RFC0768</span>, <time datetime="1980-08" class="refDate">August 1980</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc768">https://www.rfc-editor.org/info/rfc768</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC0793">[RFC0793]</dt>
        <dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"Transmission Control Protocol"</span>, <span class="seriesInfo">STD 7</span>, <span class="seriesInfo">RFC 793</span>, <span class="seriesInfo">DOI 10.17487/RFC0793</span>, <time datetime="1981-09" class="refDate">September 1981</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC1094">[RFC1094]</dt>
        <dd>
<span class="refAuthor">Nowicki, B.</span>, <span class="refTitle">"NFS: Network File System Protocol specification"</span>, <span class="seriesInfo">RFC 1094</span>, <span class="seriesInfo">DOI 10.17487/RFC1094</span>, <time datetime="1989-03" class="refDate">March 1989</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1094">https://www.rfc-editor.org/info/rfc1094</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC1813">[RFC1813]</dt>
        <dd>
<span class="refAuthor">Callaghan, B.</span>, <span class="refAuthor">Pawlowski, B.</span>, and <span class="refAuthor">P. Staubach</span>, <span class="refTitle">"NFS Version 3 Protocol Specification"</span>, <span class="seriesInfo">RFC 1813</span>, <span class="seriesInfo">DOI 10.17487/RFC1813</span>, <time datetime="1995-06" class="refDate">June 1995</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1813">https://www.rfc-editor.org/info/rfc1813</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3552">[RFC3552]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span> and <span class="refAuthor">B. Korver</span>, <span class="refTitle">"Guidelines for Writing RFC Text on Security Considerations"</span>, <span class="seriesInfo">BCP 72</span>, <span class="seriesInfo">RFC 3552</span>, <span class="seriesInfo">DOI 10.17487/RFC3552</span>, <time datetime="2003-07" class="refDate">July 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3552">https://www.rfc-editor.org/info/rfc3552</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5040">[RFC5040]</dt>
        <dd>
<span class="refAuthor">Recio, R.</span>, <span class="refAuthor">Metzler, B.</span>, <span class="refAuthor">Culley, P.</span>, <span class="refAuthor">Hilland, J.</span>, and <span class="refAuthor">D. Garcia</span>, <span class="refTitle">"A Remote Direct Memory Access Protocol Specification"</span>, <span class="seriesInfo">RFC 5040</span>, <span class="seriesInfo">DOI 10.17487/RFC5040</span>, <time datetime="2007-10" class="refDate">October 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5040">https://www.rfc-editor.org/info/rfc5040</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5041">[RFC5041]</dt>
        <dd>
<span class="refAuthor">Shah, H.</span>, <span class="refAuthor">Pinkerton, J.</span>, <span class="refAuthor">Recio, R.</span>, and <span class="refAuthor">P. Culley</span>, <span class="refTitle">"Direct Data Placement over Reliable Transports"</span>, <span class="seriesInfo">RFC 5041</span>, <span class="seriesInfo">DOI 10.17487/RFC5041</span>, <time datetime="2007-10" class="refDate">October 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5041">https://www.rfc-editor.org/info/rfc5041</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5044">[RFC5044]</dt>
        <dd>
<span class="refAuthor">Culley, P.</span>, <span class="refAuthor">Elzur, U.</span>, <span class="refAuthor">Recio, R.</span>, <span class="refAuthor">Bailey, S.</span>, and <span class="refAuthor">J. Carrier</span>, <span class="refTitle">"Marker PDU Aligned Framing for TCP Specification"</span>, <span class="seriesInfo">RFC 5044</span>, <span class="seriesInfo">DOI 10.17487/RFC5044</span>, <time datetime="2007-10" class="refDate">October 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5044">https://www.rfc-editor.org/info/rfc5044</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5532">[RFC5532]</dt>
        <dd>
<span class="refAuthor">Talpey, T.</span> and <span class="refAuthor">C. Juszczak</span>, <span class="refTitle">"Network File System (NFS) Remote Direct Memory Access (RDMA) Problem Statement"</span>, <span class="seriesInfo">RFC 5532</span>, <span class="seriesInfo">DOI 10.17487/RFC5532</span>, <time datetime="2009-05" class="refDate">May 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5532">https://www.rfc-editor.org/info/rfc5532</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5662">[RFC5662]</dt>
        <dd>
<span class="refAuthor">Shepler, S., Ed.</span>, <span class="refAuthor">Eisler, M., Ed.</span>, and <span class="refAuthor">D. Noveck, Ed.</span>, <span class="refTitle">"Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description"</span>, <span class="seriesInfo">RFC 5662</span>, <span class="seriesInfo">DOI 10.17487/RFC5662</span>, <time datetime="2010-01" class="refDate">January 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5662">https://www.rfc-editor.org/info/rfc5662</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5666">[RFC5666]</dt>
        <dd>
<span class="refAuthor">Talpey, T.</span> and <span class="refAuthor">B. Callaghan</span>, <span class="refTitle">"Remote Direct Memory Access Transport for Remote Procedure Call"</span>, <span class="seriesInfo">RFC 5666</span>, <span class="seriesInfo">DOI 10.17487/RFC5666</span>, <time datetime="2010-01" class="refDate">January 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5666">https://www.rfc-editor.org/info/rfc5666</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7530">[RFC7530]</dt>
        <dd>
<span class="refAuthor">Haynes, T., Ed.</span> and <span class="refAuthor">D. Noveck, Ed.</span>, <span class="refTitle">"Network File System (NFS) Version 4 Protocol"</span>, <span class="seriesInfo">RFC 7530</span>, <span class="seriesInfo">DOI 10.17487/RFC7530</span>, <time datetime="2015-03" class="refDate">March 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7530">https://www.rfc-editor.org/info/rfc7530</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7862">[RFC7862]</dt>
        <dd>
<span class="refAuthor">Haynes, T.</span>, <span class="refTitle">"Network File System (NFS) Version 4 Minor Version 2 Protocol"</span>, <span class="seriesInfo">RFC 7862</span>, <span class="seriesInfo">DOI 10.17487/RFC7862</span>, <time datetime="2016-11" class="refDate">November 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7862">https://www.rfc-editor.org/info/rfc7862</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8167">[RFC8167]</dt>
        <dd>
<span class="refAuthor">Lever, C.</span>, <span class="refTitle">"Bidirectional Remote Procedure Call on RPC-over-RDMA Transports"</span>, <span class="seriesInfo">RFC 8167</span>, <span class="seriesInfo">DOI 10.17487/RFC8167</span>, <time datetime="2017-06" class="refDate">June 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8167">https://www.rfc-editor.org/info/rfc8167</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8881">[RFC8881]</dt>
      <dd>
<span class="refAuthor">Noveck, D., Ed.</span> and <span class="refAuthor">C. Lever</span>, <span class="refTitle">"Network File System (NFS) Version 4 Minor Version 1 Protocol"</span>, <span class="seriesInfo">RFC 8881</span>, <span class="seriesInfo">DOI 10.17487/RFC8881</span>, <time datetime="2020-08" class="refDate">August 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8881">https://www.rfc-editor.org/info/rfc8881</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="section_9e003b83-66b5-43d7-b9ef-0f271c8d301b">
<section id="appendix-A">
      <h2 id="name-ulb-specifications">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-ulb-specifications" class="section-name selfRef">ULB Specifications</a>
      </h2>
<p id="appendix-A-1">
Typically, an Upper-Layer Protocol (ULP) is defined
without regard to a particular RPC transport.
An Upper-Layer Binding (ULB) specification
provides guidance that helps a ULP interoperate
correctly and efficiently over a particular transport.
For RPC-over-RDMA version 2, a ULB may provide:<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A-2.1">
A taxonomy of XDR data items that are eligible for DDP<a href="#appendix-A-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-2.2">
Constraints on which upper-layer procedures
a sender may reduce,
and
on how many chunks may appear in a single RPC message<a href="#appendix-A-2.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-2.3">
A method enabling a Requester to determine
the maximum size of the reply Payload
stream for all procedures in the ULP<a href="#appendix-A-2.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-2.4">
An rpcbind port assignment for the RPC Program and Version
when operating on the particular transport<a href="#appendix-A-2.4" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-A-3">
Each RPC Program and Version tuple that operates
on RPC-over-RDMA version 2 needs to have a ULB specification.<a href="#appendix-A-3" class="pilcrow">¶</a></p>
<div id="section_2f2b32a4-d78a-45f0-b6a3-fa0e2d34a97b">
<section id="appendix-A.1">
        <h3 id="name-ddp-eligibility">
<a href="#appendix-A.1" class="section-number selfRef">A.1. </a><a href="#name-ddp-eligibility" class="section-name selfRef">DDP-Eligibility</a>
        </h3>
<p id="appendix-A.1-1">
A ULB designates specific XDR data items as eligible for DDP.
As a sender constructs an RPC-over-RDMA message,
it can remove DDP-eligible data items from the Payload stream
so that the RDMA provider can place them
directly in the receiver's memory.
An XDR data item should be considered for DDP-eligibility
if there is a clear benefit to moving the contents
of the item directly from the sender's memory
to the receiver's memory.<a href="#appendix-A.1-1" class="pilcrow">¶</a></p>
<p id="appendix-A.1-2">
Criteria for DDP-eligibility include:<a href="#appendix-A.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1-3.1">
The XDR data item is frequently sent or received, and its size is
often much larger than typical inline thresholds.<a href="#appendix-A.1-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.1-3.2">
If the XDR data item is a result, its maximum size must be
predictable in advance by the Requester.<a href="#appendix-A.1-3.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.1-3.3">
Transport-level processing of the XDR data item is not needed.
For example, the data item is an opaque byte array, which requires
no XDR encoding and decoding of its content.<a href="#appendix-A.1-3.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.1-3.4">
The content of the XDR data item is sensitive to address alignment.
For example, a data copy operation would be required
on the receiver to enable the message to be parsed correctly,
or
to enable the data item to be accessed.<a href="#appendix-A.1-3.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.1-3.5">
The XDR data item itself does not contain DDP-eligible data items.<a href="#appendix-A.1-3.5" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-A.1-4">
In addition to defining the set of data items that are DDP-eligible,
a ULB may limit the use of chunks
to particular upper-layer procedures.
If more than one data item in a procedure is DDP-eligible,
the ULB may limit the number of chunks
that a Requester can provide for a particular upper-layer procedure.<a href="#appendix-A.1-4" class="pilcrow">¶</a></p>
<p id="appendix-A.1-5">
Senders never reduce data items that are not DDP-eligible.
Such data items can, however, be part of a Special Format payload.<a href="#appendix-A.1-5" class="pilcrow">¶</a></p>
<p id="appendix-A.1-6">
The programming interface by which an upper-layer implementation
indicates the DDP-eligibility of a data item to the RPC transport
is not described by this specification.
The only requirements are
that the receiver can re-assemble
the transmitted RPC-over-RDMA message into a valid XDR stream
and
that DDP-eligibility rules specified by the ULB are respected.<a href="#appendix-A.1-6" class="pilcrow">¶</a></p>
<p id="appendix-A.1-7">
There is no provision to express DDP-eligibility within the XDR
language.
The only definitive specification of DDP-eligibility is a ULB.<a href="#appendix-A.1-7" class="pilcrow">¶</a></p>
<p id="appendix-A.1-8">
In general, a DDP-eligibility violation occurs when:<a href="#appendix-A.1-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1-9.1">
A Requester reduces a non-DDP-eligible argument data item.
The Responder reports the violation as described in
<a href="#section_b1d23e5c-31df-483f-adb7-25430b5de38d" class="xref">Section 6.3.1</a>.<a href="#appendix-A.1-9.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.1-9.2">
A Responder reduces a non-DDP-eligible result data item.
The Requester terminates the pending RPC transaction
and reports an appropriate permanent error to the RPC consumer.<a href="#appendix-A.1-9.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.1-9.3">
A Responder does not reduce a DDP-eligible result data item into
an available Write chunk.
The Requester terminates the pending RPC transaction
and reports an appropriate permanent error to the RPC consumer.<a href="#appendix-A.1-9.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="section_a3f15fe3-2677-4d94-adb5-afa80c7e197a">
<section id="appendix-A.2">
        <h3 id="name-maximum-reply-size">
<a href="#appendix-A.2" class="section-number selfRef">A.2. </a><a href="#name-maximum-reply-size" class="section-name selfRef">Maximum Reply Size</a>
        </h3>
<p id="appendix-A.2-1">
When expecting small and moderately-sized Replies,
a Requester should rely on Message Continuation
rather than provision a Reply chunk.
For each ULP procedure where there is no clear Reply size maximum
and the maximum can be substantial,
the ULB should specify a dependable means
for determining the maximum Reply size.<a href="#appendix-A.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_a5e8ada2-5473-4321-beee-41c29e04227f">
<section id="appendix-A.3">
        <h3 id="name-reverse-direction-operation-2">
<a href="#appendix-A.3" class="section-number selfRef">A.3. </a><a href="#name-reverse-direction-operation-2" class="section-name selfRef">Reverse-Direction Operation</a>
        </h3>
<p id="appendix-A.3-1">
The direction of operation does not preclude
the need for DDP-eligibility statements.<a href="#appendix-A.3-1" class="pilcrow">¶</a></p>
<p id="appendix-A.3-2">
Reverse-direction operation occurs
on an already-established connection.
Specification of RPC binding parameters is
usually not necessary in this case.<a href="#appendix-A.3-2" class="pilcrow">¶</a></p>
<p id="appendix-A.3-3">
Other considerations may apply
when distinct RPC Programs
share an RPC-over-RDMA transport connection concurrently.<a href="#appendix-A.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_e568723e-3dd8-4a54-9401-92ae4f98f88f">
<section id="appendix-A.4">
        <h3 id="name-additional-considerations">
<a href="#appendix-A.4" class="section-number selfRef">A.4. </a><a href="#name-additional-considerations" class="section-name selfRef">Additional Considerations</a>
        </h3>
<p id="appendix-A.4-1">
There may be other details provided in a ULB.<a href="#appendix-A.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.4-2.1">
A ULB may recommend
inline threshold values
or
other transport-related parameters
for RPC-over-RDMA version 2 connections bearing that ULP.<a href="#appendix-A.4-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.4-2.2">
A ULP may provide a means to communicate transport-related parameters
between peers.<a href="#appendix-A.4-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-A.4-2.3">
Multiple ULPs may share
a single RPC-over-RDMA version 2 connection when
their ULBs allow the use of RPC-over-RDMA version 2
and
the rpcbind port assignments for those protocols permit connection sharing.
In this case, the same transport parameters (such as inline threshold)
apply to all ULPs using that connection.<a href="#appendix-A.4-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-A.4-3">
Each ULB needs to be designed to allow correct interoperation
without regard to the transport parameters actually in use.
Furthermore, implementations of ULPs must be designed
to interoperate correctly
regardless of the connection parameters in effect on a connection.<a href="#appendix-A.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_db58c83f-091c-481e-ba7c-a0246d1c475b">
<section id="appendix-A.5">
        <h3 id="name-ulp-extensions">
<a href="#appendix-A.5" class="section-number selfRef">A.5. </a><a href="#name-ulp-extensions" class="section-name selfRef">ULP Extensions</a>
        </h3>
<p id="appendix-A.5-1">
An RPC Program and Version tuple may be extensible.
For instance,
the RPC version number may not reflect a ULP minor versioning scheme,
or
the ULP may allow the specification of additional features
after the publication of the original RPC Program specification.
ULBs are provided for interoperable RPC Programs and Versions by
extending existing ULBs to reflect the changes made necessary by each
addition to the existing XDR.<a href="#appendix-A.5-1" class="pilcrow">¶</a></p>
<p id="appendix-A.5-2">
[ cel:
The final sentence is unclear, and may be inaccurate.
I believe I copied this section directly from RFC 8166.
Is there more to be said, now that we have some experience? ]<a href="#appendix-A.5-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_84e1ffc4-d916-4eb4-9fd8-a8218d084503">
<section id="appendix-B">
      <h2 id="name-extending-rpc-over-rdma-ver">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-extending-rpc-over-rdma-ver" class="section-name selfRef">Extending RPC-over-RDMA Version 2</a>
      </h2>
<p id="appendix-B-1">
This Appendix is not addressed to protocol implementers,
but rather to authors of documents that
extend the protocol specified in the current document.<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<p id="appendix-B-2">
RPC-over-RDMA version 2 extensibility facilitates
limited extensions to the base protocol
presented in the current document
so that new optional capabilities can be introduced
without a protocol version change
while maintaining robust interoperability
with existing RPC-over-RDMA version 2 implementations.
It allows extensions to be defined,
including the definition of new protocol elements,
without requiring modification or recompilation
of the XDR for the base protocol.<a href="#appendix-B-2" class="pilcrow">¶</a></p>
<p id="appendix-B-3">
Standards Track documents may introduce extensions
to the base RPC-over-RDMA version 2 protocol in two ways:<a href="#appendix-B-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B-4.1">
They may introduce new <span class="bcp14">OPTIONAL</span> transport header types.
<a href="#section_d4650151-40f0-4e85-8755-02c38cf8f444" class="xref">Appendix B.2</a>
covers such transport header types.<a href="#appendix-B-4.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-B-4.2">
They may define new <span class="bcp14">OPTIONAL</span> transport properties.
<a href="#section_a355adad-f03b-41a6-94a8-4128b10301bb" class="xref">Appendix B.3</a>
describes such transport properties.<a href="#appendix-B-4.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-B-5">
These documents may also add the following sorts
of ancillary protocol elements to the protocol
to support the addition of
new transport properties and header types:<a href="#appendix-B-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B-6.1">
They may create new error codes, as described in
<a href="#section_c2f5e937-d612-4e3a-a380-e0b15261f6a0" class="xref">Appendix B.4</a>.<a href="#appendix-B-6.1" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-B-7">
New capabilities can be
proposed
and
developed
independently of each other.
Implementers can choose among them,
making it straightforward
to create
and
document
experimental features
and then bring them through the standards process.<a href="#appendix-B-7" class="pilcrow">¶</a></p>
<div id="section_1c2304a3-0dc6-4ca1-b710-77a7b07f3d19">
<section id="appendix-B.1">
        <h3 id="name-documentation-requirements">
<a href="#appendix-B.1" class="section-number selfRef">B.1. </a><a href="#name-documentation-requirements" class="section-name selfRef">Documentation Requirements</a>
        </h3>
<p id="appendix-B.1-1">
As described earlier,
a Standards Track document introduces a set of new protocol elements.
Together these elements are considered an <span class="bcp14">OPTIONAL</span> feature.
Each implementation is either
aware of all the protocol elements introduced by that feature
or
is aware of none of them.<a href="#appendix-B.1-1" class="pilcrow">¶</a></p>
<p id="appendix-B.1-2">
Documents specifying extensions to RPC-over-RDMA version 2 should contain:<a href="#appendix-B.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.1-3.1">
An explanation of the purpose and use of each new protocol element.<a href="#appendix-B.1-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.1-3.2">
An XDR description including all of the new protocol elements,
and a script to extract it.<a href="#appendix-B.1-3.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.1-3.3">
A discussion of interactions with other extensions.
This discussion includes
requirements for other <span class="bcp14">OPTIONAL</span> features to be present,
or
that a particular level of support for an <span class="bcp14">OPTIONAL</span> facility is required.<a href="#appendix-B.1-3.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.1-4">
Implementers combine the XDR descriptions
of the new features they intend to use
with
the XDR description of the base protocol in the current document.
This combination is necessary to create a valid XDR input file
because extensions are
free to use XDR types defined in the base protocol,
and
later extensions may use types defined by earlier extensions.<a href="#appendix-B.1-4" class="pilcrow">¶</a></p>
<p id="appendix-B.1-5">
The XDR description for the RPC-over-RDMA version 2 base protocol
combined with that for any selected extensions
should provide a human-readable and compilable definition
of the extended protocol.<a href="#appendix-B.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_d4650151-40f0-4e85-8755-02c38cf8f444">
<section id="appendix-B.2">
        <h3 id="name-adding-new-header-types-to-">
<a href="#appendix-B.2" class="section-number selfRef">B.2. </a><a href="#name-adding-new-header-types-to-" class="section-name selfRef">Adding New Header Types to RPC-over-RDMA Version 2</a>
        </h3>
<p id="appendix-B.2-1">
New transport header types are defined similar to Sections
<a href="#section_7e1de71a-9b68-4bd0-8213-97991139ab87" class="xref">6.3.5</a>
through
<a href="#section_67bf730f-38f1-40bc-8eec-1bedde7b0449" class="xref">6.3.10</a>.
In particular, what is needed is:<a href="#appendix-B.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.2-2.1">
A description of the function and use of the new header type.<a href="#appendix-B.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.2">
A complete XDR description of the new header type.<a href="#appendix-B.2-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.3">
A description of how receivers report errors,
including mechanisms for reporting errors
outside the available choices already available
in the base protocol or other extensions.<a href="#appendix-B.2-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.4">
An indication of whether a Payload stream must be present,
and a description of its contents
and
how receivers use such Payload streams to reconstruct RPC messages.<a href="#appendix-B.2-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.5">
As appropriate, a statement of
whether a Responder may use Remote Invalidation
when sending messages that contain the new header type.<a href="#appendix-B.2-2.5" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.2-3">
There needs to be additional documentation that is made necessary
due to the <span class="bcp14">OPTIONAL</span> status of new transport header types:<a href="#appendix-B.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.2-4.1">
The document should discuss constraints on support for the new header types.
For example, if support for one header type is implied or foreclosed
by another one, this needs to be documented.<a href="#appendix-B.2-4.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-4.2">
The document should describe the preferred method
by which a sender determines whether its peer
supports a particular header type.
It is always possible to send a test invocation
of a particular header type to see if support is available.
However, when more efficient means are available
(e.g., the value of a transport property),
this should be noted.<a href="#appendix-B.2-4.2" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="section_a355adad-f03b-41a6-94a8-4128b10301bb">
<section id="appendix-B.3">
        <h3 id="name-adding-new-transport-proper">
<a href="#appendix-B.3" class="section-number selfRef">B.3. </a><a href="#name-adding-new-transport-proper" class="section-name selfRef">Adding New Transport properties to the Protocol</a>
        </h3>
<p id="appendix-B.3-1">
A Standards Track document defining a new transport property
should include the following information
paralleling that provided in this document
for the transport properties defined herein:<a href="#appendix-B.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.3-2.1">
The rpcrdma2_propid value identifying the new property.<a href="#appendix-B.3-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.3-2.2">
The XDR typedef specifying the structure of its property value.<a href="#appendix-B.3-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.3-2.3">
A description of the new property.<a href="#appendix-B.3-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.3-2.4">
An explanation of how the receiver can use this information.<a href="#appendix-B.3-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.3-2.5">
The default value if a peer never receives the new property.<a href="#appendix-B.3-2.5" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.3-3">
There is no requirement that propid assignments
occur in a continuous range of values.
Implementations should not rely on all such values being small integers.<a href="#appendix-B.3-3" class="pilcrow">¶</a></p>
<p id="appendix-B.3-4">
Before the defining Standards Track document is published,
the nfsv4 Working Group should select a unique propid value, and ensure that:<a href="#appendix-B.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.3-5.1">
rpcrdma2_propid values specified in the document do not conflict with
those currently assigned
or
in use by other pending working group documents defining transport properties.<a href="#appendix-B.3-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.3-5.2">
            <p id="appendix-B.3-5.2.1">
rpcrdma2_propid values specified in the document do not conflict with
the range reserved for experimental use,
as defined in Section 8.2.<a href="#appendix-B.3-5.2.1" class="pilcrow">¶</a></p>
<p id="appendix-B.3-5.2.2">
[ cel:
 There is no longer a section 8.2 or an experimental range of propid values.
 Should we request the creation of an IANA registry for propid values? ].<a href="#appendix-B.3-5.2.2" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="appendix-B.3-6">
When a Standards Track document proposes additional transport properties,
reviewers should deal with possible security issues
exposed by those new transport properties.<a href="#appendix-B.3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_c2f5e937-d612-4e3a-a380-e0b15261f6a0">
<section id="appendix-B.4">
        <h3 id="name-adding-new-error-codes-to-t">
<a href="#appendix-B.4" class="section-number selfRef">B.4. </a><a href="#name-adding-new-error-codes-to-t" class="section-name selfRef">Adding New Error Codes to the Protocol</a>
        </h3>
<p id="appendix-B.4-1">
The same Standards Track document that defines a new header type
may introduce new error codes used to support it.
A Standards Track document may similarly define
new error codes that an existing header type can return.<a href="#appendix-B.4-1" class="pilcrow">¶</a></p>
<p id="appendix-B.4-2">
For error codes that do not require
the return of additional information,
a peer can use the existing RDMA_ERR2 header type to report the new error.
The sender sets the new error code
as the value of rdma_err with the result
that the default switch arm of the rpcrdma2_error (i.e., void) is selected.<a href="#appendix-B.4-2" class="pilcrow">¶</a></p>
<p id="appendix-B.4-3">
For error codes that do require
the return of related information together with the error,
a new header type should be defined that returns the error
together with the related information.
The sender of a new header type needs to be prepared
to accept header types necessary to report associated errors.<a href="#appendix-B.4-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="section_c2574344-5aec-427d-a5ed-048d7fcc0d95">
<section id="appendix-C">
      <h2 id="name-differences-from-rpc-over-r">
<a href="#appendix-C" class="section-number selfRef">Appendix C. </a><a href="#name-differences-from-rpc-over-r" class="section-name selfRef">Differences from RPC-over-RDMA Version 1</a>
      </h2>
<p id="appendix-C-1">
The primary goal of RPC-over-RDMA version 2 is
to relieve constraints that have
become evident in RPC-over-RDMA version 1
with deployment experience:<a href="#appendix-C-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C-2.1">
RPC-over-RDMA version 1 has been challenging to update
to address shortcomings or improve data transfer efficiency.<a href="#appendix-C-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-C-2.2">
The average size of NFSv4 COMPOUNDs is significantly greater than
NFSv3 requests, requiring the use of Long messages for frequent operations.<a href="#appendix-C-2.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-C-2.3">
Reply size estimation is difficult more often than first expected.<a href="#appendix-C-2.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-C-3">
This section details specific changes in RPC-over-RDMA version 2
that address these constraints directly,
in addition to other changes to make implementation easier.<a href="#appendix-C-3" class="pilcrow">¶</a></p>
<div id="section_d945b9f0-0666-4db7-9126-be57cf7b5f4f">
<section id="appendix-C.1">
        <h3 id="name-changes-to-the-xdr-definiti">
<a href="#appendix-C.1" class="section-number selfRef">C.1. </a><a href="#name-changes-to-the-xdr-definiti" class="section-name selfRef">Changes to the XDR Definition</a>
        </h3>
<p id="appendix-C.1-1">
Several XDR structural changes enable
within-version protocol extensibility.<a href="#appendix-C.1-1" class="pilcrow">¶</a></p>
<p id="appendix-C.1-2">
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>
defines the RPC-over-RDMA version 1 transport header
as a single XDR object,
with an RPC message potentially following it.
In RPC-over-RDMA version 2,
there are separate XDR definitions of the transport header prefix (see
<a href="#section_2d1735f0-c465-43c6-9c18-3da6b7979862" class="xref">Section 6.4</a>),
which specifies the transport header type to be used,
and the transport header itself
(defined within one of the subsections of
<a href="#section_8039c7b8-9068-401e-9cbd-5c1e67d403e7" class="xref">Section 6.3</a>).
This construction is similar to an RPC message,
which consists of an RPC header (defined in
<span>[<a href="#RFC5531" class="xref">RFC5531</a>]</span>)
followed by a message defined by an Upper-Layer Protocol.<a href="#appendix-C.1-2" class="pilcrow">¶</a></p>
<p id="appendix-C.1-3">
As a new version of the RPC-over-RDMA transport protocol,
RPC-over-RDMA version 2 exists within the versioning rules defined in
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>.
In particular, it maintains the first four words of the protocol header,
as specified in
<span><a href="https://rfc-editor.org/rfc/rfc8166#section-4.2" class="relref">Section 4.2</a> of [<a href="#RFC8166" class="xref">RFC8166</a>]</span>,
even though, as explained in
<a href="#section_e21d4f74-b536-47f2-9d07-c03a27a20de4" class="xref">Section 6.2.1</a>
of the current document,
the XDR definition of those words is structured differently.<a href="#appendix-C.1-3" class="pilcrow">¶</a></p>
<p id="appendix-C.1-4">
Although each of the first four fields retains its semantic function,
there are differences in interpretation:<a href="#appendix-C.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.1-5.1">
The first word of the header, the rdma_xid field,
retains the format and function that it had in RPC-over-RDMA version 1.
Because RPC-over-RDMA version 2 messages can convey non-RPC messages,
a receiver should not use the contents of this field
without consideration of the protocol version and header type.<a href="#appendix-C.1-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.1-5.2">
The second word of the header, the rdma_vers field,
retains the format and function that it had in RPC-over-RDMA version 1.
To clearly distinguish version 1 and version 2 messages,
senders need to fill in the correct version
(fixed after version negotiation).
Receivers should check that the content of the rdma_vers is correct
before using the content of any other header field.<a href="#appendix-C.1-5.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.1-5.3">
The third word of the header, the rdma_credit field,
retains the size and general purpose that it had in RPC-over-RDMA version 1.
However, RPC-over-RDMA version 2 divides this field
into two 16-bit subfields. See
<a href="#section_45c67eb8-8dc6-47c3-8555-14270f1514bF" class="xref">Section 4.2.1</a>
for further details.<a href="#appendix-C.1-5.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.1-5.4">
The fourth word of the header,
previously the union discriminator field rdma_proc,
retains its format and general function
even though the set of valid values has changed.
Within RPC-over-RDMA version 2,
this word is the rdma_htype field of the structure rdma_start.
The value of this field is now an unsigned 32-bit integer
rather than an enum type, to facilitate header type extension.<a href="#appendix-C.1-5.4" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-C.1-6">
Beyond conforming to the restrictions specified in
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>,
RPC-over-RDMA version 2 attempts to limit
the scope of the changes made to ensure interoperability.
Although it introduces the Call chunk
and splits the two version 1 workhorse procedure types
RDMA_MSG and RDMA_NOMSG into several variants,
RPC-over-RDMA version 2 otherwise
expresses chunks in the same format and utilizes them the same way.<a href="#appendix-C.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_630314a8-1cf5-40f7-a5ad-5bc12c719233">
<section id="appendix-C.2">
        <h3 id="name-transport-properties-3">
<a href="#appendix-C.2" class="section-number selfRef">C.2. </a><a href="#name-transport-properties-3" class="section-name selfRef">Transport Properties</a>
        </h3>
<p id="appendix-C.2-1">
RPC-over-RDMA version 2 provides a mechanism
for exchanging an implementation's operational properties.
The purpose of this exchange is to help endpoints
improve the efficiency of data transfer
by exploiting the characteristics of both peers
rather than falling back on
the lowest common denominator default settings.
A full discussion of transport properties appears in
<a href="#section_86248e99-ca60-478a-8aff-3fb387410077" class="xref">Section 5</a>.<a href="#appendix-C.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_5a2e5ff8-0f0b-454d-b9b3-c6773cd77780">
<section id="appendix-C.3">
        <h3 id="name-credit-management-changes">
<a href="#appendix-C.3" class="section-number selfRef">C.3. </a><a href="#name-credit-management-changes" class="section-name selfRef">Credit Management Changes</a>
        </h3>
<p id="appendix-C.3-1">
RPC-over-RDMA transports employ credit-based flow control
to ensure that a Requester does not emit more RDMA Sends
than the Responder is prepared to receive.<a href="#appendix-C.3-1" class="pilcrow">¶</a></p>
<p id="appendix-C.3-2">
<span><a href="https://rfc-editor.org/rfc/rfc8166#section-3.3.1" class="relref">Section 3.3.1</a> of [<a href="#RFC8166" class="xref">RFC8166</a>]</span>
explains the operation of RPC-over-RDMA version 1 credit management
in detail.
In that design, each RDMA Send from a Requester
contains an RPC Call with a credit request,
and each RDMA Send from a Responder contains an RPC Reply
with a credit grant.
The credit grant implies that enough Receives
have been posted on the Responder to handle the credit grant
minus the number of pending RPC transactions
(the number of remaining Receive buffers might be zero).<a href="#appendix-C.3-2" class="pilcrow">¶</a></p>
<p id="appendix-C.3-3">
Each RPC Reply acts as an implicit ACK
for a previous RPC Call from the Requester.
Without an RPC Reply message,
the Requester has no way to know that
the Responder is ready for subsequent RPC Calls.<a href="#appendix-C.3-3" class="pilcrow">¶</a></p>
<p id="appendix-C.3-4">
Because version 1 embeds credit management in each message,
there is a strict one-to-one ratio between RDMA Send and RPC message.
There are interesting use cases that might be enabled
if this relationship were more flexible:<a href="#appendix-C.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.3-5.1">
RPC-over-RDMA operations that do not carry an RPC message,
e.g., control plane operations.<a href="#appendix-C.3-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.3-5.2">
A single RDMA Send that conveys more than one RPC message,
e.g., for interrupt mitigation.<a href="#appendix-C.3-5.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.3-5.3">
An RPC message that requires several sequential RDMA Sends,
e.g., to reduce the use of explicit RDMA operations for moderate-sized RPC messages.<a href="#appendix-C.3-5.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.3-5.4">
An RPC transaction that requires multiple exchanges
or
an odd number of RPC-over-RDMA operations to complete.<a href="#appendix-C.3-5.4" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-C.3-6">
RPC-over-RDMA version 2 provides
a more sophisticated credit accounting mechanism
to address these shortcomings.
<a href="#section_45c67eb8-8dc6-47c3-8555-14270f1514bF" class="xref">Section 4.2.1</a>
explains the new mechanism in detail.<a href="#appendix-C.3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_f7fb5108-58ea-4718-84be-5119a302f5f5">
<section id="appendix-C.4">
        <h3 id="name-inline-threshold-changes">
<a href="#appendix-C.4" class="section-number selfRef">C.4. </a><a href="#name-inline-threshold-changes" class="section-name selfRef">Inline Threshold Changes</a>
        </h3>
<p id="appendix-C.4-1">
An "inline threshold" value is the largest message size (in octets)
that can be conveyed on an RDMA connection
using only RDMA Send and Receive.
Each connection has two inline threshold values:
one for messages flowing from client-to-server
(referred to as the "client-to-server inline threshold")
and one for messages flowing from server-to-client
(referred to as the "server-to-client inline threshold").<a href="#appendix-C.4-1" class="pilcrow">¶</a></p>
<p id="appendix-C.4-2">
A connection's inline thresholds determine,
among other things,
when RDMA Read or Write operations are required
because an RPC message cannot be conveyed via a single RDMA Send and Receive pair.
When an RPC message does not contain DDP-eligible data items,
a Requester can prepare a Special Format Call or Reply
to convey the whole RPC message using RDMA Read or Write operations.<a href="#appendix-C.4-2" class="pilcrow">¶</a></p>
<p id="appendix-C.4-3">
RDMA Read and Write operations require that data payloads
reside in memory registered with the local RNIC.
When an RPC completes,
that memory is invalidated to fence it from the Responder.
Memory registration and invalidation typically have a latency cost
that is insignificant compared to data handling costs.<a href="#appendix-C.4-3" class="pilcrow">¶</a></p>
<p id="appendix-C.4-4">
When a data payload is small, however,
the cost of registering and invalidating
memory where the payload resides
becomes a significant part of total RPC latency.
Therefore the most efficient operation of an RPC-over-RDMA transport
occurs when the peers use explicit RDMA Read and Write operations
for large payloads but avoid those operations for small payloads.<a href="#appendix-C.4-4" class="pilcrow">¶</a></p>
<p id="appendix-C.4-5">
When the authors of
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>
first conceived RPC-over-RDMA version 1,
the average size of RPC messages
that did not involve a significant data payload
was under 500 bytes.
A 1024-byte inline threshold adequately minimized
the frequency of inefficient Long messages.<a href="#appendix-C.4-5" class="pilcrow">¶</a></p>
<p id="appendix-C.4-6">
With NFS version 4
<span>[<a href="#RFC7530" class="xref">RFC7530</a>]</span>,
the increased size of NFS COMPOUND operations
resulted in RPC messages that are, on average,
larger than previous versions of NFS.
With a 1024-byte inline threshold,
frequent operations such as GETATTR and LOOKUP
require RDMA Read or Write operations,
reducing the efficiency of data transport.<a href="#appendix-C.4-6" class="pilcrow">¶</a></p>
<p id="appendix-C.4-7">
To reduce the frequency of Special Format messages,
RPC-over-RDMA version 2 increases the default size of inline thresholds.
This change also increases the maximum size
of reverse-direction RPC messages.<a href="#appendix-C.4-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_1f3a1439-702f-4309-8733-5fa0e20555f4">
<section id="appendix-C.5">
        <h3 id="name-message-continuation-change">
<a href="#appendix-C.5" class="section-number selfRef">C.5. </a><a href="#name-message-continuation-change" class="section-name selfRef">Message Continuation Changes</a>
        </h3>
<p id="appendix-C.5-1">
In addition to a larger default inline threshold,
RPC-over-RDMA version 2 introduces Message Continuation.
Message Continuation is a mechanism
that enables the transmission of a data payload
using more than one RDMA Send.
The purpose of Message Continuation is
to provide relief in several essential cases:<a href="#appendix-C.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.5-2.1">
If a Requester finds that it is inefficient
to convey a moderately-sized data payload using Read chunks,
the Requester can use Message Continuation to send the RPC Call.<a href="#appendix-C.5-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.5-2.2">
If a Requester has provided insufficient Reply chunk space
for a Responder to send an RPC Reply,
the Responder can use Message Continuation to send the RPC Reply.<a href="#appendix-C.5-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.5-2.3">
If a sender has to convey a sizeable non-RPC data payload
(e.g., a large transport property),
the sender can use Message Continuation to avoid having to register memory.<a href="#appendix-C.5-2.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="section_16f03208-32cb-451d-90ab-a6f5f4b9e9b0">
<section id="appendix-C.6">
        <h3 id="name-host-authentication-changes">
<a href="#appendix-C.6" class="section-number selfRef">C.6. </a><a href="#name-host-authentication-changes" class="section-name selfRef">Host Authentication Changes</a>
        </h3>
<p id="appendix-C.6-1">
For the general operation of NFS on open networks,
we eventually intend to rely on RPC-on-TLS
<span>[<a href="#I-D.ietf-nfsv4-rpc-tls" class="xref">I-D.ietf-nfsv4-rpc-tls</a>]</span>
to provide cryptographic authentication of the two ends of each connection.
In turn, this can improve the trustworthiness of AUTH_SYS-style user identities
that flow on TCP, which are not cryptographically protected.
We do not have a similar solution for RPC-over-RDMA, however.<a href="#appendix-C.6-1" class="pilcrow">¶</a></p>
<p id="appendix-C.6-2">
Here, the RDMA transport layer already provides
a strong guarantee of message integrity.
On some network fabrics, IPsec or TLS
can protect the privacy of in-transit data.
However, this is not the case for all fabrics
(e.g., InfiniBand
<span>[<a href="#IBA" class="xref">IBA</a>]</span>).<a href="#appendix-C.6-2" class="pilcrow">¶</a></p>
<p id="appendix-C.6-3">
Thus, RPC-over-RDMA version 2 introduces a mechanism
for authenticating connection peers (see
<a href="#section_5f63e1b6-8d24-453b-b18b-b98ad66f3671" class="xref">Section 5.2.6</a>).
And like GSS channel binding,
there is also a way to determine when the use of host authentication is unnecessary.<a href="#appendix-C.6-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_57c034d6-7129-4f7b-b8df-31e8bc691964">
<section id="appendix-C.7">
        <h3 id="name-support-for-remote-invalida">
<a href="#appendix-C.7" class="section-number selfRef">C.7. </a><a href="#name-support-for-remote-invalida" class="section-name selfRef">Support for Remote Invalidation</a>
        </h3>
<p id="appendix-C.7-1">
When an RDMA consumer uses FRWR or Memory Windows to register memory,
that memory may be invalidated remotely [RFC5040].
These mechanisms are available when
a Requester's RNIC supports MEM_MGT_EXTENSIONS.<a href="#appendix-C.7-1" class="pilcrow">¶</a></p>
<p id="appendix-C.7-2">
For this discussion, there are two classes of STags.
Dynamically-registered STags appear in a single RPC,
then are invalidated.
Persistently-registered STags survive longer than one RPC.
They may persist for the life of an RPC-over-RDMA connection
or even longer.<a href="#appendix-C.7-2" class="pilcrow">¶</a></p>
<p id="appendix-C.7-3">
An RPC-over-RDMA Requester can provide
more than one STag in a transport header.
It may provide
a combination of dynamically- and persistently-registered STags in one RPC message,
or
any combination of these in a series of RPCs on the same connection.
Only dynamically-registered STags using Memory Windows or FRWR
may be invalidated remotely.<a href="#appendix-C.7-3" class="pilcrow">¶</a></p>
<p id="appendix-C.7-4">
There is no transport-level mechanism
by which a Responder can determine
how a Requester-provided STag was registered,
nor whether it is eligible to be invalidated remotely.
A Requester that mixes persistently- and dynamically-registered STags in one RPC,
or mixes them across RPCs on the same connection,
must, therefore, indicate which STag the Responder may invalidate remotely
via a mechanism provided in the Upper-Layer Protocol.
RPC-over-RDMA version 2 provides such a mechanism.<a href="#appendix-C.7-4" class="pilcrow">¶</a></p>
<p id="appendix-C.7-5">
A sender uses the RDMA Send With Invalidate operation
to invalidate an STag on the remote peer.
It is available only when both peers support MEM_MGT_EXTENSIONS
(can send and process an IETH).<a href="#appendix-C.7-5" class="pilcrow">¶</a></p>
<p id="appendix-C.7-6">
Existing RPC-over-RDMA transport protocol specifications
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>
          <span>[<a href="#RFC8167" class="xref">RFC8167</a>]</span>
do not forbid direct data placement in the reverse direction.
Moreover, there is currently no Upper-Layer Protocol
that makes data items in reverse-direction operations
eligible for direct data placement.<a href="#appendix-C.7-6" class="pilcrow">¶</a></p>
<p id="appendix-C.7-7">
When chunks are present in a reverse-direction RPC request,
Remote Invalidation enables the Responder
to trigger invalidation of a Requester's STags
as part of sending an RPC Reply,
the same way as is done in the forward direction.<a href="#appendix-C.7-7" class="pilcrow">¶</a></p>
<p id="appendix-C.7-8">
However, in the reverse direction, the server acts as the Requester,
and the client is the Responder.
The server's RNIC, therefore, must support receiving an IETH,
and the server must have registered its STags
with an appropriate registration mechanism.<a href="#appendix-C.7-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_e936ff03-84d1-489c-9c5f-5541adbabc94">
<section id="appendix-C.8">
        <h3 id="name-integration-of-reverse-dire">
<a href="#appendix-C.8" class="section-number selfRef">C.8. </a><a href="#name-integration-of-reverse-dire" class="section-name selfRef">Integration of Reverse-Direction Operation</a>
        </h3>
<p id="appendix-C.8-1">
Because
<span>[<a href="#RFC5666" class="xref">RFC5666</a>]</span>
did not include specification of reverse-direction operation,
<span>[<a href="#RFC8166" class="xref">RFC8166</a>]</span>
does not include it either.
Reverse-direction operation in RPC-over-RDMA version 1 is
specified by a separate standards track document
<span>[<a href="#RFC8167" class="xref">RFC8167</a>]</span>.<a href="#appendix-C.8-1" class="pilcrow">¶</a></p>
<p id="appendix-C.8-2">
Reverse-direction operation in RPC-over-RDMA version 1
was constrained by the limited ability to extend
that version of the protocol.
The most awkward issue is that
a receiver needs to peek at ingress RPC message payloads
to determine whether it is a Call or Reply message.
This is necessary because the meaning of several fields
in the RPC-over-RDMA transport header
is determined by the direction of the RPC message payload:<a href="#appendix-C.8-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.8-3.1">
The meaning of the value in the rdma_xid field
is determined by the direction of the message because
the XID spaces in the forward and reverse directions are distinct.<a href="#appendix-C.8-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.8-3.2">
The meaning of the value in the rdma_credit field
is determined by the direction of the message because
credits are granted separately
for forward and reverse direction operation.<a href="#appendix-C.8-3.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.8-3.3">
The purpose of Write chunks and the meaning of their length fields
is determined by the direction of the message because
in Call messages, they are provisional,
but in Reply messages, they represent returned results.<a href="#appendix-C.8-3.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-C.8-4">
The current document remedies this awkwardness by
integrating reverse-direction operation
into RPC-over-RDMA version 2 so that it can
make use of all facilities that are available in the forward-direction,
including body chunks, remote invalidation, and message continuation.
To enable this integration,
the direction of the RPC message payload is encoded
in each RPC-over-RDMA version 2 transport header.<a href="#appendix-C.8-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="section_e554df42-6e82-4e28-96a0-8f9872eb476c">
<section id="appendix-C.9">
        <h3 id="name-error-reporting-changes">
<a href="#appendix-C.9" class="section-number selfRef">C.9. </a><a href="#name-error-reporting-changes" class="section-name selfRef">Error Reporting Changes</a>
        </h3>
<p id="appendix-C.9-1">
RPC-over-RDMA version 2 expands the repertoire of errors
that connection peers may report to each other.
The goals of this expansion are:<a href="#appendix-C.9-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.9-2.1">
To fill in details of peer recovery actions.<a href="#appendix-C.9-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.9-2.2">
To enable retrying certain conditions
caused by mis-estimation of the maximum reply size.<a href="#appendix-C.9-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.9-2.3">
To minimize the likelihood of a Requester waiting forever for a Reply
when there are communications problems that prevent the Responder
from sending it.<a href="#appendix-C.9-2.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="section_9180da71-3ea9-40f8-b6d2-ded634e4ce25">
<section id="appendix-C.10">
        <h3 id="name-changes-in-terminology">
<a href="#appendix-C.10" class="section-number selfRef">C.10. </a><a href="#name-changes-in-terminology" class="section-name selfRef">Changes in Terminology</a>
        </h3>
<p id="appendix-C.10-1">
The RPC-over-RDMA version 2 specification makes
the following changes in terminology.
These changes do not result in
changes in the behavior or operation of the protocol.<a href="#appendix-C.10-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.10-2.1">
The current document explicitly acknowledges the different semantics
and purpose of Write chunks appearing in Call messages
and those appearing in Reply messages.<a href="#appendix-C.10-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.10-2.2">
The current document introduces the term "payload format"
to describe the selection of a mechanism for reducing
and conveying an RPC message payload.
It replaces the terms "short message" and "long message"
with the terms "simple format" and "special format"
because this selection is not based only on
the size of the payload.<a href="#appendix-C.10-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.10-2.3">
The current document introduces the terms
"data item chunk"
and
"body chunk"
in order to distinguish the purpose and operation
of these two categories of chunk.<a href="#appendix-C.10-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.10-2.4">
For improved readability,
the current document replaces the terms
"RDMA segment"
and
"plain segment"
with the term "segment",
and the term
"RDMA read segment"
with the term "Read segment".<a href="#appendix-C.10-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-C.10-2.5">
The current document refers specifically to
the RDMAP, DDP, and MPA standards track protocols
rather than using the nebulous term "iWARP".<a href="#appendix-C.10-2.5" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="section_7b212a81-9c2a-4c05-891a-369cc7184585">
<section id="appendix-D">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-D-1">
The authors gratefully acknowledge the work of
<span class="contact-name">Brent Callaghan</span>
and
<span class="contact-name">Tom Talpey</span>
on the original RPC-over-RDMA version 1 specification
<span>[<a href="#RFC5666" class="xref">RFC5666</a>]</span>.<a href="#appendix-D-1" class="pilcrow">¶</a></p>
<p id="appendix-D-2">
We are deeply indebted to
<span class="contact-name">Jana Igeyar</span>
for contributing the RPC-over-RDMA version 2
flow control mechanism described in
<a href="#section_45c67eb8-8dc6-47c3-8555-14270f1514bF" class="xref">Section 4.2.1</a>.<a href="#appendix-D-2" class="pilcrow">¶</a></p>
<p id="appendix-D-3">
The authors also wish to thank
<span class="contact-name">Bill Baker</span>,
<span class="contact-name">Greg Marsden</span>,
and
<span class="contact-name">Matt Benjamin</span>
for their support of this work.<a href="#appendix-D-3" class="pilcrow">¶</a></p>
<p id="appendix-D-4">
The XDR extraction conventions were
first described by the authors of the NFS version 4.1
XDR specification
<span>[<a href="#RFC5662" class="xref">RFC5662</a>]</span>.
<span class="contact-name">Herbert van den Bergh</span>
suggested the replacement sed script used in this document.<a href="#appendix-D-4" class="pilcrow">¶</a></p>
<p id="appendix-D-5">
Special thanks go to
Transport Area Director
<span class="contact-name">Magnus Westerlund</span>,
NFSV4 Working Group Chairs
<span class="contact-name">Spencer Shepler</span>,
and
<span class="contact-name">Brian Pawlowski</span>,
and
NFSV4 Working Group Secretary
<span class="contact-name">Thomas Haynes</span>
for their support.<a href="#appendix-D-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-E">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Charles Lever (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Oracle Corporation</span></div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:chuck.lever@oracle.com" class="email">chuck.lever@oracle.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">David Noveck</span></div>
<div dir="auto" class="left"><span class="org">NetApp</span></div>
<div dir="auto" class="left"><span class="street-address">1601 Trapelo Road</span></div>
<div dir="auto" class="left">
<span class="locality">Waltham</span>, <span class="region">MA</span> <span class="postal-code">02451</span>
</div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="tel">
<span>Phone:</span>
<a href="tel:+1%20781%20572%208038" class="tel">+1 781 572 8038</a>
</div>
<div class="email">
<span>Email:</span>
<a href="mailto:davenoveck@gmail.com" class="email">davenoveck@gmail.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
