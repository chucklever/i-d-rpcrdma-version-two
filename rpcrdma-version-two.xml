<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [ ]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" ipr="pre5378Trust200902" docName="DOCNAMEVAR">

<front>

<title abbrev="RDMA Transport for RPC V2">
RPC-over-RDMA Version 2 Protocol
</title>

<author initials="C.L." surname="Lever" fullname="Charles Lever" role="editor">
<organization abbrev="Oracle">Oracle Corporation</organization>
<address>
<postal>
<street>1015 Granger Avenue</street>
<city>Ann Arbor</city>
<region>MI</region>
<code>48104</code>
<country>United States of America</country>
</postal>
<phone>+1 248 816 6463</phone>
<email>chuck.lever@oracle.com</email>
</address>
</author>

<author initials="D.N." surname="Noveck" fullname="David Noveck">
<organization>NetApp</organization>
<address>
<postal>
<street>1601 Trapelo Road</street>
<city>Waltham</city>   
<region>MA</region>
<code>02451</code>
<country>United States of America</country>
</postal>
<phone>+1 781 572 8038</phone>
<email>davenoveck@gmail.com</email>
</address>
</author> 

<date />

<area>Transport</area>
<workgroup>Network File System Version 4</workgroup>
<keyword>NFS-Over-RDMA</keyword>

<abstract>
<t>
This document specifies a new version of the transport protocol
that conveys Remote Procedure Call (RPC) messages
on physical transports capable of Remote Direct Memory Access (RDMA).
</t>
</abstract>

</front>

<middle>

<section
 title="Introduction"
 anchor="section:CA463591-5371-4E31-81BC-48A2B50602DB">
<t>
Remote Direct Memory Access (RDMA)
<xref target="RFC5040"/> <xref target="RFC5041"/>
<xref target="IBARCH"/> is a
technique for moving data efficiently between end nodes.
By directing data into destination buffers as it is sent
on a network and placing it via direct memory access by
hardware, the complementary benefits of
faster transfers and reduced host overhead are obtained.
</t>
<t>
RPC-over-RDMA version 1 enables ONC RPC <xref target="RFC5531"/>
messages to be conveyed on RDMA transports.
That protocol is specified in <xref target="RFC8166"/>.
RPC-over-RDMA version 1 is deployed and in use,
although there are known shortcomings to this protocol:
<list style="symbols">
<t>
The protocol's default size of Receive buffers forces
the use of RDMA Read and Write transfers for small payloads,
and limits the size of reverse direction messages.
</t>
<t>
It is difficult to make optimizations or protocol fixes
that require changes to on-the-wire behavior.
</t>
</list>
</t>
<t>
To address these issues in a way that is
compatible with existing RPC-over-RDMA version 1
deployments, a new version of the RPC-over-RDMA transport protocol
is presented in this document.
</t>
<t>
This new version of RPC-over-RDMA is extensible,
enabling OPTIONAL extensions to be added
without impacting existing implementations.
In addition, RPC-over-RDMA version 2 contains
a set of incremental changes that relieve certain
performance constraints and enable recovery from
certain abnormal corner cases.
These changes include:
<list style="symbols">
<t>
The exchange of transport properties as described in
<xref target="section:331BC463-9118-46D6-9593-B9567A7529CA"/>.
</t>
<t>
A more flexible credit account mechanism, detailed in
Section TBD.
</t>
<t>
Larger default inline thresholds as described in
<xref target="section:F7FB5108-58EA-4718-84BE-5119A302F5F5"/>.
</t>
<t>
Support for remote invalidation as explained in
<xref target="section:57C034D6-7129-4F7B-B8DF-31E8BC691964"/>.
</t>
<t>
Support for reverse direction operation, as described in
<xref target="RFC8167"/>, is now REQUIRED.
Details are in
<xref target="section:F5CB1EE2-292B-48D3-8DDB-7F13A1FF41AF"/>.
</t>
<t>
An expansion of error reporting capabilities as described in
<xref target="section:9708EE05-F5EE-417E-86FA-09C276BE56FA"/>.
</t>
</list>
</t>
<t>
Because of the way in which RPC-over-RDMA version 2
builds upon the facilities present in RPC-over-RDMA version 1,
a knowledge of the basic structure of RPC-over-RDMA version 1,
as described in <xref target="RFC8166"/>, is assumed in this document.
</t>
<t>
As in that document, the terms
"RPC Payload Stream" and "Transport Header Stream"
(defined in Section 3.2 of that document)
are used to distinguish between
an RPC message as defined by <xref target="RFC5531"/>
and the header whose job it is to describe the RPC message
and its associated memory resources.
In that regard, the reader is assumed to understand
how RDMA is used to transfer chunks between client and server,
the use of Position-Zero Read chunks and Reply chunks
to convey long RPC messages, and the role of DDP-eligibility
in constraining how data payloads are to be conveyed.
</t>
<t>
In addition to the above changes which modify the over-the-wire protocol,
there is a structural change in the way the protocol is defined
that needs to be noted.
The RPC-over-RDMA version 1 transport header is defined
as a single XDR object,
with an RPC message proper potentially following it.
In RPC-over-RDMA version 2, as described in
<xref target="section:A45DB8BA-51AB-41FA-AE67-1B9C1A132945"/>
there are separate XDR definitions of the transport header prefix
(see <xref target="section:F5CB1EE2-292B-48D3-8DDB-7F13A1FF41AF"/>
which specifies the transport header type to be used,
and the specific transport header, defined within one of the subsections of
<xref target="section:9A92CD43-57D9-43BC-9E5C-430BDD3A055B"/>).
This is similar to the way that an RPC message consists of
an RPC header (defined in <xref target="RFC5531"/>) and
an RPC request or reply,
defined by the Upper Layer protocol being conveyed.
</t>

</section>

<section
 title="Requirements Language"
 anchor="section:C3708E2A-20C5-4D5E-9A59-C4EEF979D3A3">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
when, and only when, they appear in all capitals, as shown here.
</t>
</section>

<section
 title="Extensibility Framework"
 anchor="section:F1AA7C9D-888E-43C8-A61C-77A49B4F3FB7">
<t>
RPC-over-RDMA version 2 is designed to be extensible
in a way that enables the addition of OPTIONAL features
that may subsequently be converted to REQUIRED status
in a future protocol version.
</t>
<t>
A major new feature in RPC-over-RDMA version 2 is extensibility of
the RPC-over-RDMA transport header by means of creating new OPTIONAL
transport header types and new transport properties.
This form of extensibility enables limited extensions
to the base RPC-over-RDMA version 2 protocol presented
in this document so that new optional capabilities
can be introduced without a protocol version change
and while maintaining interoperability
with existing RPC-over-RDMA version 2 implementations.
</t>
<t>
New capabilities can be proposed and developed
independently of each other,
and implementers can choose among them.
This makes it straightforward to create and document experimental features
and then bring them through the standards process.
</t>

<section
 title="Relation to RPC-over-RDMA Version 1"
 anchor="section:4D6B6AE6-D915-43BF-ACB9-428B5A9FACA3">
<t>
As a new version of the RPC-over-RDMA transport protocol,
RPC-over-RDMA version 2 exists within the versioning
rules defined in <xref target="RFC8166"/>.
In particular, it maintains the first four words of the protocol header
as sent and received,
as specified in Section 4.2 of <xref target="RFC8166"/>,
even though, as explained in
<xref target="section:9CC49501-81BA-4313-A391-57C1836D76B7"/>
of this document,
the XDR definition of those words is structured differently.
</t>
<t>
Although each of the first four words retains its semantic function,
there are important differences of field interpretation:
<list style="symbols">
<t>
The rdma_xid field retains the format and function that in had in
RPC-over-RDMA version 1.
However, in order to accommodate the use of request-response
pairing of non-RPC messages and the potential use of message
continuation, it cannot be assumed that it will always have the
same value it would have had in version 1.
As a result, the contents of this field should not be used
without consideration of the associated protocol version identification.
</t>
<t>
The rdma_vers field retains the format and function
that it had in RPC-over-RDMA version 1.
To clearly distinguish version 1 and version 2 messages,
senders MUST fill in the correct version (fixed after version negotiation)
and receivers MUST check that the content of the rdma_vers is correct
before using referencing any other header field.
</t>
<t>
The rdma_credit field retains the format and general purpose
that it had in RPC-over-RDMA version 1.
The RPC-over-RDMA version 2 protocol provides additional mechanisms
that determine whether the value contained in this field
is a credit grant or response.
Also, the way in which credits are accounted for may be different
in RPC-over-RDMA version 2.
</t>
<t>
The rdma_proc field retains its format and function even though
the set of valid values has changed, and the value is now
considered an unsigned 32-bit integer rather than an enum.
</t>
</list>
</t>
<t>
Beyond conforming to the restrictions specified in
<xref target="RFC8166"/>,
RPC-over-RDMA version 2 tightly limits the scope
of the changes made in order to facilitate interoperability.
It makes no major structural changes to the protocol,
and all existing transport header types used in version 1
are retained in version 2.
Chunks are expressed using the same on-the-wire format and
are used in the same way in both versions.
</t>
</section>

<section
 title="Extensibility Within RPC-over-RDMA Version 2"
 anchor="section:E6FE7D47-3567-404D-89A7-9553AB7D8C9E">
<t>
The base protocol specified in this document may be extended within
RPC-over-RDMA version 2 in two ways:
<list style="symbols">
<t>
New OPTIONAL transport header types may be introduced by later
Standards Track documents.
</t>
<t>
New OPTIONAL transport properties may be defined in later
Standards Track documents.
</t>
</list>
</t>
<t>
A Standards Track document introduces each set of such protocol elements.
Together these elements are considered an OPTIONAL feature.
Each implementation is either aware of all the protocol
elements introduced by that feature, or is aware of none of them.
</t>
<t>
Documents describing extensions to RPC-over-RDMA version 2 should
contain:
<list style="symbols">
<t>
An explanation of the purpose and use of each new protocol element added
</t>
<t>
An XDR description of the protocol elements, and a script to extract it
</t>
<t>
A mechanism for reporting errors when the error is outside the
available choices already available in the base protocol or in
other extensions
</t>
<t>
An indication of whether a Payload stream must be present,
and a description of its contents
</t>
<t>
A description of interactions with existing extensions
</t>
</list>
The last bullet enables the requirement of other OPTIONAL features
to be present for new protocol elements to work,
or that a particular level of support
for an OPTIONAL facility is required for the new extension to work.
</t>
<t>
Implementers combine the XDR descriptions of the new features they
intend to use with the XDR description of the base protocol in this
document.
This may be necessary to create a valid XDR input file
because extensions are free to use XDR types defined in the base
protocol, and later extensions may use types defined by earlier
extensions.
</t>
<t>
The XDR description for the RPC-over-RDMA version 2 base protocol
combined with that for any selected extensions
should provide an adequate human-readable description
of the extended protocol.
</t>
</section>

<section
 title="Extensibility Beyond RPC-over-RDMA Version 2"
 anchor="section:E965E6CE-1B64-4579-A8AB-B960807F15C4">
<t>
Subsequent RPC-over-RDMA versions are free to change the protocol
in any way they choose as long as they maintain the first four header words
as currently specified by <xref target="RFC8166"/>.
</t>
<t>
Such changes might involve deletion or major re-organization of
existing transport headers.
However, the need for interoperability between adjacent versions
will often limit the scope of changes that can be made in a single version.
</t>
<t>
In some cases it may prove desirable to transition to a new version
by using the extension features described for use with RPC-over-RDMA version 2,
by continuing the same basic extension model but allowing header types
and properties that were OPTIONAL in one version to become REQUIRED
in the subsequent version.
</t>
</section>

</section>

<section
 title="Changes Within the Base RPC-over-RDMA Version 2 Protocol"
 anchor="section:C14B87E5-F2F1-441E-920A-ECEE3A77B9EC">

<section
 title="Transport Properties"
 anchor="section:331BC463-9118-46D6-9593-B9567A7529CA">
<t>
RPC-over-RDMA version 2 provides a mechanism for
exchanging the transport's operational properties.
This mechanism allows connection endpoints to communicate the properties
of their implementation at connection setup.
The mechanism could be expanded allow endpoints to request changes
in properties of the other endpoint and to notify peer endpoints of
changes to properties that occur during operation.
Transport properties are described in Sections
<xref target="section:D8CD3EE6-E4FF-43FC-9611-B075E5A70634"
 format="counter" pageno="false"/>
through
<xref target="section:9AE32E93-0B53-406B-835D-9A677A8793B3"
 format="counter" pageno="false"/>.
</t>
</section>

<section
 title="Credit Management Changes"
 anchor="section:5A2E5FF8-0F0B-454D-B9B3-C6773CD77780">
<t>
RPC-over-RDMA transports employ credit-based flow control
to ensure that a requester does not emit more RDMA Sends
than the responder is prepared to receive.
Section 3.3.1 of <xref target="RFC8166"/> explains
the purpose and operation
of RPC-over-RDMA version 1 credit management in detail.
</t>
<t>
In the RPC-over-RDMA version 1 design,
each RDMA Send from a requester contains an RPC Call with a credit request,
and each RDMA Send from a responder contains an RPC Reply with a credit grant.
The credit grant implies that enough Receives have been posted on
the responder to handle the credit grant minus the number of pending
RPC transactions (the number of remaining Receive buffers might be zero).
</t>
<t>
In other words, each RPC Reply acts as an implicit ACK
for a previous RPC Call from the requester,
indicating that the responder has posted a Receive to replace
the Receive consumed by the requester's RDMA Send.
Without an RPC Reply message, the requester has no way to know
that the responder is properly prepared for subsequent RPC Calls.
</t>
<t>
Aside from being a bit of a layering violation,
there are basic (but rare) cases where this arrangement is inadequate:
<list style="symbols">
<t>
When a requester retransmits an RPC Call on the same connection
as an earlier RPC Call for the same transaction.
</t>
<t>
When a requester transmits an RPC operation that requires no reply.
</t>
<t>
When more than one RPC-over-RDMA message is needed to complete the
transaction (e.g., RDMA_DONE).
</t>
</list>
Typically, the connection must be replaced in these cases.
This resets the credit accounting mechanism but has an undesirable impact
on other ongoing RPC transactions on that connection.
</t>
<t>
Because credit management accompanies each RPC message,
there is a strict one-to-one ratio between RDMA Send and RPC message.
There are interesting use cases that might be enabled if this relationship
were more flexible:
<list style="symbols">
<t>
RPC-over-RDMA operations which do not carry an RPC message;
e.g., control plane operations.
</t>
<t>
A single RDMA Send that conveys more than one RPC message
for the purpose of interrupt mitigation.
</t>
<t>
An RPC message that is conveyed via several sequential RDMA Sends
to reduce the use of explicit RDMA operations for moderate-sized RPC messages.
</t>
<t>
An RPC transaction that needs multiple exchanges
or an odd number of RPC-over-RDMA operations
to complete.
</t>
</list>
Bi-directional RPC operation also introduces an ambiguity.
If the RPC-over-RDMA message does not carry an RPC message, then
it is not possible to determine whether the sender is a requester
or a responder, and thus whether the rdma_credit field contains
a credit request or a credit grant.
</t>
<t>
A more sophisticated credit accounting mechanism is provided in
RPC-over-RDMA version 2 in an attempt to address some of these shortcomings.
This new mechanism is detailed in Section TBD.
</t>
</section>

<section
 title="Inline Threshold Changes"
 anchor="section:F7FB5108-58EA-4718-84BE-5119A302F5F5">
<t>
The term "inline threshold" is defined in Section 3.3.2 of
<xref target="RFC8166"/>.
An "inline threshold" value is the largest message size (in octets)
that can be conveyed in one direction on an RDMA connection
using only RDMA Send and Receive.
Each connection has two inline threshold values: one for messages
flowing from requester-to-responder (referred to as the
"call inline threshold"),
and one for messages flowing from responder-to-requester
(referred to as the "reply inline threshold").
</t>
<t>
A connection's inline threshold determines when RDMA Read or
Write operations are required because the RPC message to be
sent cannot be conveyed via a single RDMA Send and Receive pair.
When an RPC message does not contain DDP-eligible data items,
a requester prepares a Long Call or Reply to convey the whole
RPC message using RDMA Read or Write operations.
</t>
<t>
RDMA Read and Write operations require that each data payload
resides in a region of memory that is registered with the RNIC.
When an RPC is complete, that region is invalidated, fencing it
from the responder.
Memory registration and invalidation have a latency cost which is
insignificant compared to data handling costs.
When a data payload is small, however, the cost of registering and
invalidating the memory where the payload resides becomes
a relatively significant part of total RPC latency.
Therefore the most efficient operation of RPC-over-RDMA occurs
when RDMA Read and Write operations are used for large payloads,
and are avoided for small payloads.
</t>
<t>
When RPC-over-RDMA version 1 was conceived, the typical size
of RPC messages that did not involve a significant data payload
was under 500 bytes.
A 1024-byte inline threshold adequately minimized the frequency
of inefficient Long Calls and Replies.
</t>
<t>
With NFS version 4.1 <xref target="RFC5661"/>,
NFS COMPOUND messages became larger and more complex than previously.
With a 1024-byte inline threshold, RDMA Read or Write operations
are needed for frequent operations that do not bear a data payload,
such as GETATTR and LOOKUP, reducing the efficiency of the
transport.
</t>
<t>
To reduce the need to use Long Calls and Replies, RPC-over-RDMA
version 2 increases the default inline threshold size.
This also increases the maximum size of reverse direction
RPC messages.
</t>
</section>

<section
 title="Support for Remote Invalidation"
 anchor="section:57C034D6-7129-4F7B-B8DF-31E8BC691964">
<t>
An STag that is registered using
the FRWR mechanism in a privileged execution context
or is registered via a Memory Window in user space
may be invalidated remotely <xref target="RFC5040" />.
These mechanisms are available when a requester's
RNIC supports MEM_MGT_EXTENSIONS.
</t>
<t>
For the purposes of this discussion, there are two classes of STags.
Dynamically-registered STags are used in a single RPC, then invalidated.
Persistently-registered STags live longer than one RPC.
They may persist for the life of an RPC-over-RDMA connection, or longer.
</t>
<t>
An RPC-over-RDMA requester may provide more than one STag
in one transport header.
It may provide a combination of dynamically- and
persistently-registered STags in one RPC message, or
any combination of these in a series of RPCs on the same connection.
Only dynamically-registered STags using Memory Windows
or FRWR (i.e., registered via MEM_MGT_EXTENSIONS) may be invalidated remotely.
</t>
<t>
There is no transport-level mechanism by which a responder can determine
how a requester-provided STag was registered, nor whether it is
eligible to be invalidated remotely.
A requester that mixes persistently- and dynamically-registered STags in one RPC,
or mixes them across RPCs on the same connection,
must therefore indicate which handles may be invalidated via a mechanism
provided in the Upper Layer Protocol.
RPC-over-RDMA version 2 provides such a mechanism.
</t>
<t>
The RDMA Send With Invalidate operation is used to invalidate an
STag on a remote system.
It is available only when a responder's RNIC supports MEM_MGT_EXTENSIONS,
and must be utilized only when a requester's RNIC supports MEM_MGT_EXTENSIONS
(can receive and recognize an IETH).
</t>

<section
 title="Reverse Direction Remote Invalidation"
 anchor="section:750A8D5E-1D5A-4FD7-AFA3-E156561D20E5">
<t>
Existing RPC-over-RDMA transport protocol specifications
<xref target="RFC8166" />
<xref target="RFC8167" />
do not forbid
direct data placement in the reverse direction,
even though there is currently no Upper Layer Protocol that
makes data items in reverse direction operations elegible
for direct data placement.
</t>
<t>
When chunks are present in a reverse direction RPC request,
Remote Invalidation allows the responder
to trigger invalidation of a requester's STags as part of sending a reply,
the same way as is done in the forward direction.
</t>
<t>
However, in the reverse direction,
the server acts as the requester,
and the client is the responder.
The server's RNIC, therefore, must support receiving an IETH,
and the server must have registered the STags
with an appropriate registration mechanism.
</t>
</section>

</section>

<section
 title="Error Reporting Changes"
 anchor="section:E554DF42-6E82-4E28-96A0-8F9872EB476C">
<t>
RPC-over-RDMA version 2 expands the repertoire of errors that
may be reported by connection endpoints.
This is to enable extensibility,
to report overruns of specific resources,
and to avoid requester retries when an error is permanent.
</t>
</section>

</section>

<section
 title="RPC-over-RDMA Version 2 Headers and Chunks"
 anchor="section:57D26E97-DA93-4F0B-B85E-549194A17ABC">
<t>
Most RPC-over-RDMA version 2 data structures are derived
from corresponding structures in RPC-over-RDMA version 1,
although they have new XDR structure names.
</t>
<t>
This section describes those that are modified or are new,
with the exception of those associated
with the transport properties model, which are described in
<xref target="section:1759FE4A-C740-4BC9-952A-38EF64734B8C"/>.
</t>

<section
 title="rpcrdma2_chunk_lists: Describe Data Payload"
 anchor="section:C71B7DDF-7E7F-4C93-AF29-174D7D8B005A">
<t>
The rpcrdma2_chunk_lists structure is specifies how an RPC message
is conveyed using explicit RDMA operations.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

struct rpcrdma2_chunk_lists {
        uint32                      rdma_inv_handle;
        struct rpcrdma2_read_list   *rdma_reads;
        struct rpcrdma2_write_list  *rdma_writes;
        struct rpcrdma2_write_chunk *rdma_reply;
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
For the most part this structure parallels
its RPC-over-RDMA version 1 equivalent.
That is, rdma_reads, rdma_writes, rdma_reply provide, respectively,
descriptions of the chunks used to read a long request or directly
placed data from the requester, to write directly placed response
data into the requester's memory, and to write a long reply into the
requester's memory.
</t>
<t>
An important addition relative to the corresponding RPC-over-RDMA version 1
rdma_header structures is the rdma_inv_handle field.
This field supports remote invalidation
of requester memory registrations
via the RDMA Send With Invalidate operation.
</t>
<t>
To request Remote Invalidation, a requester sets the value of the
rdma_inv_handle field in an RPC Call's transport header to a non-zero
value that matches one of the rdma_handle fields in that header.  If
none of the rdma_handle values in the header conveying the Call may
be invalidated by the responder, the requester sets the RPC Call's
rdma_inv_handle field to the value zero.
</t>
<t>
If the responder chooses not to use Remote Invalidation for this
particular RPC Reply, or the RPC Call's rdma_inv_handle field
contains the value zero, the responder uses RDMA Send to transmit the
matching RPC reply.
</t>
<t>
If a requester has provided a non-zero value in the RPC Call's
rdma_inv_handle field and the responder chooses to use Remote
Invalidation for the matching RPC Reply, the responder uses RDMA Send
With Invalidate to transmit that RPC reply, and uses the value in the
corresponding Call's rdma_inv_handle field to construct the Send With
Invalidate Work Request.
</t>

</section>

<section
 title="rpcrdma_common: Common Transport Header Prefix"
 anchor="section:9CC49501-81BA-4313-A391-57C1836D76B7">
<t>
The rpcrdma_common prefix describes the first part
of each RDMA-over-RPC transport header for version 2
and subsequent versions.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

struct rpcrdma_common {
             uint32         rdma_xid;
             uint32         rdma_vers;
             uint32         rdma_credit;
             uint32         rdma_htype;
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
Although RPC-over-RDMA version 2's use of these first four words
matches that of version 1,
there are important structural differences in the way that these words
are described by the respective XDR descriptions:
<list style="symbols">
<t>
The header type is represented as a uint32 rather than as an enum
that would need to be modified to reflect additions to the set of
header types made by later extensions.
</t>
<t>
The header type field is part of an XDR structure devoted to
representing the transport header prefix, rather than being part
of a discriminated union, that includes the body of each transport
header type.
</t>
<t>
The prefix structure (see next section)
is a defined XDR object within the protocol
description, whereas in RPC-over-RDMA version 1,
it is not treated as such but is referred to in the text
without reference to its XDR realization.
</t>
</list>
These changes are part of a larger structural change in the XDR
description of version 2 in order to enable a cleaner treatment
of protocol extension.
This change is discussed in further detail in
<xref target="section:49CF0D80-6BE4-4103-B5B1-B37344991E2D"/>.
</t>
</section>

<section
 title="rpcrdma2_hdr_prefix: Version 2 Transport Header Prefix"
 anchor="section:F5CB1EE2-292B-48D3-8DDB-7F13A1FF41AF">
<t>
The following prefix structure appears at the start of any
RPC-over-RDMA version 2 transport header.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

const RPCRDMA2_F_RESPONSE           0x00000001;

struct rpcrdma2_hdr_prefix
        struct rpcrdma_common       rdma_start;
        uint32                      rdma_flags;
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
The RPCRDMA2_F_RESPONSE flag qualifies the values contained in the
transport header's rdma_xid and rdma_credits field.
This enables a receiver to reliably avoid performing an XID lookup
on incoming reverse direction Call messages,
and apply the value of the rdma_credits field correctly.
</t>
<t>
In general, when a message carries an XID that was generated by the
message's receiver (that is, the receiver is acting as a requester),
the message's sender sets the RPCRDMA2_F_RESPONSE flag.
Otherwise that flag is clear.
For example:
<list style="symbols">
<t>
When the rdma_start.rdma_htype field has the value RDMA2_MSG or
RDMA2_NOMSG, the value of the RPCRDMA2_F_RESPONSE flag MUST be the
same as the value of the associated RPC message's msg_type field.
</t>
<t>
When is anything else and a whole or partial RPC message payload
is present, the value of the RPCRDMA2_F_RESPONSE flag MUST be the
same as the value of the associated RPC message's msg_type field.
</t>
<t>
When the transport has no RPC message payload is present, a
Requester MUST set the value of the rdma_optdir field to CALL, and
a Responder MUST set the value of the rdma_optdir field to REPLY.
The Requester chooses a value for the rdma_xid field from the XID
space that matches the message's direction.  Requesters and
Responders set the rdma_credit field in a similar fashion: a value
is set that is appropriate for the direction of the message.
<vspace blankLines="1"/>
[DN: Left this as is even though the source is not clear;
problem is that assumes that the sender somehow knows whether he is a
requester or responder, even when he is not sending a message.
A participant can know whether he is a client or server but only
knows whether he is a sender or receiver in the context of sending
an RPC request.]
</t>
<t>
When the rdma_start.rdma_htype field has the value RDMA2_ERROR,
the RPCRDMA2_F_RESPONSE flag MUST be set.
</t>
</list>
</t>
</section>

</section>

<section
 title="Transport Properties"
 anchor="section:D8CD3EE6-E4FF-43FC-9611-B075E5A70634">
<t>
RPC-over-RDMA version 2 provides a mechanism for endpoints to communicate
information about implementation properties, enabling compatible endpoints
to optimize data transfer.
Initially only a small set of transport properties are defined
and a single operation is provided to exchange transport properties
(see <xref target="section:49CB5805-E206-4EF3-AEAC-7FF82C2F4F86"/>).
</t>
<t>
Both the set of transport properties and the operations used to
communicate are subject to extension.
Within RPC-over-RDMA version 2, all such extensions are OPTIONAL.
For information about existing transport properties, see Sections
<xref target="section:1759FE4A-C740-4BC9-952A-38EF64734B8C"
 format="counter" pageno="false"/>
through
<xref target="section:06A2CD00-F8D9-4C22-B5D8-404F68B5FC70"
 format="counter" pageno="false"/>.
For discussion of extensions to the set of transport properties, see
<xref target="section:9AE32E93-0B53-406B-835D-9A677A8793B3"/>.
</t>

<section
 title="Transport Properties Model"
 anchor="section:1759FE4A-C740-4BC9-952A-38EF64734B8C">
<t>
A basic set of receiver and sender properties is specified in this document.
An extensible approach is used, allowing new properties to be defined
in future Standards Track documents.
</t>
<t>
Such properties are specified using:
<list style="symbols">
<t>
A code identifying the particular transport property being specified.
</t>
<t>
A nominally opaque array which contains within it the XDR encoding
of the specific property indicated by the associated code.
</t>
</list>
</t>
<t>
The following XDR types are used by operations that deal with
transport properties:
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

typedef rpcrdma2_propid uint32;

struct rpcrdma2_propval {
        rpcrdma2_propid rdma_which;
        opaque          rdma_data&lt;&gt;;
};

typedef rpcrdma2_propval rpcrdma2_propset&lt;&gt;;

typedef uint32 rpcrdma2_propsubset&lt;&gt;;

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
An rpcrdma2_propid specifies a particular transport property.
In order to allow easier XDR extension of the set of properties
by concatenating XDR files, specific properties are defined
as const values rather than as elements in an enum.
</t>
<t>
An rpcrdma2_propval specifies a value of a particular transport
property with the particular property identified by rdma_which,
while the associated value of that property is contained within rdma_data.
</t>
<t>
An rdma_data field which is of zero length is interpreted as
indicating the default value or the property indicated by rdma_which.
</t>
<t>
While rdma_data is defined as opaque within the XDR, the contents are
interpreted (except when of length zero) using the XDR typedef
associated with the property specified by rdma_which.  The receiver
of a message containing an rpcrdma2_propval MUST report the error
RDMA2_ERR_BAD_XDR if the length of rdma_data is such that it extends
beyond the bounds of the message transferred.
</t>
<t>
In cases in which the rpcrdma2_propid specified by rdma_which is
understood by the receiver, the receiver also MUST report the error
RDMA2_ERR_BAD_XDR if either of the following occur:
<list style="symbols">
<t>
The nominally opaque data within rdma_data is not valid when
interpreted using the property-associated typedef.
</t>
<t>
The length of rdma_data is insufficient to contain the data
represented by the property-associated typedef.
</t>
</list>
Note that no error is to be reported if rdma_which is unknown to the receiver.
In that case, that rpcrdma2_propval is not processed and processing continues
using the next rpcrdma2_propval, if any.
</t>
<t>
A rpcrdma2_propset specifies a set of transport properties.
No particular ordering of the rpcrdma2_propval items within it is imposed.
</t>
<t>
A rpcrdma2_propsubset identifies a subset of the properties in a
previously specified rpcrdma2_propset.
Each bit in the mask denotes a particular element in a previously
specified rpcrdma2_propset.
If a particular rpcrdma2_propval is at position N in the array,
then bit number N mod 32 in word N div 32 specifies whether
that particular rpcrdma2_propval is included in the defined subset.
Words beyond the last one specified are treated as containing zero.
</t>
</section>

<section
 title="Transport Property Groups"
 anchor="section:BD24BFF3-F87B-4D13-829D-DD5BEAEA5ED8">
<t>
Transport properties are divided into a number of groups:
<list style="symbols">
<t>
A basic set of transport properties defined in
<xref target="section:06A2CD00-F8D9-4C22-B5D8-404F68B5FC70"/>.
</t>
<t>
Additional transport properties defined in future standards track
documents as specified in
<xref target="section:D3F41AD3-6436-436C-AD24-18587F8216C2"/>.
</t>
<t>
Experimental transport properties being explored
preparatory to being considered for standards track definition.
See the discussion in
<xref target="section:18627B78-6D48-4F85-8104-88426BEAF7DF"/>.
</t>
</list>
</t>
</section>

</section>

<section
 title="Basic Transport Properties"
 anchor="section:06A2CD00-F8D9-4C22-B5D8-404F68B5FC70">
<t>
Although the set of transport properties is subject to later extension,
a basic set of transport properties is defined in
<xref target="table:81309FE4-A924-4CE6-A5A7-DD6ACEFB72EE"/>.
</t>
<t>
In that table, the columns contain the following information:
<list style="symbols">
<t>
The column labeled "property" identifies the transport property
described by the current row.
</t>
<t>
The column labeled "code" specifies the rpcrdma2_propid value used
to identify this property.
</t>
<t>
The column labeled "XDR type" gives the XDR type of the data used
to communicate the value of this property.  This data type
overlays the data portion of the nominally opaque field rdma_data
in a rpcrdma2_propval.
</t>
<t>
The column labeled "default" gives the default value for the
property which is to be assumed by those who do not receive, or
are unable to interpret, information about the actual value of the
property.
</t>
<t>
The column labeled "sec" indicates the section (within this
document) that explains the semantics and use of this transport
property.
</t>
</list>
</t>
<texttable
 align="left"
 style="full"
 anchor="table:81309FE4-A924-4CE6-A5A7-DD6ACEFB72EE">
<ttcol align="left">property</ttcol>
<ttcol align="left">code</ttcol>
<ttcol align="left">XDR type</ttcol>
<ttcol align="left">default</ttcol>
<ttcol align="left">sec</ttcol>
<c>Receive Buffer Size</c>
<c>1</c>
<c>uint32</c>
<c>4096</c>
<c>
<xref target="section:D1323C3B-F719-4B06-B7D3-FFF9FF1D6C7F"
 format="counter" pageno="false"/>
</c>
<c>Reverse Request Support</c>
<c>2</c>
<c>enum rpcrdma2_rvreqsup</c>
<c>RDMA2_RVREQSUP_INLINE</c>
<c>
<xref target="section:B27C507D-F351-418B-BF0A-76983D0B3300"
 format="counter" pageno="false"/>
</c>
</texttable>

<section
 title="Receive Buffer Size"
 anchor="section:D1323C3B-F719-4B06-B7D3-FFF9FF1D6C7F">
<t>
The Receive Buffer Size specifies the minimum size, in octets, of
pre-posted receive buffers.
It is the responsibility of the participant sending this value
to ensure that its pre-posted receives are at least the size specified,
allowing the participant receiving this value to send messages
that are of this size.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

const uint32 RDMA2_PROPID_RBSIZ = 1;
typedef uint32 rpcrdma2_prop_rbsiz;

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
The sender may use his knowledge of the receiver's buffer size to
determine when the message to be sent will fit in the preposted
receive buffers that the receiver has set up.
In particular,
<list style="symbols">
<t>
Requesters may use the value to determine when it is necessary to
provide a Position-Zero read chunk when sending a request.
</t>
<t>
Requesters may use the value to determine when it is necessary to
provide a Reply chunk when sending a request, based on the maximum
possible size of the reply.
</t>
<t>
Responders may use the value to determine when it is necessary,
given the actual size of the reply, to actually use a Reply chunk
provided by the requester.
</t>
</list>
</t>
</section>

<section
 title="Reverse Request Support"
 anchor="section:B27C507D-F351-418B-BF0A-76983D0B3300">
<t>
The value of this property is used to indicate a client implementation's
readiness to accept and process messages that are part
of reverse direction RPC requests.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

enum rpcrdma2_rvreqsup {
        RDMA2_RVREQSUP_NONE    = 0,
        RDMA2_RVREQSUP_INLINE  = 1,
        RDMA2_RVREQSUP_GENL    = 2
};

const uint32 RDMA2_PROPID_BRS = 2;
typedef rpcrdma2_rvreqsup rpcrdma2_prop_brs;

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
Multiple levels of support are distinguished:
<list style="symbols">
<t>
The value RDMA2_RVREQSUP_NONE indicates that receipt of reverse
direction requests and replies is not supported.
</t>
<t>
The value RDMA2_RVREQSUP_INLINE indicates that receipt of reverse
direction requests or replies is only supported using inline
messages and that use of explicit RDMA operations or other form of
Direct Data Placement for reverse direction requests or responses
is not supported.
</t>
<t>
The value RDMA2_RVREQSUP_GENL that receipt of reverse direction
requests or replies is supported in the same ways that forward
direction requests or replies typically are.
</t>
</list>
</t>
<t>
When information about this property is not provided,
the support level of servers can be inferred
from the reverse direction requests that they issue,
assuming that issuing a request implicitly indicates support
for receiving the corresponding reply.
On this basis, support for receiving inline replies
can be assumed when requests without
Read chunks, Write chunks, or Reply chunks are issued,
while requests with any of these elements allow the client to assume
that general support for reverse direction replies is present on the server.
</t>
</section>

</section>

<section
 title="Additional Properties"
 anchor="section:9AE32E93-0B53-406B-835D-9A677A8793B3">

<section
 title="Additional OPTIONAL Properties"
 anchor="section:D3F41AD3-6436-436C-AD24-18587F8216C2">
<t>
The set of transport properties is designed to be extensible.
As a result, once new properties are defined in standards track documents,
the operations defined in this document may reference these new
transport properties, as well as the ones described in this document.
</t>
<t>
A standards track document defining a new transport property should
include the following information paralleling that provided in this
document for the transport properties defined herein.
<list style="symbols">
<t>
The rpcrdma2_propid value used to identify this property.
</t>
<t>
The XDR typedef specifying the form in which the property value is
communicated.
</t>
<t>
A description of the transport property that is communicated by
the sender of RDMA2_CONNPROP and RDMA2_UPDPROP and requested by
the sender of RDMA2_REQPROP.
</t>
<t>
An explanation of how this knowledge could be used by the
participant receiving this information.
</t>
<t>
Information giving rules governing possible changes of values of
this property.
</t>
</list>
</t>
<t>
The definition of transport property structures is such as to make it
easy to assign unique values.
There is no requirement that a continuous set of values be used and
implementations should not rely on all such values being small integers.
A unique value should be selected when the defining document is first
published as an internet draft.
When the document becomes a standards track document working group
should insure that:
<list style="symbols">
<t>
rpcrdma2_propid values specified in the document do not conflict
with those currently assigned or in use by other pending working
group documents defining transport properties.
</t>
<t>
rpcrdma2_propid values specified in the document do not conflict
with the range reserved for experimental use, as defined in
Section 8.2.
</t>
</list>
</t>
<t>
Documents defining new properties fall into a number of categories.
<list style="symbols">
<t>
Those defining new properties and explaining (only) how they
affect use of existing message types.
</t>
<t>
Those defining new OPTIONAL message types and new properties
applicable to the operation of those new message types.
</t>
<t>
Those defining new OPTIONAL message types and new properties
applicable both to new and existing message types.
</t>
</list>
</t>
<t>
When additional transport properties are proposed, the review of the
associated standards track document should deal with possible
security issues raised by those new transport properties.
</t>
</section>

<section
 title="Experimental Properties"
 anchor="section:18627B78-6D48-4F85-8104-88426BEAF7DF">
<t>
Given the design of the transport properties data structure, it is
possible to use the operations to implement experimental, possibly
unpublished, transport properties.
rpcrdma2_propid values in the range from 4,294,967,040 to
4,294,967,295 are reserved for experimental use and these values
should not be assigned to new properties in standards track
documents.
</t>
<t>
When values in this range are used there is no guarantee of
successful interoperation among independent implementations.
However, it is possible to convert an experimental property to a
candidate OPTIONAL property by assigning a new rpcrdma_propval
outside the experimental range, as part of the process of defining
the property in a standards-track document.
</t>
<t>
Once such extension documents are published, the additions become
part of RPC-over-RDMA version 2.
Because the extensions are OPTIONAL, existing implementations
will continue to interoperate with implementations incorporating
the new features while other implementations using the new features
will be able to interoperate with implementations that either do
or do not support the extension.
</t>
</section>

</section>

<section
 title="RPC-over-RDMA Version 2 Transport Messages"
 anchor="section:9A92CD43-57D9-43BC-9E5C-430BDD3A055B">

<section
 title="Overall Transport Message Structure"
 anchor="section:A45DB8BA-51AB-41FA-AE67-1B9C1A132945">
<t>
Each transport message consists of multiple sections:
<list style="symbols">
<t>
A transport header prefix, as defined in
<xref target="section:F5CB1EE2-292B-48D3-8DDB-7F13A1FF41AF"/>.
Among other things, this structure indicates the header type.
</t>
<t>
The transport header proper, as defined by one of the sub-sections below.
See <xref target="section:DF5A4B03-DF1E-4D22-8157-1AAAC541D986"/>
for the mapping between header types and the corresponding header structure.
</t>
<t>
Potentially, an RPC message being conveyed as an addendum to the header.
</t>
</list>
</t>
<t>
This organization differs from that presented in the definition of
RPC-over-RDMA version 1 <xref target="RFC8166"/>,
which presented the first and second of the items above as a single XDR item.
The new organization is more in keeping with RPC-over-RDMA version 2's
extensibility model in that new header types can be defined without
modifying the existing set of header types.
</t>
</section>

<section
 title="Transport Header Types"
 anchor="section:DF5A4B03-DF1E-4D22-8157-1AAAC541D986">
<t>
The new header types within RPC-over-RDMA version 2
are set forth in <xref target="table:7A17DE91-36B7-4664-B863-CE0BF1F817F4"/>.
In that table, the columns contain the following information:
<list style="symbols">
<t>
The column labeled "operation" specifies the particular operation.
</t>
<t>
The column labeled "code" specifies the value of header type for
this operation.
</t>
<t>
The column labeled "XDR type" gives the XDR type of the data
structure used to describe the information in this new message type.
This data immediately follows the universal portion on the
transport header present in every RPC-over-RDMA transport header.
</t>
<t>
The column labeled "msg" indicates whether this operation is
followed (or not) by an RPC message payload.
</t>
<t>
The column labeled "sec" indicates the section (within this
document) that explains the semantics and use of this operation.
</t>
</list>
</t>
<texttable
 align="left"
 style="full"
 anchor="table:7A17DE91-36B7-4664-B863-CE0BF1F817F4"
 title=""
 suppress-title="false">
<ttcol align="left">operation</ttcol>
<ttcol align="left">code</ttcol>
<ttcol align="left">XDR type</ttcol>
<ttcol align="left">msg</ttcol>
<ttcol align="left">status</ttcol>
<ttcol align="left">sec</ttcol>
<c>Convey RPC Message Inline</c>
<c>0</c>
<c>rpcrdma2_msg</c>
<c>Yes</c>
<c>REQ</c>
<c><xref target="section:22BDF040-68EC-4A58-A1AF-F8777C842819"
 format="counter" pageno="false"/></c>
<c>Convey RPC Message Out if line</c>
<c>1</c>
<c>rpcrdma2_nomsg</c>
<c>No</c>
<c>REQ</c>
<c><xref target="section:F5C1CF00-AB6E-469A-A79D-103C33B65C50"
 format="counter" pageno="false"/></c>
<c>Report Transport Error</c>
<c>4</c>
<c>rpcrdma2_err</c>
<c>No</c>
<c>REQ</c>
<c><xref target="section:9708EE05-F5EE-417E-86FA-09C276BE56FA"
 format="counter" pageno="false"/></c>
<c>Specify Properties at Connection</c>
<c>5</c>
<c>optinfo_connprop</c>
<c>No</c>
<c>REQ</c>
<c><xref target="section:49CB5805-E206-4EF3-AEAC-7FF82C2F4F86"
 format="counter" pageno="false"/></c>
</texttable>
<t>
Support for additional operations will be OPTIONAL.
RPC-over-RDMA version 2 implementations that receive an OPTIONAL operation
that is not supported MUST respond with an RDMA_ERROR message
with an error code of RDMA_ERR_INVAL_OPTION.
</t>
</section>

<section
 title="Header Types Present in RPC-over-RDMA version 1"
 anchor="section:7AEC2E7C-9F70-4BE0-8570-72C62EE908B2">
<t>
The header types defined and used in RPC-over-RDMA version 1
are all carried over into RPC-over-RDMA version 2,
although they may be limited changes in the definition of existing
header types.
To simplify interoperability with RPC-over-RDMA version 1,
only RDMA2_ERROR (defined in
<xref target="section:9708EE05-F5EE-417E-86FA-09C276BE56FA"/>)
is modified from version 1,
and its modifications are all compatible extensions.
</t>

<section
 title="RDMA2_MSG: Convey RPC Message Inline"
 anchor="section:22BDF040-68EC-4A58-A1AF-F8777C842819">
<t>
RDMA2_MSG is used to convey an RPC message that is sent inline.
This is either an RPC request that has no Position-Zero Read chunk
or an RPC reply that is not sent using a Reply chunk.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_MSG = 0;

struct rpcrdma2_msg {
        struct rpcrdma2_chunk_lists  rdma_chunks;

        /* The rpc message starts here and continues
         * through the end of the transmission. */
        uint32                       rdma_rpc_first_word;
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
</section>

<section
 title="RDMA2_NOMSG: Convey RPC Message Out of Line"
 anchor="section:F5C1CF00-AB6E-469A-A79D-103C33B65C50">
<t>
RDMA2_NOMSG is used to convey an RPC message that cannot be sent inline,
because it would not fit within the size limits that result from the
receiver's inline threshold.
[CL: Not quite: a client may choose to send a small request this way as well]
The message can be a long request, which is RDMA Read
from the requester's memory area specified by a Position-Zero Read chunk,
or a long reply,
which is RDMA written into the requester's memory area specified by a Reply chunk.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_NOMSG = 1;

struct rpcrdma2_nomsg {
        struct rpcrdma2_chunk_lists  rdma_chunks;
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
</section>

<section
 title="RDMA2_ERROR: Report Transport Error"
 anchor="section:9708EE05-F5EE-417E-86FA-09C276BE56FA">
<t>
RDMA2_ERROR provides a way of reporting the occurrence of transport
errors on a previous transmission.
It is restricted to reporting problems when RPC requests are transmitted.
[DN: this is a credit-related issue that needs to be addressed.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

const rpcrdma2_proc RDMA2_ERROR = 4;

enum rpcrdma2_errcode {
        RDMA2_ERR_VERS = 1,
        RDMA2_ERR_BAD_XDR = 2,
        RDMA2_ERR_INVAL_PROC = 3,
        RDMA2_ERR_READ_CHUNKS = 4,
        RDMA2_ERR_WRITE_CHUNKS = 5,
        RDMA2_ERR_SEGMENTS = 6,
        RDMA2_ERR_WRITE_RESOURCE = 7,
        RDMA2_ERR_REPLY_RESOURCE = 8,
        RDMA2_ERR_INVAL_OPTION = 9,
        RDMA2_ERR_SYSTEM = 10,
};

struct rpcrdma2_err_vers {
        uint32 rdma_vers_low;
        uint32 rdma_vers_high;
};

struct rpcrdma2_err_write {
        uint32 rdma_chunk_index;
        uint32 rdma_length_needed;
};

union rpcrdma2_error switch (rpcrdma2_errcode rdma_err) {
        case RDMA2_ERR_VERS:
          rpcrdma2_err_vers rdma_vrange;
        case RDMA2_ERR_BAD_XDR:
          void;
        case RDMA2_ERR_INVAL_PROC:
          void;
        case RDMA2_ERR_READ_CHUNKS:
          uint32 rdma_max_chunks;
        case RDMA2_ERR_WRITE_CHUNKS:
          uint32 rdma_max_chunks;
        case RDMA2_ERR_SEGMENTS:
          uint32 rdma_max_segments;
        case RDMA2_ERR_WRITE_RESOURCE:
          rpcrdma2_err_write rdma_writeres;
        case RDMA2_ERR_REPLY_RESOURCE:
          uint32 rdma_length_needed;
        case RDMA2_ERR_INVAL_OPTION:
          void;
        case RDMA2_ERR_SYSTEM:
          void;
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
Error reporting is addressed in RPC-over-RDMA version 2
in a fashion similar to RPC-over-RDMA version 1.
Several new error codes, and error messages
never flow from requester to responder.
RPC-over-RDMA version 1 error reporting
is described in Section 5 of <xref target="RFC8166"/>.
</t>
<t>
In all cases below, the responder copies the values of the rdma_xid
and rdma_vers fields from the incoming transport header that
generated the error to transport header of the error response.
The responder sets the rdma_start.rdma_htype field of the transport
header prefix to RDMA2_ERROR, and the rdma_start.rdma_credit field is
set to the credit grant value for this connection.
</t>
<t>
<list style="hanging">
<t hangText="RDMA2_ERR_VERS">
<vspace/>
This is the equivalent of ERR_VERS in RPC-over-RDMA version 1.
The error code value, semantics, and utilization are the same.
</t>
<t hangText="RDMA2_ERR_INVAL_PROC">
<vspace/>
If a responder recognizes the value in the rdma_vers field, but
it does not recognize the value in the rdma_proc field,
it MUST set the rdma_err field to RDMA2_ERR_INVAL_PROC.
</t>
<t hangText="RDMA2_ERR_BAD_XDR">
<vspace/>
If a responder recognizes the values in the rdma_vers and rdma_proc
fields, but the incoming RPC-over-RDMA transport header cannot be
parsed, it MUST set the rdma_err field to RDMA2_ERR_BAD_XDR.
The error code value of RDMA2_ERR_BAD_XDR is the same as
the error code value of ERR_CHUNK in RPC-over-RDMA version 1.
The responder MUST NOT process the request in any way
except to send an error message.
</t>
<t hangText="RDMA2_ERR_READ_CHUNKS">
<vspace/>
If a requester presents more DDP-eligible arguments than the responder
is prepared to Read,
the responder MUST set the rdma_err field to RDMA2_ERR_READ_CHUNKS,
and set the rdma_max_chunks field to the maximum number of
Read chunks the responder can receive and process.
<vspace/>
If the responder implementation cannot handle any Read chunks
for a request, it MUST set the rdma_max_chunks to zero in this response.
The requester SHOULD resend the request using a Position-Zero Read chunk.
If this was a request using a Position-Zero Read chunk,
the requester MUST terminate the transaction with an error.
</t>
<t hangText="RDMA2_ERR_WRITE_CHUNKS">
<vspace/>
If a requester has constructed an RPC Call message with
more DDP-eligible results than the server is prepared to Write,
the responder MUST set the rdma_err field to RDMA2_ERR_WRITE_CHUNKS,
and set the rdma_max_chunks field to the maximum number of
Write chunks the responder can process and return.
<vspace/>
If the responder implementation cannot handle any Write chunks for a
request, it MUST return a response of RDMA2_ERR_REPLY_RESOURCE (below).
The requester SHOULD resend the request with no Write chunks and
a Reply chunk of appropriate size.
</t>
<t hangText="RDMA2_ERR_SEGMENTS">
<vspace/>
If a requester has constructed an RPC Call message with a
chunk that contains more segments than the responder supports,
the responder MUST set the rdma_err field to RDMA2_ERR_SEGMENTS,
and set the rdma_max_segments field to the maximum number of
segments the responder can process.
</t>
<t hangText="RDMA2_ERR_WRITE_RESOURCE">
<vspace/>
If a requester has provided a Write chunk that is not large enough
to convey a DDP-eligible result,
the responder MUST set the rdma_err field to RDMA2_ERR_WRITE_RESOURCE.
<vspace/>
<vspace/>
The responder MUST set the rdma_chunk_index field to point to the
first Write chunk in the transport header that is too short, or to
zero to indicate that it was not possible to determine which chunk
is too small.
Indexing starts at one (1), which represents the first Write chunk.
The responder MUST set the rdma_length_needed to the number of bytes
needed in that chunk in order to convey the result data item.
<vspace/>
<vspace/>
Upon receipt of this error code,
a responder MAY choose to terminate the operation
(for instance, if the responder set the index and length fields to zero),
or it MAY send the request again using the same XID and more
reply resources.
</t>
<t hangText="RDMA2_ERR_REPLY_RESOURCE">
<vspace/>
If an RPC Reply's Payload stream does not fit inline
and the requester has not provided a large enough Reply chunk
to convey the stream,
the responder MUST set the rdma_err field to RDMA2_ERR_REPLY_RESOURCE.
The responder MUST set the rdma_length_needed to the number of
Reply chunk bytes needed to convey the reply.
<vspace/>
<vspace/>
Upon receipt of this error code,
a responder MAY choose to terminate the operation
(for instance, if the responder set the index and length fields to zero),
or it MAY send the request again using the same XID and larger
reply resources.
</t>
<t hangText="RDMA2_ERR_INVAL_OPTION">
<vspace/>
A responder MUST set the rdma_err field to RDMA2_ERR_INVAL_OPTION
when an RDMA2_OPTIONAL message is received
and the responder does not recognize the value in the
rdma_opttype field.
</t>
<t hangText="RDMA2_ERR_SYSTEM">
<vspace/>
If some problem occurs on a responder that does not fit
into the above categories,
the responder MAY report it to the sender by setting
the rdma_err field to RDMA2_ERR_SYSTEM.
<vspace/>
<vspace/>
This is a permanent error: a requester that receives this error MUST
terminate the RPC transaction associated with the XID value in the
rdma_xid field.
</t>
</list>
</t>
</section>

</section>

</section>

<section
 title="New Header Types"
 anchor="section:9AC165FD-8C01-480E-BB01-873597CF71B7">

<section
 title="RDMA2_CONNPROP: Advertise Transport Properties"
 anchor="section:49CB5805-E206-4EF3-AEAC-7FF82C2F4F86">
<t>
The RDMA2_CONNPROP message type allows an RPC-over-RDMA endpoint,
whether client or server, to indicate to its partner relevant
transport properties that the partner might need to be aware of.
</t>
<t>
The message definition for this operation is as follows:
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

struct rpcrdma2_connprop {
        rpcrdma2_propset rdma_start;
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
All relevant transport properties that the sender is aware of should
be included in rdma_start.
Since support of each of the properties is OPTIONAL,
the sender cannot assume that the receiver will necessarily take note
of these properties.
The sender should be prepared for cases in which the partner continues
to assume that the default value for a particular property is still in effect.
</t>
<t>
Generally, a participant will send a RDMA2_CONNPROP message as the
first message after a connection is established.
Given that fact, the sender should make sure that the message can be received
by partners who use the default Receive Buffer Size.
The connection's initial receive buffer size is typically 1KB,
but it depends on the initial connection state of the RPC-over-RDMA
version in use.
</t>
<t>
Properties not included in rdma_start are to be treated by the peer
endpoint as having the default value and are not allowed to change
subsequently.
The peer should not request changes in such properties.
</t>
<t>
Those receiving an RDMA2_CONNPROP may encounter properties that they
do not support or are unaware of.
In such cases, these properties are simply ignored
without any error response being generated.
</t>
</section>

</section>

<section
 title="XDR Protocol Definition"
 anchor="section:49CF0D80-6BE4-4103-B5B1-B37344991E2D">
<t>
This section contains a description of the core features of
the RPC-over-RDMA version 2 protocol expressed in the XDR
language <xref target="RFC4506"/>.
</t>
<t>
Because of the need to provide for protocol extensibility,
without a need to modify an existing XDR definition,
this description has some important structural differences
from the corresponding XDR description for RPC-over-RDMA version 1,
which appears in <xref target="RFC8166"/>.
</t>
<t>
This description is divided into three parts:
<list style="symbols">
<t>
A code component license which appears in
<xref target="section:828F7C6D-4B91-423E-A9E5-281F2429B36E"/>.
</t>
<t>
An XDR description of the structures that are generally available
for use by transport header types including both those defined in
this document and those that may be defined as extensions.
This includes
definitions of the chunk-related structures derived from RPC-over-RDMA version 1,
the transport property model introduced in this document,
and a definition of the transport header prefixes that precede the
various transport header types.
This appears in
<xref target="section:CFB10C65-A962-4039-8781-A3F39C7B6F4C"/>.
</t>
<t>
An XDR description of the transport header types defined in this document,
including those derived from RPC-over-RDMA version 1
and those introduced in RPC-over-RDMA version 2.
This appears in
<xref target="section:84905CED-69F9-47DC-986D-4F37FEC1EFD9"/>.
</t>
</list>
</t>
<t>
This description is provided in a way that makes it simple
to extract into ready-to-compile form.
To enable the combination of this description with the descriptions
of subsequent extensions to RPC-over-RDMA version 2,
the extracted description can be combined with similar descriptions
published later, or those descriptions can be compiled separately.
Refer to
<xref target="section:44E280C7-58A4-4EDE-9799-11F1582AD8A6"/>
for details.
</t>

<section
 title="Code Component License"
 anchor="section:828F7C6D-4B91-423E-A9E5-281F2429B36E">
<t>
Code components extracted from this document must include the
following license text.
When the extracted XDR code is combined with other complementary
XDR code which itself has an identical license, only a single
copy of the license text need be preserved.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

/// /*
///  * Copyright (c) 2010-2018 IETF Trust and the persons
///  * identified as authors of the code.  All rights reserved.
///  *
///  * The authors of the code are:
///  * B. Callaghan, T. Talpey, C. Lever, and D. Noveck.
///  *
///  * Redistribution and use in source and binary forms, with
///  * or without modification, are permitted provided that the
///  * following conditions are met:
///  *
///  * - Redistributions of source code must retain the above
///  *   copyright notice, this list of conditions and the
///  *   following disclaimer.
///  *
///  * - Redistributions in binary form must reproduce the above
///  *   copyright notice, this list of conditions and the
///  *   following disclaimer in the documentation and/or other
///  *   materials provided with the distribution.
///  *
///  * - Neither the name of Internet Society, IETF or IETF
///  *   Trust, nor the names of specific contributors, may be
///  *   used to endorse or promote products derived from this
///  *   software without specific prior written permission.
///  *
///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
///  *   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///  */
///

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
</section>

<section
 title="Extraction and Use of XDR Definitions"
 anchor="section:44E280C7-58A4-4EDE-9799-11F1582AD8A6">
<t>
The reader can apply the following sed script to this
document to produce a machine-readable XDR description of
the RPC-over-RDMA version 2 protocol without any OPTIONAL
extensions.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

sed -n -e 's:^ */// ::p' -e 's:^ *///$::p'

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
That is, if this document is in a file called
"spec.txt" then the reader can do the following to extract
an XDR description file and store it in the file rpcrdma-v2.x.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

sed -n -e 's:^ */// ::p' -e 's:^ *///$::p' \
     &lt; spec.txt &gt; rpcrdma-v2.x

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
Although this file is a usable description of the base protocol,
when extensions are to supported, it may be desirable to divide into
multiple files.
The following script can be used for that purpose:
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

#!/usr/local/bin/perl
open(IN,"rpcrdma-v2.x");
open(OUT,"&gt;temp.x");
while(&lt;IN&gt;)
{
  if (m/FILE ENDS: (.*)$/)
    {
      close(OUT);
      rename("temp.x", $1);
      open(OUT,"&gt;temp.x");
    }
    else
    {
      print OUT $_;
    }
}
close(IN);
close(OUT);

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
<t>
Running the above script will result in two files:
<list style="symbols">
<t>
The file common.x, containing the license plus the common XDR
definitions which need to be made available to both the base
operations and any subsequent extensions.
</t>
<t>
The file baseops.x containing the XDR definitions for the base
operations, defined in this document.
</t>
</list>
</t>
<t>
Optional extensions to RPC-over-RDMA version 2,
published as Standards Track documents,
will have similar means of providing XDR that describes
those extensions.
Once XDR for all desired extensions is also extracted,
it can be appended to the XDR description file extracted
from this document to produce a consolidated XDR description
file reflecting all extensions selected for an RPC-over-RDMA
implementation.
</t>
<t>
Alternatively, the XDR descriptions can be compiled separately.
In this case the combination of common.x and baseops.x serves to
define the base transport, while using as XDR descriptions for
extensions, the XDR from the document defining that extension,
together with the file common.x, obtained from this document.
</t>
</section>

<section
 title="XDR Definition for RPC-over-RDMA Version 2 Core Structures"
 anchor="section:CFB10C65-A962-4039-8781-A3F39C7B6F4C">
<t>
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;
/// /*******************************************************************
///  *    Transport Header Prefixes
///  ******************************************************************/
///
/// struct rpcrdma_common {
///         uint32         rdma_xid;
///         uint32         rdma_vers;
///         uint32         rdma_credit;
///         uint32         rdma_htype;
/// };
///
/// /* From RFC 5531, Section 9 */
/// enum msg_type {
///         CALL = 0,
///         REPLY = 1
/// };
///
/// struct rpcrdma2_hdr_prefix
///         struct rpcrdma_common       rdma_start;
///         enum msg_type               rdma_direction;
/// };
///
/// /*******************************************************************
///  *    Chunks and Chunk Lists
///  ******************************************************************/
///
/// struct rpcrdma2_segment {
///         uint32 rdma_handle;
///         uint32 rdma_length;
///         uint64 rdma_offset;
/// };
///
/// struct rpcrdma2_read_segment {
///         uint32                  rdma_position;
///         struct rpcrdma2_segment rdma_target;
/// };
///
/// struct rpcrdma2_read_list {
///         struct rpcrdma2_read_segment rdma_entry;
///         struct rpcrdma2_read_list    *rdma_next;
/// };
///
/// struct rpcrdma2_write_chunk {
///         struct rpcrdma2_segment rdma_target&lt;&gt;;
/// };
///
/// struct rpcrdma2_write_list {
///         struct rpcrdma2_write_chunk rdma_entry;
///         struct rpcrdma2_write_list  *rdma_next;
/// };
///
/// struct rpcrdma2_chunk_lists {
///         uint32                      rdma_inv_handle;
///         struct rpcrdma2_read_list   *rdma_reads;
///         struct rpcrdma2_write_list  *rdma_writes;
///         struct rpcrdma2_write_chunk *rdma_reply;
/// };
///
/// /*******************************************************************
///  *    Transport Properties
///  ******************************************************************/
///
/// /*
///  * Types for transport properties model
///  */
/// typedef rpcrdma2_propid uint32;
///
/// struct rpcrdma2_propval {
///         rpcrdma2_propid rdma_which;
///         opaque          rdma_data&lt;&gt;;
/// };
///
/// typedef rpcrdma2_propval rpcrdma2_propset&lt;&gt;;
/// typedef uint32 rpcrdma2_propsubset&lt;&gt;;
///
/// /*
///  * Transport propid values for basic properties
///  */
/// const uint32 RDMA2_PROPID_RBSIZ = 1;
/// const uint32 RDMA2_PROPID_BRS = 2;
///
/// /*
///  * Types specific to particular properties
///  */
/// typedef uint32 rpcrdma2_prop_rbsiz;
/// typedef rpcrdma2_rvreqsup rpcrdma2_prop_brs;
///
/// enum rpcrdma2_rvreqsup {
///         RDMA2_RVREQSUP_NONE = 0,
///         RDMA2_RVREQSUP_INLINE = 1,
///         RDMA2_RVREQSUP_GENL = 2
/// };
///
/// /* FILE ENDS: common.x; */

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
</section>

<section
 title="XDR Definition for RPC-over-RDMA Version 2 Base Header Types"
 anchor="section:84905CED-69F9-47DC-986D-4F37FEC1EFD9">
<t>
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;
/// /*******************************************************************
///  *    Header Types Carried over from RPC-over-RDMA version 1
///  ******************************************************************/
///
/// const rpcrdma2_proc RDMA2_MSG = 0;
///
/// struct rpcrdma2_msg {
///         struct rpcrdma2_chunk_lists  rdma_chunks;
///
///         /* The rpc message starts here and continues
///          * through the end of the transmission. */
///         uint32                       rdma_rpc_first_word;
/// };
///
/// const rpcrdma2_proc RDMA2_NOMSG = 1;
///
/// struct rpcrdma2_nomsg {
///         struct rpcrdma2_chunk_lists  rdma_chunks;
/// };
///
/// const rpcrdma2_proc RDMA2_ERROR = 4;
///
/// enum rpcrdma2_errcode {
///         RDMA2_ERR_VERS = 1,
///         RDMA2_ERR_BAD_XDR = 2,
///         RDMA2_ERR_INVAL_PROC = 3,
///         RDMA2_ERR_READ_CHUNKS = 4,
///         RDMA2_ERR_WRITE_CHUNKS = 5,
///         RDMA2_ERR_SEGMENTS = 6,
///         RDMA2_ERR_WRITE_RESOURCE = 7,
///         RDMA2_ERR_REPLY_RESOURCE = 8,
///         RDMA2_ERR_INVAL_OPTION = 9,
///         RDMA2_ERR_SYSTEM = 10,
/// };
///
/// struct rpcrdma2_err_vers {
///         uint32 rdma_vers_low;
///         uint32 rdma_vers_high;
/// };
///
/// struct rpcrdma2_err_write {
///         uint32 rdma_chunk_index;
///         uint32 rdma_length_needed;
/// };
///
/// union rpcrdma2_error switch (rpcrdma2_errcode rdma_err) {
///         case RDMA2_ERR_VERS:
///           rpcrdma2_err_vers rdma_vrange;
///         case RDMA2_ERR_BAD_XDR:
///           void;
///         case RDMA2_ERR_INVAL_PROC:
///           void;
///         case RDMA2_ERR_READ_CHUNKS:
///           uint32 rdma_max_chunks;
///         case RDMA2_ERR_WRITE_CHUNKS:
///           uint32 rdma_max_chunks;
///         case RDMA2_ERR_SEGMENTS:
///           uint32 rdma_max_segments;
///         case RDMA2_ERR_WRITE_RESOURCE:
///           rpcrdma2_err_write rdma_writeres;
///         case RDMA2_ERR_REPLY_RESOURCE:
///           uint32 rdma_length_needed;
///         case RDMA2_ERR_INVAL_OPTION:
///           void;
///         case RDMA2_ERR_SYSTEM:
///           void;
/// };
///
/// /*******************************************************************
///  *    Header Types Added to RPC-over-RDMA version 2
///  ******************************************************************/
///
/// const rpcrdma2_proc RDMA2_CONNPROP = 5;
///
/// struct rpcrdma2_connprop {
///         rpcrdma2_propset rdma_start;
/// };
///
///
/// /* FILE ENDS: baseops.x; */

&lt;CODE ENDS&gt;
</artwork>
</figure>
</t>
</section>

<section
 title="Use of the XDR Description Files"
 anchor="section:9EB3F922-7928-4082-9A40-6D04EC32DE0C">
<t>
The three files common.x and baseops.x, when combined
with the XDR descriptions for extension defined later,
will produce a human-readable and compilable description
of the RPC-over-RDMA version 2 protocol with the included extensions.
</t>
<t>
While this XDR description can be useful in generating code
to encode and decode the transport and payload streams,
there are elements of the structure of RPC-over-RDMA version 2
which are not expressible within the XDR language as currently defined.
This requires implementations that use the output of the XDR processor
to provide additional code to bridge the gaps.
<list style="symbols">
<t>
While the values of transport properties are represented
within XDR as opaque values, the actual structures of each
of the properties are represented by XDR typedefs,
with the selection of the appropriate typedef described by text in
this document.
The determination of the appropriate typedef is not specified by XDR,
which does not possess the facilities necessary for that determination
to be specified in an extensible way.
<vspace blankLines="1"/>
This is similar to the way in which NFSv4 attributes are handled
<xref target="RFC7530"/> <xref target="RFC5661"/>.
As in that case, implementations that need to encode and decode these
nominally opaque entities need to use the protocol description
to determine the actual XDR representation underlay these
items described as opaque.
</t>
<t>
The transport stream is not represented as a single XDR object.
Instead, the header prefix is described by one XDR object  while
the rest of the header is described as another XDR object with
the mapping between the header type in the header prefix and the
XDR object representing the header type represented by tables
contained in this document, with additional mappings being
specifiable by a later extension document.
<vspace blankLines="1"/>
This situation is similar to that in which RPC message headers
contain program and procedure numbers, so that the XDR for
those request and replies can be used to encode and decode the
associated messages without requiring that all be present in a
single XDR specification.
As in that case, implementations need to use the header specification
to select the appropriate XDR-generated code to be used
in message processing.
</t>
<t>
The relationship between the transport stream and the payload
stream is not specified in the XDR itself,
although comments within the XDR text make clear
where transported messages, described by their own XDR, need to appear.
Such data by its nature is opaque to the transport,
although its form differs XDR opaque arrays.
<vspace blankLines="1"/>
Potential extensions allowing continuation of RPC messages
across transport message boundaries will require that message
assembly facilities, not specifiable within XDR, also be part
of transport implementations.
</t>
</list>
</t>
<t>
To summarize, the role of XDR in this specification
is more limited than for protocols which are themselves XDR programs,
where the totality of the protocol is expressible within the
XDR paradigm established for that purpose.
This more limited role reflects the fact that XDR lacks facilities
to represent the embedding of transported material
within the transport framework.
In addition, the need to cleanly accommodate extensions
has meant that those using rpcgen in their applications
need to take a more active role in providing the facilities that
cannot be expressed within XDR.
</t>
</section>

</section>

<section
 title="Protocol Version Negotiation"
 anchor="section:8399CF6C-D40F-4E55-8916-C8A5B94FBC93">
<t>
When an RPC-over-RDMA version 2 client establishes a
connection to a server, its first order of business is to
determine the server's highest supported protocol version.
</t>
<t>
As with RPC-over-RDMA version 1, upon connection a client
MUST NOT send more than a single RPC-over-RDMA message at a
time until it receives a valid non-error RPC-over-RDMA message
from the server that reports the server's credit limit.
</t>
<t>
First, the client sends a single valid RPC-over-RDMA message
with the value two (2) in the rdma_vers field.
Because the server might support only RPC-over-RDMA
version 1, this initial message can be no larger than the
version 1 default inline threshold of 1024 bytes.
</t>

<section
 title="Server Does Support RPC-over-RDMA Version 2"
 anchor="section:C8AFA920-EB80-499F-87AA-EEA586D911B1">
<t>
If the server does support RPC-over-RDMA version 2,
it sends RPC-over-RDMA messages back to the client
with the value two (2) in the rdma_vers field.
Both peers may use the default inline threshold value
for RPC-over-RDMA version 2 connections (4096 bytes).
</t>

</section>

<section
 title="Server Does Not Support RPC-over-RDMA Version 2"
 anchor="section:BE7C81D4-4541-41D4-87FA-CB9ABD4DEAD8">
<t>
If the server does not support RPC-over-RDMA version 2,
it MUST send an RPC-over-RDMA message to the client with the
same XID, with RDMA2_ERROR in the rdma_start.rdma_htype field,
and with the error code RDMA2_ERR_VERS.
This message also reports a range of protocol versions that
the server supports.
To continue operation, the client selects a protocol
version in the range of server-supported versions for
subsequent messages on this connection.
</t>
<t>
If the connection is lost immediately after an
RDMA2_ERROR / RDMA2_ERR_VERS message is received,
a client can avoid a possible version negotiation
loop when re-establishing another connection by assuming that
particular server does not support RPC-over-RDMA
version 2.
A client can assume the same situation (no server support
for RPC-over-RDMA version 2) if the initial negotiation message
is lost or dropped.
Once the negotiation exchange is complete, both peers may use
the default inline threshold value for the transport protocol
version that has been selected.
</t>

</section>

<section
 title="Client Does Not Support RPC-over-RDMA Version 2"
 anchor="section:367436EC-B091-4167-978F-2A942EF08FB8">
<t>
If the server supports the RPC-over-RDMA protocol version used in
Call messages from a client, it MUST send Replies with the same
RPC-over-RDMA protocol version that the client uses to
send its Calls.
The client MUST NOT change the version during the duration of the connection.
</t>

</section>

</section>

<section
 title="Security Considerations"
 anchor="section:912A2C09-95EC-4CB6-AA2B-2245726D9EDF">
<t>
The security considerations for RPC-over-RDMA version 2
are the same as those for RPC-over-RDMA version 1.
</t>

<section
 title="Security Considerations (Transport Properties)"
 anchor="section:3B0E673B-98D7-436D-BD6F-180180503DF6">
<t>
Like other fields that appear in each RPC-over-RDMA header,
property information is sent in the clear on the fabric
with no integrity protection, making it vulnerable to
man-in-the-middle attacks.
</t>
<t>
For example, if a man-in-the-middle were to change the value of
the Receive buffer size or the Requester Remote Invalidation boolean,
it could reduce connection performance or trigger loss of connection.
Repeated connection loss can impact performance or even prevent a
new connection from being established. Recourse is to deploy on a
private network or use link-layer encryption.
</t>
</section>

</section>

<section
 title="IANA Considerations"
 anchor="section:D235C884-6463-411F-BA34-6BCC82AB7A9F">
<t>
This document does not require actions by IANA.
</t>
</section>

</middle>

<back>

<references title="Normative References">
<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.4506.xml"?>
<?rfc include="reference.RFC.5531.xml"?>
<?rfc include="reference.RFC.8166.xml"?>
<?rfc include="reference.RFC.8174.xml"?>
</references>

<references title="Informative References">

<reference
 anchor="IBARCH"
 target="http://www.infinibandta.org/content/pages.php?pg=technology_download">
<front>
<title>InfiniBand Architecture Specification Volume 1</title>
<author>
<organization>InfiniBand Trade Association</organization>
</author>
<date month='March' year='2015'/>
</front>
<seriesInfo name='Release' value='1.3'/>
</reference>

<?rfc include="reference.RFC.5040.xml"?>
<?rfc include="reference.RFC.5041.xml"?>
<?rfc include="reference.RFC.5661.xml"?>
<?rfc include="reference.RFC.5662.xml"?>
<?rfc include="reference.RFC.5666.xml"?>
<?rfc include="reference.RFC.7530.xml"?>
<?rfc include="reference.RFC.8167.xml"?>
</references>

<section title="Acknowledgments" numbered="no">
<t>
The authors gratefully acknowledge the work of Brent Callaghan
and Tom Talpey on the original RPC-over-RDMA version 1
specification <xref target="RFC5666" />.
The authors also wish to thank
Bill Baker, Greg Marsden, and Matt Benjamin
for their support of this work.
</t>
<t>
The XDR extraction conventions were
first described by the authors of the NFS version 4.1
XDR specification <xref target="RFC5662" />.
Herbert van den Bergh suggested the replacement sed
script used in this document.
</t>
<t>
Special thanks go to
Transport Area Director Spencer Dawkins,
NFSV4 Working Group Chairs Spencer Shepler
and
Brian Pawlowski,
and
NFSV4 Working Group Secretary Thomas Haynes
for their support.
</t>
</section>

</back>

</rfc>
